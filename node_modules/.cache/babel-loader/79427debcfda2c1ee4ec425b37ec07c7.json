{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n'use strict';\n\nconst npm = {\n  assertOptions: require('assert-options'),\n  os: require('os'),\n  utils: require('../utils'),\n  errors: require('../errors'),\n  QueryFile: require('../queryFile')\n};\n/**\r\n * @class ParameterizedQuery\r\n * @description\r\n * **Alternative Syntax:** `ParameterizedQuery({text, values, ...})` &#8658; {@link ParameterizedQuery}\r\n *\r\n * Constructs a new {@link ParameterizedQuery} object.\r\n *\r\n * The alternative syntax supports advanced properties {@link ParameterizedQuery#binary binary} and {@link ParameterizedQuery#rowMode rowMode},\r\n * which are passed into $[pg], but not used by the class.\r\n *\r\n * All properties can also be set after the object's construction.\r\n *\r\n * This type extends the basic `{text, values}` object, by replacing it, i.e. when the basic object is used\r\n * with a query method, a new {@link ParameterizedQuery} object is created implicitly in its place.\r\n *\r\n * The type can be used in place of the `query` parameter, with any query method directly. And it never throws any error,\r\n * leaving it for query methods to reject with {@link errors.ParameterizedQueryError ParameterizedQueryError}.\r\n *\r\n * The type is available from the library's root: `pgp.ParameterizedQuery`.\r\n *\r\n * @param {string|QueryFile} text\r\n * A non-empty query string or a {@link QueryFile} object.\r\n *\r\n * Only the basic variables (`$1`, `$2`, etc) can be used in the query, because _Parameterized Queries_ are formatted by the database server.\r\n *\r\n * @param {array} [values]\r\n * Query formatting values. When it is not an `Array` and not `null`/`undefined`, it is automatically wrapped into an array.\r\n *\r\n * @returns {ParameterizedQuery}\r\n *\r\n * @see\r\n * {@link errors.ParameterizedQueryError ParameterizedQueryError}\r\n *\r\n * @example\r\n *\r\n * const PQ = require('pg-promise').ParameterizedQuery;\r\n *\r\n * // Creating a complete Parameterized Query with parameters:\r\n * const findUser = new PQ('SELECT * FROM Users WHERE id = $1', [123]);\r\n *\r\n * db.one(findUser)\r\n *     .then(user => {\r\n *         // user found;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n *\r\n * @example\r\n *\r\n * const PQ = require('pg-promise').ParameterizedQuery;\r\n *\r\n * // Creating a reusable Parameterized Query without values:\r\n * const addUser = new PQ('INSERT INTO Users(name, age) VALUES($1, $2)');\r\n *\r\n * // setting values explicitly:\r\n * addUser.values = ['John', 30];\r\n *\r\n * db.none(addUser)\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error=> {\r\n *         // error;\r\n *     });\r\n *\r\n * // setting values implicitly, by passing them into the query method:\r\n * db.none(addUser, ['Mike', 25])\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error=> {\r\n *         // error;\r\n *     });\r\n *\r\n */\n\nfunction ParameterizedQuery(text, values) {\n  if (!(this instanceof ParameterizedQuery)) {\n    return new ParameterizedQuery(text, values);\n  }\n\n  let currentError,\n      PQ = {},\n      changed = true;\n  const state = {\n    text,\n    binary: undefined,\n    rowMode: undefined\n  };\n\n  if (text && typeof text === 'object' && 'text' in text) {\n    text = npm.assertOptions(text, ['text', 'values', 'binary', 'rowMode']);\n    state.text = text.text;\n    state.binary = text.binary;\n    state.rowMode = text.rowMode;\n    setValues(text.values);\n  } else {\n    setValues(values);\n  }\n\n  function setValues(v) {\n    if (Array.isArray(v)) {\n      if (v.length) {\n        PQ.values = v;\n      } else {\n        delete PQ.values;\n      }\n    } else {\n      if (npm.utils.isNull(v)) {\n        delete PQ.values;\n      } else {\n        PQ.values = [v];\n      }\n    }\n  }\n  /**\r\n   * @name ParameterizedQuery#text\r\n   * @type {string|QueryFile}\r\n   * @description\r\n   * A non-empty query string or a {@link QueryFile} object.\r\n   */\n\n\n  Object.defineProperty(this, 'text', {\n    get() {\n      return state.text;\n    },\n\n    set(value) {\n      if (value !== state.text) {\n        state.text = value;\n        changed = true;\n      }\n    }\n\n  });\n  /**\r\n   * @name ParameterizedQuery#values\r\n   * @type {array}\r\n   * @description\r\n   * Query formatting parameters, depending on the type:\r\n   *\r\n   * - `null` / `undefined` means the query has no formatting parameters\r\n   * - `Array` - it is an array of formatting parameters\r\n   * - None of the above, means it is a single formatting value, which\r\n   *   is then automatically wrapped into an array\r\n   */\n\n  Object.defineProperty(this, 'values', {\n    get() {\n      return PQ.values;\n    },\n\n    set(value) {\n      setValues(value);\n    }\n\n  });\n  /**\r\n   * @name ParameterizedQuery#binary\r\n   * @type {boolean}\r\n   * @default undefined\r\n   * @description\r\n   * Activates binary result mode. The default is the text mode.\r\n   *\r\n   * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}\r\n   */\n\n  Object.defineProperty(this, 'binary', {\n    get() {\n      return state.binary;\n    },\n\n    set(value) {\n      if (value !== state.binary) {\n        state.binary = value;\n        changed = true;\n      }\n    }\n\n  });\n  /**\r\n   * @name ParameterizedQuery#rowMode\r\n   * @type {string}\r\n   * @default undefined\r\n   * @description\r\n   * Changes the way data arrives to the client, with only one value supported by $[pg]:\r\n   *  - `rowMode = 'array'` will make all data rows arrive as arrays of values.\r\n   *    By default, rows arrive as objects.\r\n   */\n\n  Object.defineProperty(this, 'rowMode', {\n    get() {\n      return state.rowMode;\n    },\n\n    set(value) {\n      if (value !== state.rowMode) {\n        state.rowMode = value;\n        changed = true;\n      }\n    }\n\n  });\n  /**\r\n   * @name ParameterizedQuery#error\r\n   * @type {errors.ParameterizedQueryError}\r\n   * @default undefined\r\n   * @readonly\r\n   * @description\r\n   * When in an error state, it is set to a {@link errors.ParameterizedQueryError ParameterizedQueryError} object. Otherwise, it is `undefined`.\r\n   *\r\n   * This property is primarily for internal use by the library.\r\n   */\n\n  Object.defineProperty(this, 'error', {\n    get() {\n      return currentError;\n    }\n\n  });\n  /**\r\n   * @method ParameterizedQuery#parse\r\n   * @description\r\n   * Parses the current object and returns a simple `{text, values}`, if successful,\r\n   * or else it returns a {@link errors.ParameterizedQueryError ParameterizedQueryError} object.\r\n   *\r\n   * This method is primarily for internal use by the library.\r\n   *\r\n   * @returns {{text, values}|errors.ParameterizedQueryError}\r\n   */\n\n  this.parse = () => {\n    const qf = state.text instanceof npm.QueryFile ? state.text : null;\n\n    if (!changed && !qf) {\n      return PQ;\n    }\n\n    const errors = [],\n          vals = PQ.values;\n    PQ = {\n      name: state.name\n    };\n    changed = true;\n    currentError = undefined;\n\n    if (qf) {\n      qf.prepare();\n\n      if (qf.error) {\n        PQ.text = state.text;\n        errors.push(qf.error);\n      } else {\n        PQ.text = qf[npm.QueryFile.$query];\n      }\n    } else {\n      PQ.text = state.text;\n    }\n\n    if (!npm.utils.isText(PQ.text)) {\n      errors.push('Property \\'text\\' must be a non-empty text string.');\n    }\n\n    if (!npm.utils.isNull(vals)) {\n      PQ.values = vals;\n    }\n\n    if (state.binary !== undefined) {\n      PQ.binary = state.binary;\n    }\n\n    if (state.rowMode !== undefined) {\n      PQ.rowMode = state.rowMode;\n    }\n\n    if (errors.length) {\n      return currentError = new npm.errors.ParameterizedQueryError(errors[0], PQ);\n    }\n\n    changed = false;\n    return PQ;\n  };\n}\n/**\r\n * @method ParameterizedQuery#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object's current state.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\n\n\nParameterizedQuery.prototype.toString = function (level) {\n  level = level > 0 ? parseInt(level) : 0;\n  const gap = npm.utils.messageGap(level + 1);\n  const pq = this.parse();\n  const lines = ['ParameterizedQuery {'];\n\n  if (npm.utils.isText(pq.text)) {\n    lines.push(gap + 'text: \"' + pq.text + '\"');\n  }\n\n  if (this.values !== undefined) {\n    lines.push(gap + 'values: ' + JSON.stringify(this.values));\n  }\n\n  if (this.binary !== undefined) {\n    lines.push(gap + 'binary: ' + JSON.stringify(this.binary));\n  }\n\n  if (this.rowMode !== undefined) {\n    lines.push(gap + 'rowMode: ' + JSON.stringify(this.rowMode));\n  }\n\n  if (this.error !== undefined) {\n    lines.push(gap + 'error: ' + this.error.toString(level + 1));\n  }\n\n  lines.push(npm.utils.messageGap(level) + '}');\n  return lines.join(npm.os.EOL);\n};\n\nmodule.exports = ParameterizedQuery;","map":null,"metadata":{},"sourceType":"script"}