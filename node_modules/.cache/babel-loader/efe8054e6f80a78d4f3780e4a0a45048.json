{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n'use strict';\n\nconst npm = {\n  assertOptions: require('assert-options'),\n  os: require('os'),\n  utils: require('../utils'),\n  errors: require('../errors'),\n  QueryFile: require('../queryFile')\n};\n/**\r\n * @class PreparedStatement\r\n * @description\r\n * **Alternative Syntax:** `PreparedStatement({name, text, values, ...})` &#8658; {@link PreparedStatement}\r\n *\r\n * Constructs a new $[Prepared Statement] object.\r\n *\r\n * The alternative syntax supports advanced properties {@link PreparedStatement#binary binary}, {@link PreparedStatement#rowMode rowMode}\r\n * and {@link PreparedStatement#rows rows}, which are passed into $[pg], but not used by the class.\r\n *\r\n * All properties can also be set after the object's construction.\r\n *\r\n * This type extends the basic `{name, text, values}` object, by replacing it, i.e. when the basic object is used\r\n * with a query method, a new {@link PreparedStatement} object is created implicitly in its place.\r\n *\r\n * The type can be used in place of the `query` parameter, with any query method directly. And it never throws any error,\r\n * leaving it for query methods to reject with {@link errors.PreparedStatementError PreparedStatementError}.\r\n *\r\n * The type is available from the library's root: `pgp.PreparedStatement`.\r\n *\r\n * @param {string} name\r\n * An arbitrary name given to this particular prepared statement. It must be unique within a single session and is\r\n * subsequently used to execute or deallocate a previously prepared statement.\r\n *\r\n * @param {string|QueryFile} text\r\n * A non-empty query string or a {@link QueryFile} object.\r\n *\r\n * Only the basic variables (`$1`, `$2`, etc) can be used in the query, because $[Prepared Statements] are formatted by the database server.\r\n *\r\n * @param {array} [values]\r\n * Query formatting values. When it is not an `Array` and not `null`/`undefined`, it is automatically wrapped into an array.\r\n *\r\n * @returns {PreparedStatement}\r\n *\r\n * @see\r\n * {@link errors.PreparedStatementError PreparedStatementError},\r\n * {@link http://www.postgresql.org/docs/9.5/static/sql-prepare.html PostgreSQL Prepared Statements}\r\n *\r\n * @example\r\n *\r\n * const PS = require('pg-promise').PreparedStatement;\r\n *\r\n * // Creating a complete Prepared Statement with parameters:\r\n * const findUser = new PS('find-user', 'SELECT * FROM Users WHERE id = $1', [123]);\r\n *\r\n * db.one(findUser)\r\n *     .then(user => {\r\n *         // user found;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n *\r\n * @example\r\n *\r\n * const PS = require('pg-promise').PreparedStatement;\r\n *\r\n * // Creating a reusable Prepared Statement without values:\r\n * const addUser = new PS('add-user', 'INSERT INTO Users(name, age) VALUES($1, $2)');\r\n *\r\n * // setting values explicitly:\r\n * addUser.values = ['John', 30];\r\n *\r\n * db.none(addUser)\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n *\r\n * // setting values implicitly, by passing them into the query method:\r\n * db.none(addUser, ['Mike', 25])\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n */\n\nfunction PreparedStatement(name, text, values) {\n  if (!(this instanceof PreparedStatement)) {\n    return new PreparedStatement(name, text, values);\n  }\n\n  let currentError,\n      PS = {},\n      changed = true;\n  const state = {\n    name,\n    text,\n    binary: undefined,\n    rowMode: undefined,\n    rows: undefined\n  };\n\n  if (name && typeof name === 'object' && 'name' in name) {\n    name = npm.assertOptions(name, ['name', 'text', 'binary', 'rowMode', 'rows', 'values']);\n    state.name = name.name;\n    state.text = name.text;\n    state.binary = name.binary;\n    state.rowMode = name.rowMode;\n    state.rows = name.rows;\n    setValues(name.values);\n  } else {\n    setValues(values);\n  }\n\n  function setValues(v) {\n    if (Array.isArray(v)) {\n      if (v.length) {\n        PS.values = v;\n      } else {\n        delete PS.values;\n      }\n    } else {\n      if (npm.utils.isNull(v)) {\n        delete PS.values;\n      } else {\n        PS.values = [v];\n      }\n    }\n  }\n  /**\r\n   * @name PreparedStatement#name\r\n   * @type {string}\r\n   * @description\r\n   * An arbitrary name given to this particular prepared statement. It must be unique within a single session and is\r\n   * subsequently used to execute or deallocate a previously prepared statement.\r\n   */\n\n\n  Object.defineProperty(this, 'name', {\n    get() {\n      return state.name;\n    },\n\n    set(value) {\n      if (value !== state.name) {\n        state.name = value;\n        changed = true;\n      }\n    }\n\n  });\n  /**\r\n   * @name PreparedStatement#text\r\n   * @type {string|QueryFile}\r\n   * @description\r\n   * A non-empty query string or a {@link QueryFile} object.\r\n   *\r\n   * Changing this property for the same {@link PreparedStatement#name name} will have no effect, because queries\r\n   * for Prepared Statements are cached, with {@link PreparedStatement#name name} being the cache key.\r\n   */\n\n  Object.defineProperty(this, 'text', {\n    get() {\n      return state.text;\n    },\n\n    set(value) {\n      if (value !== state.text) {\n        state.text = value;\n        changed = true;\n      }\n    }\n\n  });\n  /**\r\n   * @name PreparedStatement#values\r\n   * @type {array}\r\n   * @description\r\n   * Query formatting parameters, depending on the type:\r\n   *\r\n   * - `null` / `undefined` means the query has no formatting parameters\r\n   * - `Array` - it is an array of formatting parameters\r\n   * - None of the above, means it is a single formatting value, which\r\n   *   is then automatically wrapped into an array\r\n   */\n\n  Object.defineProperty(this, 'values', {\n    get() {\n      return PS.values;\n    },\n\n    set(value) {\n      setValues(value);\n    }\n\n  });\n  /**\r\n   * @name PreparedStatement#binary\r\n   * @type {boolean}\r\n   * @default undefined\r\n   * @description\r\n   * Activates binary result mode. The default is the text mode.\r\n   *\r\n   * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}\r\n   */\n\n  Object.defineProperty(this, 'binary', {\n    get() {\n      return state.binary;\n    },\n\n    set(value) {\n      if (value !== state.binary) {\n        state.binary = value;\n        changed = true;\n      }\n    }\n\n  });\n  /**\r\n   * @name PreparedStatement#rowMode\r\n   * @type {string}\r\n   * @default undefined\r\n   * @description\r\n   * Changes the way data arrives to the client, with only one value supported by $[pg]:\r\n   *  - `rowMode = 'array'` will make all data rows arrive as arrays of values.\r\n   *    By default, rows arrive as objects.\r\n   */\n\n  Object.defineProperty(this, 'rowMode', {\n    get() {\n      return state.rowMode;\n    },\n\n    set(value) {\n      if (value !== state.rowMode) {\n        state.rowMode = value;\n        changed = true;\n      }\n    }\n\n  });\n  /**\r\n   * @name PreparedStatement#rows\r\n   * @type {number}\r\n   * @description\r\n   * Number of rows to return at a time from a Prepared Statement's portal.\r\n   * The default is 0, which means that all rows must be returned at once.\r\n   */\n\n  Object.defineProperty(this, 'rows', {\n    get() {\n      return state.rows;\n    },\n\n    set(value) {\n      if (value !== state.rows) {\n        state.rows = value;\n        changed = true;\n      }\n    }\n\n  });\n  /**\r\n   * @name PreparedStatement#error\r\n   * @type {errors.PreparedStatementError}\r\n   * @default undefined\r\n   * @description\r\n   * When in an error state, it is set to a {@link errors.PreparedStatementError PreparedStatementError} object. Otherwise, it is `undefined`.\r\n   *\r\n   * This property is primarily for internal use by the library.\r\n   */\n\n  Object.defineProperty(this, 'error', {\n    get() {\n      return currentError;\n    }\n\n  });\n  /**\r\n   * @method PreparedStatement#parse\r\n   * @description\r\n   * Parses the current object and returns a simple `{name, text, values}`, if successful,\r\n   * or else it returns a {@link errors.PreparedStatementError PreparedStatementError} object.\r\n   *\r\n   * This method is primarily for internal use by the library.\r\n   *\r\n   * @returns {{name, text, values}|errors.PreparedStatementError}\r\n   */\n\n  this.parse = () => {\n    const qf = state.text instanceof npm.QueryFile ? state.text : null;\n\n    if (!changed && !qf) {\n      return PS;\n    }\n\n    const errors = [],\n          vals = PS.values;\n    PS = {\n      name: state.name\n    };\n    changed = true;\n    currentError = undefined;\n\n    if (!npm.utils.isText(PS.name)) {\n      errors.push('Property \\'name\\' must be a non-empty text string.');\n    }\n\n    if (qf) {\n      qf.prepare();\n\n      if (qf.error) {\n        PS.text = state.text;\n        errors.push(qf.error);\n      } else {\n        PS.text = qf[npm.QueryFile.$query];\n      }\n    } else {\n      PS.text = state.text;\n    }\n\n    if (!npm.utils.isText(PS.text)) {\n      errors.push('Property \\'text\\' must be a non-empty text string.');\n    }\n\n    if (!npm.utils.isNull(vals)) {\n      PS.values = vals;\n    }\n\n    if (state.binary !== undefined) {\n      PS.binary = state.binary;\n    }\n\n    if (state.rowMode !== undefined) {\n      PS.rowMode = state.rowMode;\n    }\n\n    if (state.rows !== undefined) {\n      PS.rows = state.rows;\n    }\n\n    if (errors.length) {\n      return currentError = new npm.errors.PreparedStatementError(errors[0], PS);\n    }\n\n    changed = false;\n    return PS;\n  };\n}\n/**\r\n * @method PreparedStatement#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object's current state.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\n\n\nPreparedStatement.prototype.toString = function (level) {\n  level = level > 0 ? parseInt(level) : 0;\n  const gap = npm.utils.messageGap(level + 1);\n  const ps = this.parse();\n  const lines = ['PreparedStatement {', gap + 'name: ' + JSON.stringify(this.name)];\n\n  if (npm.utils.isText(ps.text)) {\n    lines.push(gap + 'text: \"' + ps.text + '\"');\n  }\n\n  if (this.values !== undefined) {\n    lines.push(gap + 'values: ' + JSON.stringify(this.values));\n  }\n\n  if (this.binary !== undefined) {\n    lines.push(gap + 'binary: ' + JSON.stringify(this.binary));\n  }\n\n  if (this.rowMode !== undefined) {\n    lines.push(gap + 'rowMode: ' + JSON.stringify(this.rowMode));\n  }\n\n  if (this.rows !== undefined) {\n    lines.push(gap + 'rows: ' + JSON.stringify(this.rows));\n  }\n\n  if (this.error) {\n    lines.push(gap + 'error: ' + this.error.toString(level + 1));\n  }\n\n  lines.push(npm.utils.messageGap(level) + '}');\n  return lines.join(npm.os.EOL);\n};\n\nmodule.exports = PreparedStatement;","map":null,"metadata":{},"sourceType":"script"}