{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n'use strict';\n\nconst npm = {\n  fs: require('fs'),\n  path: require('path'),\n  assertOptions: require('assert-options'),\n  utils: require('./'),\n  package: require('../../package.json')\n};\n\nconst EOL = require('os').EOL;\n/**\r\n * @method utils.camelize\r\n * @description\r\n * Camelizes a text string.\r\n *\r\n * Case-changing characters include:\r\n * - _hyphen_\r\n * - _underscore_\r\n * - _period_\r\n * - _space_\r\n *\r\n * @param {string} text\r\n * Input text string.\r\n *\r\n * @returns {string}\r\n * Camelized text string.\r\n *\r\n * @see\r\n * {@link utils.camelizeVar camelizeVar}\r\n *\r\n */\n\n\nfunction camelize(text) {\n  text = text.replace(/[-_\\s.]+(.)?/g, (match, chr) => {\n    return chr ? chr.toUpperCase() : '';\n  });\n  return text.substr(0, 1).toLowerCase() + text.substr(1);\n}\n/**\r\n * @method utils.camelizeVar\r\n * @description\r\n * Camelizes a text string, while making it compliant with JavaScript variable names:\r\n * - contains symbols `a-z`, `A-Z`, `0-9`, `_` and `$`\r\n * - cannot have leading digits\r\n *\r\n * First, it removes all symbols that do not meet the above criteria, except for _hyphen_, _period_ and _space_,\r\n * and then it forwards into {@link utils.camelize camelize}.\r\n *\r\n * @param {string} text\r\n * Input text string.\r\n *\r\n * If it doesn't contain any symbols to make up a valid variable name, the result will be an empty string.\r\n *\r\n * @returns {string}\r\n * Camelized text string that can be used as an open property name.\r\n *\r\n * @see\r\n * {@link utils.camelize camelize}\r\n *\r\n */\n\n\nfunction camelizeVar(text) {\n  text = text.replace(/[^a-zA-Z0-9$_\\-\\s.]/g, '').replace(/^[0-9_\\-\\s.]+/, '');\n  return camelize(text);\n}\n\nfunction _enumSql(dir, options, cb, namePath) {\n  const tree = {};\n  npm.fs.readdirSync(dir).forEach(file => {\n    let stat;\n    const fullPath = npm.path.join(dir, file);\n\n    try {\n      stat = npm.fs.statSync(fullPath);\n    } catch (e) {\n      // while it is very easy to test manually, it is very difficult to test for\n      // access-denied errors automatically; therefore excluding from the coverage:\n      // istanbul ignore next\n      if (options.ignoreErrors) {\n        return; // on to the next file/folder;\n      } // istanbul ignore next\n\n\n      throw e;\n    }\n\n    if (stat.isDirectory()) {\n      if (options.recursive) {\n        const dirName = camelizeVar(file);\n        const np = namePath ? namePath + '.' + dirName : dirName;\n\n        const t = _enumSql(fullPath, options, cb, np);\n\n        if (Object.keys(t).length) {\n          if (!dirName.length || dirName in tree) {\n            if (!options.ignoreErrors) {\n              throw new Error('Empty or duplicate camelized folder name: ' + fullPath);\n            }\n          }\n\n          tree[dirName] = t;\n        }\n      }\n    } else {\n      if (npm.path.extname(file).toLowerCase() === '.sql') {\n        const name = camelizeVar(file.replace(/\\.[^/.]+$/, ''));\n\n        if (!name.length || name in tree) {\n          if (!options.ignoreErrors) {\n            throw new Error('Empty or duplicate camelized file name: ' + fullPath);\n          }\n        }\n\n        tree[name] = fullPath;\n\n        if (cb) {\n          const result = cb(fullPath, name, namePath ? namePath + '.' + name : name);\n\n          if (result !== undefined) {\n            tree[name] = result;\n          }\n        }\n      }\n    }\n  });\n  return tree;\n}\n/**\r\n * @method utils.enumSql\r\n * @description\r\n * Synchronously enumerates all SQL files (within a given directory) into a camelized SQL tree.\r\n *\r\n * All property names within the tree are camelized via {@link utils.camelizeVar camelizeVar},\r\n * so they can be used in the code directly, as open property names.\r\n *\r\n * @param {string} dir\r\n * Directory path where SQL files are located, either absolute or relative to the current directory.\r\n *\r\n * SQL files are identified by using `.sql` extension (case-insensitive).\r\n *\r\n * @param {object} [options]\r\n * Search options.\r\n *\r\n * @param {boolean} [options.recursive=false]\r\n * Include sub-directories into the search.\r\n *\r\n * Sub-directories without SQL files will be skipped from the result.\r\n *\r\n * @param {boolean} [options.ignoreErrors=false]\r\n * Ignore the following types of errors:\r\n * - access errors, when there is no read access to a file or folder\r\n * - empty or duplicate camelized property names\r\n *\r\n * This flag does not affect errors related to invalid input parameters, or if you pass in a\r\n * non-existing directory.\r\n *\r\n * @param {function} [cb]\r\n * A callback function that takes three arguments:\r\n * - `file` - SQL file path, relative or absolute, according to how you specified the search directory\r\n * - `name` - name of the property that represents the SQL file\r\n * - `path` - property resolution path (full property name)\r\n *\r\n * If the function returns anything other than `undefined`, it overrides the corresponding property value in the tree.\r\n *\r\n * @returns {object}\r\n * Camelized SQL tree object, with each value being an SQL file path (unless changed via the callback).\r\n *\r\n * @see\r\n * {@link utils.objectToCode objectToCode},\r\n * {@link utils.buildSqlModule buildSqlModule}\r\n *\r\n * @example\r\n *\r\n * // simple SQL tree generation for further processing:\r\n * const tree = pgp.utils.enumSql('../sql', {recursive: true});\r\n *\r\n * @example\r\n *\r\n * // generating an SQL tree for dynamic use of names:\r\n * const sql = pgp.utils.enumSql(__dirname, {recursive: true}, file=> {\r\n *     return new pgp.QueryFile(file, {minify: true});\r\n * });\r\n *\r\n * @example\r\n *\r\n * const path = require('path');\r\n *\r\n * // replacing each relative path in the tree with a full one:\r\n * const tree = pgp.utils.enumSql('../sql', {recursive: true}, file=> {\r\n *     return path.join(__dirname, file);\r\n * });\r\n *\r\n */\n\n\nfunction enumSql(dir, options, cb) {\n  if (!npm.utils.isText(dir)) {\n    throw new TypeError('Parameter \\'dir\\' must be a non-empty text string.');\n  }\n\n  options = npm.assertOptions(options, ['recursive', 'ignoreErrors']);\n  cb = typeof cb === 'function' ? cb : null;\n  return _enumSql(dir, options, cb, '');\n}\n/**\r\n *\r\n * @method utils.objectToCode\r\n * @description\r\n * Translates an object tree into a well-formatted JSON code string.\r\n *\r\n * @param {object} obj\r\n * Source tree object.\r\n *\r\n * @param {function} [cb]\r\n * A callback function to override property values for the code.\r\n *\r\n * It takes three arguments:\r\n *\r\n * - `value` - property value\r\n * - `name` - property name\r\n * - `obj` - current object (which contains the property)\r\n *\r\n * The returned value is used as is for the property value in the generated code.\r\n *\r\n * @returns {string}\r\n *\r\n * @see\r\n * {@link utils.enumSql enumSql},\r\n * {@link utils.buildSqlModule buildSqlModule}\r\n *\r\n * @example\r\n *\r\n * // Generating code for a simple object\r\n *\r\n * const tree = {one: 1, two: {item: 'abc'}};\r\n *\r\n * const code = pgp.utils.objectToCode(tree);\r\n *\r\n * console.log(code);\r\n * //=>\r\n * // {\r\n * //     one: 1,\r\n * //     two: {\r\n * //         item: \"abc\"\r\n * //     }\r\n * // }\r\n *\r\n * @example\r\n *\r\n * // Generating a Node.js module with an SQL tree\r\n *\r\n * const fs = require('fs');\r\n * const EOL = require('os').EOL;\r\n *\r\n * // generating an SQL tree from the folder:\r\n * const tree = pgp.utils.enumSql('./sql', {recursive: true});\r\n *\r\n * // generating the module's code:\r\n * const code = \"const load = require('./loadSql');\" + EOL + EOL + \"module.exports = \" +\r\n *         pgp.utils.objectToCode(tree, value => {\r\n *             return 'load(' + JSON.stringify(value) + ')';\r\n *         }) + ';';\r\n *\r\n * // saving the module:\r\n * fs.writeFileSync('sql.js', code);\r\n *\r\n * @example\r\n *\r\n * // generated code example (file sql.js)\r\n *\r\n * const load = require('./loadSql');\r\n *\r\n * module.exports = {\r\n *     events: {\r\n *         add: load(\"../sql/events/add.sql\"),\r\n *         delete: load(\"../sql/events/delete.sql\"),\r\n *         find: load(\"../sql/events/find.sql\"),\r\n *         update: load(\"../sql/events/update.sql\")\r\n *     },\r\n *     products: {\r\n *         add: load(\"../sql/products/add.sql\"),\r\n *         delete: load(\"../sql/products/delete.sql\"),\r\n *         find: load(\"../sql/products/find.sql\"),\r\n *         update: load(\"../sql/products/update.sql\")\r\n *     },\r\n *     users: {\r\n *         add: load(\"../sql/users/add.sql\"),\r\n *         delete: load(\"../sql/users/delete.sql\"),\r\n *         find: load(\"../sql/users/find.sql\"),\r\n *         update: load(\"../sql/users/update.sql\")\r\n *     },\r\n *     create: load(\"../sql/create.sql\"),\r\n *     init: load(\"../sql/init.sql\"),\r\n *     drop: load(\"../sql/drop.sql\")\r\n *};\r\n *\r\n * @example\r\n *\r\n * // loadSql.js module example\r\n *\r\n * const QueryFile = require('pg-promise').QueryFile;\r\n *\r\n * module.exports = file => {\r\n *     return new QueryFile(file, {minify: true});\r\n * };\r\n *\r\n */\n\n\nfunction objectToCode(obj, cb) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('Parameter \\'obj\\' must be a non-null object.');\n  }\n\n  cb = typeof cb === 'function' ? cb : null;\n  return '{' + generate(obj, 1) + EOL + '}';\n\n  function generate(o, level) {\n    let code = '',\n        idx = 0;\n    const gap = npm.utils.messageGap(level);\n\n    for (const prop in o) {\n      const value = o[prop];\n\n      if (idx) {\n        code += ',';\n      }\n\n      if (value && typeof value === 'object') {\n        code += EOL + gap + prop + ': {';\n        code += generate(value, level + 1);\n        code += EOL + gap + '}';\n      } else {\n        code += EOL + gap + prop + ': ';\n\n        if (cb) {\n          code += cb(value, prop, o);\n        } else {\n          code += JSON.stringify(value);\n        }\n      }\n\n      idx++;\n    }\n\n    return code;\n  }\n}\n/**\r\n * @method utils.buildSqlModule\r\n * @description\r\n * Synchronously generates a Node.js module with a camelized SQL tree, based on a configuration object that has the format shown below.\r\n *\r\n * This method is normally to be used on a grunt/gulp watch that triggers when the file structure changes in your SQL directory,\r\n * although it can be invoked manually as well.\r\n *\r\n * ```js\r\n * {\r\n *    // Required Properties:\r\n *    \r\n *    \"dir\" // {string}: relative or absolute directory where SQL files are located (see API for method enumSql, parameter `dir`)\r\n *\r\n *    // Optional Properties:\r\n *    \r\n *    \"recursive\" // {boolean}: search for sql files recursively (see API for method enumSql, option `recursive`)\r\n *\r\n *    \"ignoreErrors\" // {boolean}: ignore common errors (see API for method enumSql, option `ignoreErrors`)\r\n *\r\n *    \"output\" // {string}: relative or absolute destination file path; when not specified, no file is created,\r\n *             // but you still can use the code string that's always returned by the method.\r\n *     \r\n *    \"module\": {\r\n *        \"path\" // {string}: relative path to a module exporting a function which takes a file path\r\n *               // and returns a proper value (typically, a new QueryFile object); by default, it uses `./loadSql`.\r\n *\r\n *        \"name\" // {string}: local variable name for the SQL-loading module; by default, it uses `load`.\r\n *    }\r\n * }\r\n * ```\r\n *\r\n * @param {object|string} [config]\r\n * Configuration parameter for generating the code.\r\n *\r\n * - When it is a non-null object, it is assumed to be a configuration object (see the format above).\r\n * - When it is a text string - it is the relative path to either a JSON file that contains the configuration object,\r\n *   or a Node.js module that exports one. The path is relative to the application's entry point file.\r\n * - When `config` isn't specified, the method will try to locate the default `sql-config.json` file in the directory of your\r\n *   application's entry point file, and if not found - throw {@link external:Error Error} = `Default SQL configuration file not found`.\r\n *\r\n * @returns {string}\r\n * Generated code.\r\n *\r\n * @see\r\n * {@link utils.enumSql enumSql},\r\n * {@link utils.objectToCode objectToCode}\r\n *\r\n * @example\r\n *\r\n * // generate SQL module automatically, from sql-config.json in the module's start-up folder:\r\n *\r\n * pgp.utils.buildSqlModule();\r\n *\r\n * // see generated file below:\r\n *\r\n * @example\r\n *\r\n * /////////////////////////////////////////////////////////////////////////\r\n * // This file was automatically generated by pg-promise v.4.3.8\r\n * //\r\n * // Generated on: 6/2/2016, at 2:15:23 PM\r\n * // Total files: 15\r\n * //\r\n * // API: http://vitaly-t.github.io/pg-promise/utils.html#.buildSqlModule\r\n * /////////////////////////////////////////////////////////////////////////\r\n *\r\n * const load = require('./loadSql');\r\n *\r\n * module.exports = {\r\n *     events: {\r\n *         add: load(\"../sql/events/add.sql\"),\r\n *         delete: load(\"../sql/events/delete.sql\"),\r\n *         find: load(\"../sql/events/find.sql\"),\r\n *         update: load(\"../sql/events/update.sql\")\r\n *     },\r\n *     products: {\r\n *         add: load(\"../sql/products/add.sql\"),\r\n *         delete: load(\"../sql/products/delete.sql\"),\r\n *         find: load(\"../sql/products/find.sql\"),\r\n *         update: load(\"../sql/products/update.sql\")\r\n *     },\r\n *     users: {\r\n *         add: load(\"../sql/users/add.sql\"),\r\n *         delete: load(\"../sql/users/delete.sql\"),\r\n *         find: load(\"../sql/users/find.sql\"),\r\n *         update: load(\"../sql/users/update.sql\")\r\n *     },\r\n *     create: load(\"../sql/create.sql\"),\r\n *     init: load(\"../sql/init.sql\"),\r\n *     drop: load(\"../sql/drop.sql\")\r\n *};\r\n *\r\n */\n\n\nfunction buildSqlModule(config) {\n  if (npm.utils.isText(config)) {\n    const path = npm.utils.isPathAbsolute(config) ? config : npm.path.join(npm.utils.startDir, config);\n    config = require(path);\n  } else {\n    if (npm.utils.isNull(config)) {\n      const defConfig = npm.path.join(npm.utils.startDir, 'sql-config.json'); // istanbul ignore else;\n\n      if (!npm.fs.existsSync(defConfig)) {\n        throw new Error('Default SQL configuration file not found: ' + defConfig);\n      } // cannot test this automatically, because it requires that file 'sql-config.json'\n      // resides within the Jasmine folder, since it is the client during the test.\n      // istanbul ignore next;\n\n\n      config = require(defConfig);\n    } else {\n      if (!config || typeof config !== 'object') {\n        throw new TypeError('Invalid parameter \\'config\\' specified.');\n      }\n    }\n  }\n\n  if (!npm.utils.isText(config.dir)) {\n    throw new Error('Property \\'dir\\' must be a non-empty string.');\n  }\n\n  let total = 0;\n  const tree = enumSql(config.dir, {\n    recursive: config.recursive,\n    ignoreErrors: config.ignoreErrors\n  }, () => {\n    total++;\n  });\n  let modulePath = './loadSql',\n      moduleName = 'load';\n\n  if (config.module && typeof config.module === 'object') {\n    if (npm.utils.isText(config.module.path)) {\n      modulePath = config.module.path;\n    }\n\n    if (npm.utils.isText(config.module.name)) {\n      moduleName = config.module.name;\n    }\n  }\n\n  const d = new Date();\n  const header = '/////////////////////////////////////////////////////////////////////////' + EOL + '// This file was automatically generated by pg-promise v.' + npm.package.version + EOL + '//' + EOL + '// Generated on: ' + d.toLocaleDateString() + ', at ' + d.toLocaleTimeString() + EOL + '// Total files: ' + total + EOL + '//' + EOL + '// API: http://vitaly-t.github.io/pg-promise/utils.html#.buildSqlModule' + EOL + '/////////////////////////////////////////////////////////////////////////' + EOL + EOL + '\\'use strict\\';' + EOL + EOL + 'const ' + moduleName + ' = require(\\'' + modulePath + '\\');' + EOL + EOL + 'module.exports = ';\n  const code = header + objectToCode(tree, value => {\n    return moduleName + '(' + JSON.stringify(value) + ')';\n  }) + ';';\n\n  if (npm.utils.isText(config.output)) {\n    let p = config.output;\n\n    if (!npm.utils.isPathAbsolute(p)) {\n      p = npm.path.join(npm.utils.startDir, p);\n    }\n\n    npm.fs.writeFileSync(p, code);\n  }\n\n  return code;\n}\n/**\r\n * @method utils.taskArgs\r\n * @description\r\n * Normalizes/prepares arguments for tasks and transactions.\r\n *\r\n * Its main purpose is to simplify adding custom methods {@link Database#task task}, {@link Database#taskIf taskIf},\r\n * {@link Database#tx tx} and {@link Database#txIf txIf} within event {@link event:extend extend}, as the those methods use fairly\r\n * complex logic for parsing inputs.\r\n *\r\n * @param args {Object}\r\n * Array-like object of `arguments` that was passed into the method. It is expected that the `arguments`\r\n * are always made of two parameters - `(options, cb)`, same as all the default task/transaction methods.\r\n *\r\n * And if your custom method needs additional parameters, they should be passed in as extra properties within `options`.\r\n *\r\n * @returns {Array}\r\n * Array of arguments that can be passed into a task or transaction.\r\n *\r\n * It is extended with properties `options` and `cb` to access the corresponding array elements `[0]` and `[1]` by name.\r\n *\r\n * @example\r\n *\r\n * // Registering a custom transaction method that assigns a default Transaction Mode:\r\n *\r\n * const initOptions = {\r\n *     extend: obj => {\r\n *         obj.myTx = function(options, cb) {\r\n *             const args = pgp.utils.taskArgs(arguments); // prepare arguments\r\n *\r\n *             if (!('mode' in args.options)) {\r\n *                 // if no 'mode' was specified, set default for transaction mode:\r\n *                 args.options.mode = myTxModeObject; // of type pgp.txMode.TransactionMode\r\n *             }\r\n *\r\n *             return obj.tx.apply(this, args);\r\n *             // or explicitly, if needed:\r\n *             // return obj.tx.call(this, args.options, args.cb);\r\n *         }\r\n *     }\r\n * };\r\n *\r\n */\n\n\nfunction taskArgs(args) {\n  if (!args || typeof args.length !== 'number') {\n    throw new TypeError('Parameter \"args\" must be an array-like object of arguments.');\n  }\n\n  let options = args[0],\n      cb;\n\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n\n    if (cb.name) {\n      options.tag = cb.name;\n    }\n  } else {\n    if (typeof args[1] === 'function') {\n      cb = args[1];\n    }\n\n    if (typeof options === 'string' || typeof options === 'number') {\n      options = {\n        tag: options\n      };\n    } else {\n      options = typeof options === 'object' && options || {};\n\n      if (!('tag' in options) && cb && cb.name) {\n        options.tag = cb.name;\n      }\n    }\n  }\n\n  const res = [options, cb];\n  Object.defineProperty(res, 'options', {\n    get: function () {\n      return this[0];\n    },\n    set: function (newValue) {\n      return this[0] = newValue;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(res, 'cb', {\n    get: function () {\n      return this[1];\n    },\n    set: function (newValue) {\n      return this[1] = newValue;\n    },\n    enumerable: true\n  });\n  return res;\n}\n/**\r\n * @namespace utils\r\n *\r\n * @description\r\n * Namespace for general-purpose static functions, available as `pgp.utils`, before and after initializing the library.\r\n *\r\n * See also:\r\n * - [Automatic SQL Trees](https://github.com/vitaly-t/pg-promise/issues/153)\r\n * - [SQL Files](https://github.com/vitaly-t/pg-promise/wiki/SQL-Files)\r\n *\r\n * @property {function} camelize\r\n * {@link utils.camelize camelize} - camelizes a text string\r\n *\r\n * @property {function} camelizeVar\r\n * {@link utils.camelizeVar camelizeVar} - camelizes a text string as a variable\r\n *\r\n * @property {function} enumSql\r\n * {@link utils.enumSql enumSql} - enumerates SQL files in a directory\r\n *\r\n * @property {function} objectToCode\r\n * {@link utils.objectToCode objectToCode} - generates code from an object\r\n *\r\n * @property {function} buildSqlModule\r\n * {@link utils.buildSqlModule buildSqlModule} - generates a complete Node.js module\r\n *\r\n * @property {function} taskArgs\r\n * {@link utils.taskArgs taskArgs} - prepares arguments for tasks and transactions\r\n */\n\n\nmodule.exports = {\n  camelize,\n  camelizeVar,\n  enumSql,\n  objectToCode,\n  buildSqlModule,\n  taskArgs\n};\nObject.freeze(module.exports);","map":null,"metadata":{},"sourceType":"script"}