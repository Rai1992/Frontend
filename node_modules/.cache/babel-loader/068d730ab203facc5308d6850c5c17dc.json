{"ast":null,"code":"'use strict';\n\nvar npm = {\n  u: require('util'),\n  os: require('os'),\n  utils: require('../utils/static')\n};\nvar errorReasons = {\n  0: 'Source %s returned a rejection at index %d.',\n  1: 'Source %s threw an error at index %d.',\n  2: 'Destination %s returned a rejection at index %d.',\n  3: 'Destination %s threw an error at index %d.'\n};\n/**\r\n * @interface errors.SequenceError\r\n * @augments external:Error\r\n * @description\r\n * This type represents all errors rejected by method {@link sequence}, except for {@link external:TypeError TypeError}\r\n * when the method receives invalid input parameters.\r\n *\r\n * @property {string} name\r\n * Standard {@link external:Error Error} property - error type name = `SequenceError`.\r\n *\r\n * @property {string} message\r\n * Standard {@link external:Error Error} property - the error message.\r\n *\r\n * @property {string} stack\r\n * Standard {@link external:Error Error} property - the stack trace.\r\n *\r\n * @property {} error\r\n * The error that was thrown or the rejection reason.\r\n *\r\n * @property {number} index\r\n * Index of the element in the sequence for which the error/rejection occurred.\r\n *\r\n * @property {number} duration\r\n * Duration (in milliseconds) of processing until the error/rejection occurred.\r\n *\r\n * @property {string} reason\r\n * Textual explanation of why the method failed.\r\n *\r\n * @property {} source\r\n * Resolved `data` parameter that was passed into the `source` function.\r\n *\r\n * It is only set when the error/rejection occurred inside the `source` function.\r\n *\r\n * @property {} dest\r\n * Resolved `data` parameter that was passed into the `dest` function.\r\n *\r\n * It is only set when the error/rejection occurred inside the `dest` function.\r\n *\r\n * @see {@link sequence}\r\n *\r\n */\n\nfunction SequenceError(e, code, cbName, duration) {\n  this.index = e.index;\n  this.duration = duration;\n  this.error = e.error;\n\n  if (this.error instanceof Error) {\n    this.message = this.error.message;\n  } else {\n    this.message = this.error;\n\n    if (typeof this.message !== 'string') {\n      this.message = npm.u.inspect(this.message);\n    }\n  }\n\n  if ('source' in e) {\n    this.source = e.source;\n  } else {\n    this.dest = e.dest;\n  }\n\n  cbName = cbName ? '\\'' + cbName + '\\'' : '<anonymous>';\n  this.reason = npm.u.format(errorReasons[code], cbName, e.index);\n  Error.captureStackTrace(this, SequenceError);\n}\n\nnpm.u.inherits(SequenceError, Error);\nSequenceError.prototype.name = 'SequenceError';\n/**\r\n * @method errors.SequenceError.toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the error.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\n\nSequenceError.prototype.toString = function (level) {\n  level = level > 0 ? parseInt(level) : 0;\n  var gap0 = npm.utils.messageGap(level),\n      gap1 = npm.utils.messageGap(level + 1),\n      lines = ['SequenceError {', gap1 + 'message: ' + JSON.stringify(this.message), gap1 + 'reason: ' + this.reason, gap1 + 'index: ' + this.index, gap1 + 'duration: ' + this.duration];\n  lines.push(gap1 + 'error: ' + npm.utils.formatError(this.error, level + 1));\n  lines.push(gap0 + '}');\n  return lines.join(npm.os.EOL);\n};\n\nnpm.utils.addInspection(SequenceError, function () {\n  return this.toString();\n});\nmodule.exports = SequenceError;","map":null,"metadata":{},"sourceType":"script"}