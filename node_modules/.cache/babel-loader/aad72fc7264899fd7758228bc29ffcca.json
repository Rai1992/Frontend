{"ast":null,"code":"'use strict';\n\nvar SequenceError = require('../errors/sequence');\n/**\r\n * @method sequence\r\n * @description\r\n * Resolves a dynamic sequence of [mixed values]{@tutorial mixed}.\r\n *\r\n * The method acquires [mixed values]{@tutorial mixed} from the `source` function, one at a time, and resolves them,\r\n * till either no more values left in the sequence or an error/reject occurs.\r\n *\r\n * It supports both [linked and detached sequencing]{@tutorial sequencing}.\r\n *\r\n * @param {Function|generator} source\r\n * Expected to return the next [mixed value]{@tutorial mixed} to be resolved. Returning or resolving\r\n * with `undefined` ends the sequence, and the method resolves.\r\n *\r\n * Parameters:\r\n *  - `index` = current request index in the sequence\r\n *  - `data` = resolved data from the previous call (`undefined` when `index=0`)\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.SequenceError SequenceError}, which will have property `source` set.\r\n *\r\n * Passing in anything other than a function will reject with {@link external:TypeError TypeError} = `Parameter 'source' must be a function.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.dest=null]\r\n * Optional destination function (or generator), to receive resolved data for each index,\r\n * process it and respond as required.\r\n *\r\n * Parameters:\r\n *  - `index` = index of the resolved data in the sequence\r\n *  - `data` = the data resolved\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise object, if data processing is done asynchronously.\r\n * If a promise is returned, the method will not request another value from the `source` function,\r\n * until the promise has been resolved (the resolved value is ignored).\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.SequenceError SequenceError}, which will have property `dest` set.\r\n *\r\n * @param {Number} [options.limit=0]\r\n * Limits the maximum size of the sequence. If the value is greater than 0, the method will\r\n * successfully resolve once the specified limit has been reached.\r\n *\r\n * When `limit` isn't specified (default), the sequence is unlimited, and it will continue\r\n * till one of the following occurs:\r\n *  - `source` either returns or resolves with `undefined`\r\n *  - either `source` or `dest` functions throw an error or return a rejected promise\r\n *\r\n * @param {Boolean} [options.track=false]\r\n * Changes the type of data to be resolved by this method. By default, it is `false`\r\n * (see the return result). When set to be `true`, the method tracks/collects all resolved data\r\n * into an array internally, and resolves with that array once the method has finished successfully.\r\n *\r\n * It must be used with caution, as to the size of the sequence, because accumulating data for\r\n * a very large sequence can result in consuming too much memory.\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When successful, the resolved data depends on parameter `track`. When `track` is `false`\r\n * (default), the method resolves with object `{total, duration}`:\r\n *  - `total` = number of values resolved by the sequence\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When `track` is `true`, the method resolves with an array of all the data that has been resolved,\r\n * the same way that the standard $[promise.all] resolves. In addition, the array comes extended with\r\n * a hidden read-only property `duration` - number of milliseconds consumed by the method.\r\n *\r\n * When the method fails, it rejects with {@link errors.SequenceError SequenceError}.\r\n */\n\n\nfunction sequence(source, options, config) {\n  var $p = config.promise,\n      utils = config.utils;\n\n  if (typeof source !== 'function') {\n    return $p.reject(new TypeError('Parameter \\'source\\' must be a function.'));\n  }\n\n  source = utils.wrap(source);\n  options = options || {};\n  var limit = options.limit > 0 ? parseInt(options.limit) : 0,\n      dest = utils.wrap(options.dest),\n      self = this,\n      data,\n      srcTime,\n      destTime,\n      result = [],\n      start = Date.now();\n  return $p(function (resolve, reject) {\n    function loop(idx) {\n      var srcNow = Date.now(),\n          srcDelay = idx ? srcNow - srcTime : undefined;\n      srcTime = srcNow;\n      utils.resolve.call(self, source, [idx, data, srcDelay], function (value, delayed) {\n        data = value;\n\n        if (data === undefined) {\n          success();\n        } else {\n          if (options.track) {\n            result.push(data);\n          }\n\n          if (dest) {\n            var destResult,\n                destNow = Date.now(),\n                destDelay = idx ? destNow - destTime : undefined;\n            destTime = destNow;\n\n            try {\n              destResult = dest.call(self, idx, data, destDelay);\n            } catch (e) {\n              fail({\n                error: e,\n                dest: data\n              }, 3, dest.name);\n              return;\n            }\n\n            if (utils.isPromise(destResult)) {\n              destResult.then(function () {\n                next(true);\n                return null; // this dummy return is just to prevent Bluebird warnings;\n              }).catch(function (error) {\n                fail({\n                  error: error,\n                  dest: data\n                }, 2, dest.name);\n              });\n            } else {\n              next(delayed);\n            }\n          } else {\n            next(delayed);\n          }\n        }\n      }, function (reason, isRej) {\n        fail({\n          error: reason,\n          source: data\n        }, isRej ? 0 : 1, source.name);\n      });\n\n      function next(delayed) {\n        if (limit === ++idx) {\n          success();\n        } else {\n          if (delayed) {\n            loop(idx);\n          } else {\n            $p.resolve().then(function () {\n              loop(idx);\n              return null; // this dummy return is just to prevent Bluebird warnings;\n            });\n          }\n        }\n      }\n\n      function success() {\n        var length = Date.now() - start;\n\n        if (options.track) {\n          utils.extend(result, 'duration', length);\n        } else {\n          result = {\n            total: idx,\n            duration: length\n          };\n        }\n\n        resolve(result);\n      }\n\n      function fail(reason, code, cbName) {\n        reason.index = idx;\n        reject(new SequenceError(reason, code, cbName, Date.now() - start));\n      }\n    }\n\n    loop(0);\n  });\n}\n\nmodule.exports = function (config) {\n  return function (source, options) {\n    return sequence.call(this, source, options, config);\n  };\n};","map":null,"metadata":{},"sourceType":"script"}