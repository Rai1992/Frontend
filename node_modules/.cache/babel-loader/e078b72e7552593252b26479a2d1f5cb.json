{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n'use strict';\n\nconst npm = {\n  assertOptions: require('assert-options'),\n  os: require('os'),\n  utils: require('../utils'),\n  formatting: require('../formatting'),\n  TableName: require('./tableName'),\n  Column: require('./column')\n};\n/**\r\n * @class helpers.ColumnSet\r\n * @description\r\n *\r\n * Performance-optimized, read-only structure with query-formatting columns.\r\n *\r\n * For performance-oriented applications this type should be created globally/statically, to be reused by all methods.\r\n *\r\n * @param {object|helpers.Column|array} columns\r\n * Columns information object, depending on the type:\r\n *\r\n * - When it is a simple object, its properties are enumerated to represent both column names and property names\r\n *   within the source objects. See also option `inherit` that's applicable in this case.\r\n *\r\n * - When it is a single {@link helpers.Column Column} object, property {@link helpers.ColumnSet#columns columns} is initialized with\r\n *   just a single column. It is not a unique situation when only a single column is required for an update operation.\r\n *\r\n * - When it is an array, each element is assumed to represent details for a column. If the element is already of type {@link helpers.Column Column},\r\n *   it is used directly; otherwise the element is passed into {@link helpers.Column Column} constructor for initialization.\r\n *   On any duplicate column name (case-sensitive) it will throw {@link external:Error Error} = `Duplicate column name \"name\".`\r\n *\r\n * - When it is none of the above, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'columns' specified.`\r\n *\r\n * @param {object} [options]\r\n *\r\n * @param {helpers.TableName|string|{table,schema}} [options.table]\r\n * Table details.\r\n *\r\n * When it is a non-null value, and not a {@link helpers.TableName TableName} object, a new {@link helpers.TableName TableName} is constructed from the value.\r\n *\r\n * It can be used as the default for methods {@link helpers.insert insert} and {@link helpers.update update} when their parameter\r\n * `table` is omitted, and for logging purposes.\r\n *\r\n * @param {boolean} [options.inherit = false]\r\n * Use inherited properties in addition to the object's own properties.\r\n *\r\n * By default, only the object's own properties are enumerated for column names.\r\n *\r\n * @returns {helpers.ColumnSet}\r\n *\r\n * @see\r\n *\r\n * {@link helpers.ColumnSet#columns columns},\r\n * {@link helpers.ColumnSet#names names},\r\n * {@link helpers.ColumnSet#table table},\r\n * {@link helpers.ColumnSet#variables variables} |\r\n * {@link helpers.ColumnSet#assign assign},\r\n * {@link helpers.ColumnSet#assignColumns assignColumns},\r\n * {@link helpers.ColumnSet#extend extend},\r\n * {@link helpers.ColumnSet#merge merge},\r\n * {@link helpers.ColumnSet#prepare prepare}\r\n *\r\n * @example\r\n *\r\n * // A complex insert/update object scenario for table 'purchases' in schema 'fiscal'.\r\n * // For a good performance, you should declare such objects once and then reuse them.\r\n * //\r\n * // Column Requirements:\r\n * //\r\n * // 1. Property 'id' is only to be used for a WHERE condition in updates\r\n * // 2. Property 'list' needs to be formatted as a csv\r\n * // 3. Property 'code' is to be used as raw text, and to be defaulted to 0 when the\r\n * //    property is missing in the source object\r\n * // 4. Property 'log' is a JSON object with 'log-entry' for the column name\r\n * // 5. Property 'data' requires SQL type casting '::int[]'\r\n * // 6. Property 'amount' needs to be set to 100, if it is 0\r\n * // 7. Property 'total' must be skipped during updates, if 'amount' was 0, plus its\r\n * //    column name is 'total-val'\r\n *\r\n * const cs = new pgp.helpers.ColumnSet([\r\n *     '?id', // ColumnConfig equivalent: {name: 'id', cnd: true}\r\n *     'list:csv', // ColumnConfig equivalent: {name: 'list', mod: ':csv'}\r\n *     {\r\n *         name: 'code',\r\n *         mod: '^', // format as raw text\r\n *         def: 0 // default to 0 when the property doesn't exist\r\n *     },\r\n *     {\r\n *         name: 'log-entry',\r\n *         prop: 'log',\r\n *         mod: ':json' // format as JSON\r\n *     },\r\n *     {\r\n *         name: 'data',\r\n *         cast: 'int[]' // use SQL type casting '::int[]'\r\n *     },\r\n *     {\r\n *         name: 'amount',\r\n *         init: col => {\r\n *             // set to 100, if the value is 0:\r\n *             return col.value === 0 ? 100 : col.value;\r\n *         }\r\n *     },\r\n *     {\r\n *         name: 'total-val',\r\n *         prop: 'total',\r\n *         skip: col => {\r\n *             // skip from updates, if 'amount' is 0:\r\n *             return col.source.amount === 0;\r\n *         }\r\n *     }\r\n * ], {table: {table: 'purchases', schema: 'fiscal'}});\r\n *\r\n * // Alternatively, you could take the table declaration out:\r\n * // const table = new pgp.helpers.TableName('purchases', 'fiscal');\r\n *\r\n * console.log(cs); // console output for the object:\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"fiscal\".\"purchases\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"id\"\r\n * //            cnd: true\r\n * //        }\r\n * //        Column {\r\n * //            name: \"list\"\r\n * //            mod: \":csv\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"code\"\r\n * //            mod: \"^\"\r\n * //            def: 0\r\n * //        }\r\n * //        Column {\r\n * //            name: \"log-entry\"\r\n * //            prop: \"log\"\r\n * //            mod: \":json\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"data\"\r\n * //            cast: \"int[]\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"amount\"\r\n * //            init: [Function]\r\n * //        }\r\n * //        Column {\r\n * //            name: \"total-val\"\r\n * //            prop: \"total\"\r\n * //            skip: [Function]\r\n * //        }\r\n * //    ]\r\n * // }\r\n */\n\nfunction ColumnSet(columns, opt) {\n  if (!(this instanceof ColumnSet)) {\n    return new ColumnSet(columns, opt);\n  }\n\n  if (!columns || typeof columns !== 'object') {\n    throw new TypeError('Invalid parameter \\'columns\\' specified.');\n  }\n\n  let names,\n      variables,\n      updates,\n      isSimple = true;\n  opt = npm.assertOptions(opt, ['table', 'inherit']);\n\n  if (!npm.utils.isNull(opt.table)) {\n    this.table = opt.table instanceof npm.TableName ? opt.table : new npm.TableName(opt.table);\n  }\n  /**\r\n   * @name helpers.ColumnSet#table\r\n   * @type {helpers.TableName}\r\n   * @readonly\r\n   * @description\r\n   * Destination table. It can be specified for two purposes:\r\n   *\r\n   * - **primary:** to be used as the default table when it is omitted during a call into methods {@link helpers.insert insert} and {@link helpers.update update}\r\n   * - **secondary:** to be automatically written into the console (for logging purposes).\r\n   */\n\n  /**\r\n   * @name helpers.ColumnSet#columns\r\n   * @type helpers.Column[]\r\n   * @readonly\r\n   * @description\r\n   * Array of {@link helpers.Column Column} objects.\r\n   */\n\n\n  if (Array.isArray(columns)) {\n    const colNames = {};\n    this.columns = columns.map(c => {\n      const col = c instanceof npm.Column ? c : new npm.Column(c);\n\n      if (col.name in colNames) {\n        throw new Error('Duplicate column name \"' + col.name + '\".');\n      }\n\n      colNames[col.name] = true;\n      return col;\n    });\n  } else {\n    if (columns instanceof npm.Column) {\n      this.columns = [columns];\n    } else {\n      this.columns = [];\n\n      for (const name in columns) {\n        if (opt.inherit || Object.prototype.hasOwnProperty.call(columns, name)) {\n          this.columns.push(new npm.Column(name));\n        }\n      }\n    }\n  }\n\n  Object.freeze(this.columns);\n\n  for (let i = 0; i < this.columns.length; i++) {\n    const c = this.columns[i]; // ColumnSet is simple when the source objects require no preparation,\n    // and should be used directly:\n\n    if (c.prop || c.init || 'def' in c) {\n      isSimple = false;\n      break;\n    }\n  }\n  /**\r\n   * @name helpers.ColumnSet#names\r\n   * @type string\r\n   * @readonly\r\n   * @description\r\n   * Returns a string - comma-separated list of all column names, properly escaped.\r\n   *\r\n   * @example\r\n   * const cs = new ColumnSet(['id^', {name: 'cells', cast: 'int[]'}, 'doc:json']);\r\n   * console.log(cs.names);\r\n   * //=> \"id\",\"cells\",\"doc\"\r\n   */\n\n\n  Object.defineProperty(this, 'names', {\n    get() {\n      if (!names) {\n        names = this.columns.map(c => c.escapedName).join();\n      }\n\n      return names;\n    }\n\n  });\n  /**\r\n   * @name helpers.ColumnSet#variables\r\n   * @type string\r\n   * @readonly\r\n   * @description\r\n   * Returns a string - formatting template for all column values.\r\n   *\r\n   * @see {@link helpers.ColumnSet#assign assign}\r\n   *\r\n   * @example\r\n   * const cs = new ColumnSet(['id^', {name: 'cells', cast: 'int[]'}, 'doc:json']);\r\n   * console.log(cs.variables);\r\n   * //=> ${id^},${cells}::int[],${doc:json}\r\n   */\n\n  Object.defineProperty(this, 'variables', {\n    get() {\n      if (!variables) {\n        variables = this.columns.map(c => c.variable + c.castText).join();\n      }\n\n      return variables;\n    }\n\n  });\n  /**\r\n   * @method helpers.ColumnSet#assign\r\n   * @description\r\n   * Returns a formatting template of SET assignments, either generic or for a single object.\r\n   *\r\n   * The method is optimized to cache the output string when there are no columns that can be skipped dynamically.\r\n   *\r\n   * This method is primarily for internal use, that's why it does not validate the input.\r\n   *\r\n   * @param {object} [options]\r\n   * Assignment/formatting options.\r\n   *\r\n   * @param {object} [options.source]\r\n   * Source - a single object that contains values for columns.\r\n   *\r\n   * The object is only necessary to correctly apply the logic of skipping columns dynamically, based on the source data\r\n   * and the rules defined in the {@link helpers.ColumnSet ColumnSet}. If, however, you do not care about that, then you do not need to specify any object.\r\n   *\r\n   * Note that even if you do not specify the object, the columns marked as conditional (`cnd: true`) will always be skipped.\r\n   *\r\n   * @param {string} [options.prefix]\r\n   * In cases where needed, an alias prefix to be added before each column.\r\n   *\r\n   * @returns {string}\r\n   * Comma-separated list of variable-to-column assignments.\r\n   *\r\n   * @see {@link helpers.ColumnSet#variables variables}\r\n   *\r\n   * @example\r\n   *\r\n   * const cs = new pgp.helpers.ColumnSet([\r\n   *     '?first', // = {name: 'first', cnd: true}\r\n   *     'second:json',\r\n   *     {name: 'third', mod: ':raw', cast: 'text'}\r\n   * ]);\r\n   *\r\n   * cs.assign();\r\n   * //=> \"second\"=${second:json},\"third\"=${third:raw}::text\r\n   *\r\n   * cs.assign({prefix: 'a b c'});\r\n   * //=> \"a b c\".\"second\"=${second:json},\"a b c\".\"third\"=${third:raw}::text\r\n   */\n\n  this.assign = options => {\n    const hasPrefix = options && options.prefix && typeof options.prefix === 'string';\n\n    if (updates && !hasPrefix) {\n      return updates;\n    }\n\n    let dynamic = hasPrefix;\n    const hasSource = options && options.source && typeof options.source === 'object';\n    let list = this.columns.filter(c => {\n      if (c.cnd) {\n        return false;\n      }\n\n      if (c.skip) {\n        dynamic = true;\n\n        if (hasSource) {\n          const a = colDesc(c, options.source);\n\n          if (c.skip.call(options.source, a)) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    });\n    const prefix = hasPrefix ? npm.formatting.as.alias(options.prefix) + '.' : '';\n    list = list.map(c => prefix + c.escapedName + '=' + c.variable + c.castText).join();\n\n    if (!dynamic) {\n      updates = list;\n    }\n\n    return list;\n  };\n  /**\r\n   * @method helpers.ColumnSet#assignColumns\r\n   * @description\r\n   * Generates assignments for all columns in the set, with support for aliases and column-skipping logic.\r\n   * Aliases are set by using method {@link formatting.alias as.alias}.\r\n   *\r\n   * @param {Object} [options]\r\n   * Optional Parameters.\r\n   *\r\n   * @param {string} [options.from]\r\n   * Alias for the source columns.\r\n   *\r\n   * @param {string} [options.to]\r\n   * Alias for the destination columns.\r\n   *\r\n   * @param {string | Array<string> | function} [options.skip]\r\n   * Name(s) of the column(s) to be skipped (case-sensitive). It can be either a single string or an array of strings.\r\n   *\r\n   * It can also be a function - iterator, to be called for every column, passing in {@link helpers.Column Column} as\r\n   * `this` context, and plus as a single parameter. The function would return a truthy value for every column that needs to be skipped.\r\n   *\r\n   * @returns {string}\r\n   * A string of comma-separated column assignments.\r\n   *\r\n   * @example\r\n   *\r\n   * const cs = new pgp.helpers.ColumnSet(['id', 'city', 'street']);\r\n   *\r\n   * cs.assignColumns({from: 'EXCLUDED', skip: 'id'})\r\n   * //=> \"city\"=EXCLUDED.\"city\",\"street\"=EXCLUDED.\"street\"\r\n   *\r\n   * @example\r\n   *\r\n   * const cs = new pgp.helpers.ColumnSet(['?id', 'city', 'street']);\r\n   *\r\n   * cs.assignColumns({from: 'source', to: 'target', skip: c => c.cnd})\r\n   * //=> target.\"city\"=source.\"city\",target.\"street\"=source.\"street\"\r\n   *\r\n   */\n\n\n  this.assignColumns = options => {\n    options = npm.assertOptions(options, ['from', 'to', 'skip']);\n    const skip = typeof options.skip === 'string' && [options.skip] || (Array.isArray(options.skip) || typeof options.skip === 'function') && options.skip;\n    const from = typeof options.from === 'string' && options.from && npm.formatting.as.alias(options.from) + '.' || '';\n    const to = typeof options.to === 'string' && options.to && npm.formatting.as.alias(options.to) + '.' || '';\n    const iterator = typeof skip === 'function' ? c => !skip.call(c, c) : c => skip.indexOf(c.name) === -1;\n    const cols = skip ? this.columns.filter(iterator) : this.columns;\n    return cols.map(c => to + c.escapedName + '=' + from + c.escapedName).join();\n  };\n  /**\r\n   * @method helpers.ColumnSet#extend\r\n   * @description\r\n   * Creates a new {@link helpers.ColumnSet ColumnSet}, by joining the two sets of columns.\r\n   *\r\n   * If the two sets contain a column with the same `name` (case-sensitive), an error is thrown.\r\n   *\r\n   * @param {helpers.Column|helpers.ColumnSet|array} columns\r\n   * Columns to be appended, of the same type as parameter `columns` during {@link helpers.ColumnSet ColumnSet} construction, except:\r\n   * - it can also be of type {@link helpers.ColumnSet ColumnSet}\r\n   * - it cannot be a simple object (properties enumeration is not supported here)\r\n   *\r\n   * @returns {helpers.ColumnSet}\r\n   * New {@link helpers.ColumnSet ColumnSet} object with the extended/concatenated list of columns.\r\n   *\r\n   * @see\r\n   * {@link helpers.Column Column},\r\n   * {@link helpers.ColumnSet#merge merge}\r\n   *\r\n   * @example\r\n   *\r\n   * const pgp = require('pg-promise')();\r\n   *\r\n   * const cs = new pgp.helpers.ColumnSet(['one', 'two'], {table: 'my-table'});\r\n   * console.log(cs);\r\n   * //=>\r\n   * // ColumnSet {\r\n   * //    table: \"my-table\"\r\n   * //    columns: [\r\n   * //        Column {\r\n   * //            name: \"one\"\r\n   * //        }\r\n   * //        Column {\r\n   * //            name: \"two\"\r\n   * //        }\r\n   * //    ]\r\n   * // }\r\n   * const csExtended = cs.extend(['three']);\r\n   * console.log(csExtended);\r\n   * //=>\r\n   * // ColumnSet {\r\n   * //    table: \"my-table\"\r\n   * //    columns: [\r\n   * //        Column {\r\n   * //            name: \"one\"\r\n   * //        }\r\n   * //        Column {\r\n   * //            name: \"two\"\r\n   * //        }\r\n   * //        Column {\r\n   * //            name: \"three\"\r\n   * //        }\r\n   * //    ]\r\n   * // }\r\n   */\n\n\n  this.extend = cols => {\n    let cs = cols;\n\n    if (!(cs instanceof ColumnSet)) {\n      cs = new ColumnSet(cols);\n    } // Any duplicate column will throw Error = 'Duplicate column name \"name\".',\n\n\n    return new ColumnSet(this.columns.concat(cs.columns), {\n      table: this.table\n    });\n  };\n  /**\r\n   * @method helpers.ColumnSet#merge\r\n   * @description\r\n   * Creates a new {@link helpers.ColumnSet ColumnSet}, by joining the two sets of columns.\r\n   *\r\n   * Items in `columns` with the same `name` (case-sensitive) override the original columns.\r\n   *\r\n   * @param {helpers.Column|helpers.ColumnSet|array} columns\r\n   * Columns to be appended, of the same type as parameter `columns` during {@link helpers.ColumnSet ColumnSet} construction, except:\r\n   * - it can also be of type {@link helpers.ColumnSet ColumnSet}\r\n   * - it cannot be a simple object (properties enumeration is not supported here)\r\n   *\r\n   * @see\r\n   * {@link helpers.Column Column},\r\n   * {@link helpers.ColumnSet#extend extend}\r\n   *\r\n   * @returns {helpers.ColumnSet}\r\n   * New {@link helpers.ColumnSet ColumnSet} object with the merged list of columns.\r\n   *\r\n   * @example\r\n   *\r\n   * const pgp = require('pg-promise')();\r\n   *\r\n   * const cs = new pgp.helpers.ColumnSet(['?one', 'two:json'], {table: 'my-table'});\r\n   * console.log(cs);\r\n   * //=>\r\n   * // ColumnSet {\r\n   * //    table: \"my-table\"\r\n   * //    columns: [\r\n   * //        Column {\r\n   * //            name: \"one\"\r\n   * //            cnd: true\r\n   * //        }\r\n   * //        Column {\r\n   * //            name: \"two\"\r\n   * //            mod: \":json\"\r\n   * //        }\r\n   * //    ]\r\n   * // }\r\n   * const csMerged = cs.merge(['two', 'three^']);\r\n   * console.log(csMerged);\r\n   * //=>\r\n   * // ColumnSet {\r\n   * //    table: \"my-table\"\r\n   * //    columns: [\r\n   * //        Column {\r\n   * //            name: \"one\"\r\n   * //            cnd: true\r\n   * //        }\r\n   * //        Column {\r\n   * //            name: \"two\"\r\n   * //        }\r\n   * //        Column {\r\n   * //            name: \"three\"\r\n   * //            mod: \"^\"\r\n   * //        }\r\n   * //    ]\r\n   * // }\r\n   *\r\n   */\n\n\n  this.merge = $columns => {\n    let cs = $columns;\n\n    if (!(cs instanceof ColumnSet)) {\n      cs = new ColumnSet($columns);\n    }\n\n    const colNames = {},\n          cols = [];\n    this.columns.forEach((c, idx) => {\n      cols.push(c);\n      colNames[c.name] = idx;\n    });\n    cs.columns.forEach(c => {\n      if (c.name in colNames) {\n        cols[colNames[c.name]] = c;\n      } else {\n        cols.push(c);\n      }\n    });\n    return new ColumnSet(cols, {\n      table: this.table\n    });\n  };\n  /**\r\n   * @method helpers.ColumnSet#prepare\r\n   * @description\r\n   * Prepares a source object to be formatted, by cloning it and applying the rules as set by the\r\n   * columns configuration.\r\n   *\r\n   * This method is primarily for internal use, that's why it does not validate the input parameters.\r\n   *\r\n   * @param {object} source\r\n   * The source object to be prepared, if required.\r\n   *\r\n   * It must be a non-`null` object, which the method does not validate, as it is\r\n   * intended primarily for internal use by the library.\r\n   *\r\n   * @returns {object}\r\n   * When the object needs to be prepared, the method returns a clone of the source object,\r\n   * with all properties and values set according to the columns configuration.\r\n   *\r\n   * When the object does not need to be prepared, the original object is returned.\r\n   */\n\n\n  this.prepare = source => {\n    if (isSimple) {\n      return source; // a simple ColumnSet requires no object preparation;\n    }\n\n    const target = {};\n    this.columns.forEach(c => {\n      const a = colDesc(c, source);\n\n      if (c.init) {\n        target[a.name] = c.init.call(source, a);\n      } else {\n        if (a.exists || 'def' in c) {\n          target[a.name] = a.value;\n        }\n      }\n    });\n    return target;\n  };\n\n  Object.freeze(this);\n\n  function colDesc(column, source) {\n    const a = {\n      source,\n      name: column.prop || column.name\n    };\n    a.exists = a.name in source;\n\n    if (a.exists) {\n      a.value = source[a.name];\n    } else {\n      a.value = 'def' in column ? column.def : undefined;\n    }\n\n    return a;\n  }\n}\n/**\r\n * @method helpers.ColumnSet#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\n\n\nColumnSet.prototype.toString = function (level) {\n  level = level > 0 ? parseInt(level) : 0;\n  const gap0 = npm.utils.messageGap(level),\n        gap1 = npm.utils.messageGap(level + 1),\n        lines = ['ColumnSet {'];\n\n  if (this.table) {\n    lines.push(gap1 + 'table: ' + this.table);\n  }\n\n  if (this.columns.length) {\n    lines.push(gap1 + 'columns: [');\n    this.columns.forEach(c => {\n      lines.push(c.toString(2));\n    });\n    lines.push(gap1 + ']');\n  } else {\n    lines.push(gap1 + 'columns: []');\n  }\n\n  lines.push(gap0 + '}');\n  return lines.join(npm.os.EOL);\n};\n\nnpm.utils.addInspection(ColumnSet, function () {\n  return this.toString();\n});\nmodule.exports = ColumnSet;","map":null,"metadata":{},"sourceType":"script"}