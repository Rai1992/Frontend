{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst util = require('util');\n\nconst Entity = require('./entity');\n\nconst EventEmitter = require('events');\n\nconst SingleValueStream = require('./util/single-value-stream');\n/**\n * An executable function or script.\n *\n * @class\n * @extends Entity\n * @param {Object} spec - An expanded {@linkcode Entity} specification:\n * @param {Object} spec.db - A {@linkcode Database}.\n * @param {String} spec.name - The name of the function or script.\n * @param {String} spec.schema - The owning schema or file path of the function\n * or script, respectively.\n * @param {String|QueryFile} spec.sql - A function invocation statement or a\n * pg-promise QueryFile.\n * @param {Number} spec.arity - Number of parameters the executable expects,\n * only for QueryFiles.\n * @param {Boolean} spec.isVariadic - Whether the executable accepts\n * variable-length argument lists as the last parameter, only for database\n * functions.\n * @param {Boolean} spec.enhancedFunctions - True to enable single row/value\n * results processing.\n * @param {Boolean} spec.singleRow - If true, return the first result row as an\n * object (with enhancedFunctions).\n * @param {Boolean} spec.singleValue - If true, return results as a primitive\n * or primitives (with enhancedFunctions).\n */\n\n\nconst Executable = function (spec) {\n  Entity.apply(this, arguments);\n  this.sql = spec.sql;\n  this.isDatabaseFunction = Object.prototype.hasOwnProperty.call(spec, 'isVariadic');\n  this.arity = spec.arity; // only for scripts\n\n  this.isVariadic = !!spec.isVariadic; // only for db functions\n\n  this.isProcedure = spec.kind === 'p'; // only for db functions\n\n  this.singleRow = spec.enhancedFunctions && spec.singleRow;\n  this.singleValue = spec.enhancedFunctions && spec.singleValue;\n};\n\nutil.inherits(Executable, Entity);\n/**\n * Invoke the function or script.\n *\n * @param {Object} [options] - {@link https://massivejs.org/docs/options-objects|Result processing options}.\n * @return {Promise} Execution results as an array, unless options.single is\n * toggled or enhanced functions are enabled and the function returns a single\n * value.\n */\n\nExecutable.prototype.invoke = function () {\n  let statement = this.sql,\n      args,\n      opts = {\n    single: this.singleRow || false\n  }; // arrays as the first argument are always a full parameter list, for\n  // functions and scripts alike; for scripts with arity > 0, an object as the\n  // first argument may be a named parameter block\n\n  if (_.isArray(arguments[0]) || !this.isDatabaseFunction && this.arity > 0 && _.isPlainObject(arguments[0]) && !_.isString(this.sql)) {\n    args = arguments[0];\n    opts = _.defaults(_.last(arguments), opts);\n  } else {\n    args = Array.prototype.slice.call(arguments); // functions don't have an arity to check, but since they can't use named\n    // parameters we can just check for an object at the end of the params; for\n    // scripts, options make the arguments array longer than the arity.\n\n    if (this.isDatabaseFunction && _.isPlainObject(_.last(args)) || !this.isDatabaseFunction && arguments.length === this.arity + 1) {\n      opts = _.defaults(args.pop(), opts);\n    }\n  }\n\n  if (statement === undefined) {\n    // functions can be overloaded or variadic, so we have to build the\n    // statement dynamically to handle however many arguments are present at\n    // call time\n    const params = _.times(args.length, i => \"$\".concat(i + 1)).join(',');\n\n    if (this.isProcedure) {\n      statement = \"CALL \\\"\".concat(this.schema, \"\\\".\\\"\").concat(this.name, \"\\\"(\").concat(params, \")\");\n    } else {\n      statement = \"SELECT * FROM \\\"\".concat(this.schema, \"\\\".\\\"\").concat(this.name, \"\\\"(\").concat(params, \")\");\n    }\n  }\n\n  if (args.length === 0) {\n    args = undefined;\n  }\n\n  return this.db.query(statement, args, opts).then(result => {\n    if (result instanceof EventEmitter && typeof result.read === 'function') {\n      if (this.singleValue) {\n        result = result.pipe(new SingleValueStream());\n      }\n\n      return result;\n    }\n\n    let data = result;\n\n    if (this.singleValue) {\n      try {\n        data = _.isArray(data) ? data.map(SingleValueStream.singleValue) : SingleValueStream.singleValue(data);\n      } catch (e) {\n        return this.db.$p.reject(e);\n      }\n    }\n\n    return data;\n  });\n};\n\nmodule.exports = Executable;","map":null,"metadata":{},"sourceType":"script"}