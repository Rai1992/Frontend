{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n'use strict';\n\nconst npm = {\n  util: require('util'),\n  utils: require('./utils'),\n  special: require('./special'),\n  QueryFile: require('./queryFile'),\n  formatting: require('./formatting'),\n  result: require('./result'),\n  errors: require('./errors'),\n  events: require('./events'),\n  stream: require('./stream'),\n  types: require('./types'),\n  text: require('./text')\n};\nconst QueryResultError = npm.errors.QueryResultError,\n      InternalError = npm.utils.InternalError,\n      ExternalQuery = npm.types.ExternalQuery,\n      PreparedStatement = npm.types.PreparedStatement,\n      ParameterizedQuery = npm.types.ParameterizedQuery,\n      SpecialQuery = npm.special.SpecialQuery,\n      qrec = npm.errors.queryResultErrorCode;\nconst badMask = npm.result.one | npm.result.many; // unsupported combination bit-mask;\n//////////////////////////////\n// Generic query method;\n\nfunction $query(ctx, query, values, qrm, config) {\n  const special = qrm instanceof SpecialQuery && qrm;\n  const $p = config.promise;\n\n  if (special && special.isStream) {\n    return npm.stream.call(this, ctx, query, values, config);\n  }\n\n  const opt = ctx.options,\n        capSQL = opt.capSQL;\n  let error,\n      isFunc,\n      pgFormatting = opt.pgFormatting,\n      params = pgFormatting ? values : undefined;\n\n  if (typeof query === 'function') {\n    try {\n      query = npm.formatting.resolveFunc(query, values);\n    } catch (e) {\n      error = e;\n      params = values;\n      query = npm.util.inspect(query);\n    }\n  }\n\n  if (!error && !query) {\n    error = new TypeError(npm.text.invalidQuery);\n  }\n\n  if (!error && typeof query === 'object') {\n    if (query instanceof npm.QueryFile) {\n      query.prepare();\n\n      if (query.error) {\n        error = query.error;\n        query = query.file;\n      } else {\n        query = query[npm.QueryFile.$query];\n      }\n    } else {\n      if ('funcName' in query) {\n        isFunc = true;\n        query = query.funcName; // query is a function name;\n      } else {\n        if (query instanceof ExternalQuery) {\n          pgFormatting = true;\n        } else {\n          if ('name' in query) {\n            query = new PreparedStatement(query);\n            pgFormatting = true;\n          } else {\n            if ('text' in query) {\n              query = new ParameterizedQuery(query);\n              pgFormatting = true;\n            }\n          }\n        }\n\n        if (query instanceof ExternalQuery && !npm.utils.isNull(values)) {\n          query.values = values;\n        }\n      }\n    }\n  }\n\n  if (!error) {\n    if (!pgFormatting && !npm.utils.isText(query)) {\n      error = new TypeError(isFunc ? npm.text.invalidFunction : npm.text.invalidQuery);\n    }\n\n    if (query instanceof ExternalQuery) {\n      const qp = query.parse();\n\n      if (qp instanceof Error) {\n        error = qp;\n      } else {\n        query = qp;\n      }\n    }\n  }\n\n  if (!error && !special) {\n    if (npm.utils.isNull(qrm)) {\n      qrm = npm.result.any; // default query result;\n    } else {\n      if (qrm !== parseInt(qrm) || (qrm & badMask) === badMask || qrm < 1 || qrm > 6) {\n        error = new TypeError(npm.text.invalidMask);\n      }\n    }\n  }\n\n  if (!error && (!pgFormatting || isFunc)) {\n    try {\n      // use 'pg-promise' implementation of values formatting;\n      if (isFunc) {\n        params = undefined;\n        query = npm.formatting.formatFunction(query, values, capSQL);\n      } else {\n        query = npm.formatting.formatQuery(query, values);\n      }\n    } catch (e) {\n      if (isFunc) {\n        const prefix = capSQL ? 'SELECT * FROM' : 'select * from';\n        query = prefix + ' ' + query + '(...)';\n      } else {\n        params = values;\n      }\n\n      error = e instanceof Error ? e : new npm.utils.InternalError(e);\n    }\n  }\n\n  return $p((resolve, reject) => {\n    if (notifyReject()) {\n      return;\n    }\n\n    error = npm.events.query(opt, getContext());\n\n    if (notifyReject()) {\n      return;\n    }\n\n    try {\n      const start = Date.now();\n      ctx.db.client.query(query, params, (err, result) => {\n        let data,\n            multiResult,\n            lastResult = result;\n\n        if (err) {\n          error = err;\n        } else {\n          multiResult = Array.isArray(result);\n\n          if (multiResult) {\n            lastResult = result[result.length - 1];\n\n            for (let i = 0; i < result.length; i++) {\n              const r = result[i];\n              error = npm.events.receive(opt, r.rows, r, getContext());\n\n              if (error) {\n                break;\n              }\n            }\n          } else {\n            result.duration = Date.now() - start;\n            error = npm.events.receive(opt, result.rows, result, getContext());\n          }\n        }\n\n        if (!error) {\n          data = lastResult;\n\n          if (special) {\n            if (special.isMultiResult) {\n              data = multiResult ? result : [result]; // method .multiResult() called\n            }\n          } else {\n            data = data.rows;\n            const len = data.length;\n\n            if (len) {\n              if (len > 1 && qrm & npm.result.one) {\n                // one row was expected, but returned multiple;\n                error = new QueryResultError(qrec.multiple, lastResult, query, params);\n              } else {\n                if (!(qrm & (npm.result.one | npm.result.many))) {\n                  // no data should have been returned;\n                  error = new QueryResultError(qrec.notEmpty, lastResult, query, params);\n                } else {\n                  if (!(qrm & npm.result.many)) {\n                    data = data[0];\n                  }\n                }\n              }\n            } else {\n              // no data returned;\n              if (qrm & npm.result.none) {\n                if (qrm & npm.result.one) {\n                  data = null;\n                } else {\n                  data = qrm & npm.result.many ? data : null;\n                }\n              } else {\n                error = new QueryResultError(qrec.noData, lastResult, query, params);\n              }\n            }\n          }\n        }\n\n        if (!notifyReject()) {\n          resolve(data);\n        }\n      });\n    } catch (e) {\n      // this can only happen as a result of an internal failure within node-postgres,\n      // like during a sudden loss of communications, which is impossible to reproduce\n      // automatically, so removing it from the test coverage:\n      // istanbul ignore next\n      error = e;\n    }\n\n    function getContext() {\n      let client;\n\n      if (ctx.db) {\n        client = ctx.db.client;\n      } else {\n        error = new Error(npm.text.looseQuery);\n      }\n\n      return {\n        client,\n        query,\n        params,\n        dc: ctx.dc,\n        ctx: ctx.ctx\n      };\n    }\n\n    notifyReject();\n\n    function notifyReject() {\n      const context = getContext();\n\n      if (error) {\n        if (error instanceof InternalError) {\n          error = error.error;\n        }\n\n        npm.events.error(opt, error, context);\n        reject(error);\n        return true;\n      }\n    }\n  });\n}\n\nmodule.exports = config => {\n  return function (ctx, query, values, qrm) {\n    return $query.call(this, ctx, query, values, qrm, config);\n  };\n};","map":null,"metadata":{},"sourceType":"script"}