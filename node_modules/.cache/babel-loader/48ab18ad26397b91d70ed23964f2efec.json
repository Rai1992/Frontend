{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n'use strict';\n\nconst npm = {\n  assertOptions: require('assert-options'),\n  TableName: require('../tableName'),\n  ColumnSet: require('../columnSet'),\n  formatting: require('../../formatting'),\n  utils: require('../../utils')\n};\n/**\r\n * @method helpers.update\r\n * @description\r\n * Generates a simplified `UPDATE` query for either one object or an array of objects.\r\n *\r\n * The resulting query needs a `WHERE` clause to be appended to it, to determine the update logic.\r\n * This is to allow for update conditions of any complexity that are easy to add.\r\n *\r\n * @param {object|object[]} data\r\n * An update object with properties for update values, or an array of such objects.\r\n *\r\n * When `data` is not a non-null object and not an array, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`\r\n *\r\n * When `data` is an empty array, it will throw {@link external:TypeError TypeError} = `Cannot generate an UPDATE from an empty array.`\r\n *\r\n * When `data` is an array that contains a non-object value, the method will throw {@link external:Error Error} =\r\n * `Invalid update object at index N.`\r\n *\r\n * @param {array|helpers.Column|helpers.ColumnSet} [columns]\r\n * Set of columns to be updated.\r\n *\r\n * It is optional when `data` is a single object, and required when `data` is an array of objects. If not specified for an array\r\n * of objects, the method will throw {@link external:TypeError TypeError} = `Parameter 'columns' is required when updating multiple records.`\r\n *\r\n * When `columns` is not a {@link helpers.ColumnSet ColumnSet} object, a temporary {@link helpers.ColumnSet ColumnSet}\r\n * is created - from the value of `columns` (if it was specified), or from the value of `data` (if it is not an array).\r\n *\r\n * When the final {@link helpers.ColumnSet ColumnSet} is empty (no columns in it), the method will throw\r\n * {@link external:Error Error} = `Cannot generate an UPDATE without any columns.`, unless option `emptyUpdate` was specified.\r\n *\r\n * @param {helpers.TableName|string|{table,schema}} [table]\r\n * Table to be updated.\r\n *\r\n * It is normally a required parameter. But when `columns` is passed in as a {@link helpers.ColumnSet ColumnSet} object\r\n * with `table` set in it, that will be used when this parameter isn't specified. When neither is available, the method\r\n * will throw {@link external:Error Error} = `Table name is unknown.`\r\n *\r\n * @param {object} [options]\r\n * An object with formatting options for multi-row `UPDATE` queries.\r\n *\r\n * @param {string} [options.tableAlias=t]\r\n * Name of the SQL variable that represents the destination table.\r\n *\r\n * @param {string} [options.valueAlias=v]\r\n * Name of the SQL variable that represents the values.\r\n *\r\n * @param {*} [options.emptyUpdate]\r\n * This is a convenience option, to avoid throwing an error when generating a conditional update results in no columns.\r\n *\r\n * When present, regardless of the value, this option overrides the method's behaviour when applying `skip` logic results in no columns,\r\n * i.e. when every column is being skipped.\r\n *\r\n * By default, in that situation the method throws {@link external:Error Error} = `Cannot generate an UPDATE without any columns.`\r\n * But when this option is present, the method will instead return whatever value the option was passed.\r\n *\r\n * @returns {*}\r\n * The method usually returns the resulting query string that typically needs a `WHERE` condition appended.\r\n *\r\n * However, if it results in an empty update, and option `emptyUpdate` was passed in, then the method returns whatever\r\n * value the option was passed.\r\n *\r\n * @see\r\n *  {@link helpers.Column Column},\r\n *  {@link helpers.ColumnSet ColumnSet},\r\n *  {@link helpers.TableName TableName}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')({\r\n *    capSQL: true // if you want all generated SQL capitalized\r\n * });\r\n *\r\n * const dataSingle = {id: 1, val: 123, msg: 'hello'};\r\n * const dataMulti = [{id: 1, val: 123, msg: 'hello'}, {id: 2, val: 456, msg: 'world!'}];\r\n *\r\n * // Although column details can be taken from the data object, it is not\r\n * // a likely scenario for an update, unless updating the whole table:\r\n *\r\n * pgp.helpers.update(dataSingle, null, 'my-table');\r\n * //=> UPDATE \"my-table\" SET \"id\"=1,\"val\"=123,\"msg\"='hello'\r\n *\r\n * @example\r\n *\r\n * // A typical single-object update:\r\n *\r\n * pgp.helpers.update(dataSingle, ['val', 'msg'], 'my-table') + ' WHERE id = ' + dataSingle.id;\r\n * //=> UPDATE \"my-table\" SET \"val\"=123,\"msg\"='hello' WHERE id = 1\r\n *\r\n * @example\r\n *\r\n * // Column details are required for a multi-row `UPDATE`;\r\n * // Adding '?' in front of a column name means it is only for a WHERE condition:\r\n *\r\n * pgp.helpers.update(dataMulti, ['?id', 'val', 'msg'], 'my-table') + ' WHERE v.id = t.id';\r\n * //=> UPDATE \"my-table\" AS t SET \"val\"=v.\"val\",\"msg\"=v.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS v(\"id\",\"val\",\"msg\") WHERE v.id = t.id\r\n *\r\n * @example\r\n *\r\n * // Column details from a reusable ColumnSet (recommended for performance):\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id', 'val', 'msg'], {table: 'my-table'});\r\n *\r\n * pgp.helpers.update(dataMulti, cs) + ' WHERE v.id = t.id';\r\n * //=> UPDATE \"my-table\" AS t SET \"val\"=v.\"val\",\"msg\"=v.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS v(\"id\",\"val\",\"msg\") WHERE v.id = t.id\r\n *\r\n * @example\r\n *\r\n * // Using parameter `options` to change the default alias names:\r\n *\r\n * pgp.helpers.update(dataMulti, cs, null, {tableAlias: 'X', valueAlias: 'Y'}) + ' WHERE Y.id = X.id';\r\n * //=> UPDATE \"my-table\" AS X SET \"val\"=Y.\"val\",\"msg\"=Y.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS Y(\"id\",\"val\",\"msg\") WHERE Y.id = X.id\r\n *\r\n * @example\r\n *\r\n * // Handling an empty update\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id', '?name'], {table: 'tt'}); // no actual update-able columns\r\n * const result = pgp.helpers.update(dataMulti, cs, null, {emptyUpdate: 123});\r\n * if(result === 123) {\r\n *    // We know the update is empty, i.e. no columns that can be updated;\r\n *    // And it didn't throw because we specified `emptyUpdate` option.\r\n * }\r\n */\n\nfunction update(data, columns, table, options, capSQL) {\n  if (!data || typeof data !== 'object') {\n    throw new TypeError('Invalid parameter \\'data\\' specified.');\n  }\n\n  const isArray = Array.isArray(data);\n\n  if (isArray && !data.length) {\n    throw new TypeError('Cannot generate an UPDATE from an empty array.');\n  }\n\n  if (columns instanceof npm.ColumnSet) {\n    if (npm.utils.isNull(table)) {\n      table = columns.table;\n    }\n  } else {\n    if (isArray && npm.utils.isNull(columns)) {\n      throw new TypeError('Parameter \\'columns\\' is required when updating multiple records.');\n    }\n\n    columns = new npm.ColumnSet(columns || data);\n  }\n\n  options = npm.assertOptions(options, ['tableAlias', 'valueAlias', 'emptyUpdate']);\n  const format = npm.formatting.as.format,\n        useEmptyUpdate = 'emptyUpdate' in options;\n\n  if (isArray) {\n    const tableAlias = npm.formatting.as.alias(npm.utils.isNull(options.tableAlias) ? 't' : options.tableAlias);\n    const valueAlias = npm.formatting.as.alias(npm.utils.isNull(options.valueAlias) ? 'v' : options.valueAlias);\n    const q = capSQL ? sql.multi.capCase : sql.multi.lowCase;\n    const actualColumns = columns.columns.filter(c => !c.cnd);\n\n    if (checkColumns(actualColumns)) {\n      return options.emptyUpdate;\n    }\n\n    checkTable();\n    const targetCols = actualColumns.map(c => c.escapedName + '=' + valueAlias + '.' + c.escapedName).join();\n    const values = data.map((d, index) => {\n      if (!d || typeof d !== 'object') {\n        throw new Error('Invalid update object at index ' + index + '.');\n      }\n\n      return '(' + format(columns.variables, columns.prepare(d)) + ')';\n    }).join();\n    return format(q, [table.name, tableAlias, targetCols, values, valueAlias, columns.names]);\n  }\n\n  const updates = columns.assign({\n    source: data\n  });\n\n  if (checkColumns(updates)) {\n    return options.emptyUpdate;\n  }\n\n  checkTable();\n  const query = capSQL ? sql.single.capCase : sql.single.lowCase;\n  return format(query, table.name) + format(updates, columns.prepare(data));\n\n  function checkTable() {\n    if (table && !(table instanceof npm.TableName)) {\n      table = new npm.TableName(table);\n    }\n\n    if (!table) {\n      throw new Error('Table name is unknown.');\n    }\n  }\n\n  function checkColumns(cols) {\n    if (!cols.length) {\n      if (useEmptyUpdate) {\n        return true;\n      }\n\n      throw new Error('Cannot generate an UPDATE without any columns.');\n    }\n  }\n}\n\nconst sql = {\n  single: {\n    lowCase: 'update $1^ set ',\n    capCase: 'UPDATE $1^ SET '\n  },\n  multi: {\n    lowCase: 'update $1^ as $2^ set $3^ from (values$4^) as $5^($6^)',\n    capCase: 'UPDATE $1^ AS $2^ SET $3^ FROM (VALUES$4^) AS $5^($6^)'\n  }\n};\nmodule.exports = update;","map":null,"metadata":{},"sourceType":"script"}