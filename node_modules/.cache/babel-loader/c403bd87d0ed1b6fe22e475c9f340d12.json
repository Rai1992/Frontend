{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n'use strict';\n\nconst npm = {\n  spex: require('spex'),\n  utils: require('./utils'),\n  mode: require('./txMode'),\n  events: require('./events'),\n  query: require('./query'),\n  async: require('./async'),\n  text: require('./text')\n};\n/**\r\n * @interface Task\r\n * @description\r\n * Extends {@link Database} for an automatic connection session, with methods for executing multiple database queries.\r\n *\r\n * The type isn't available directly, it can only be created via methods {@link Database#task Database.task}, {@link Database#taskIf Database.taskIf},\r\n * {@link Database#tx Database.tx} and {@link Database#txIf Database.txIf}.\r\n *\r\n * When executing more than one request at a time, one should allocate and release the connection only once,\r\n * while executing all the required queries within the same connection session. More importantly, a transaction\r\n * can only work within a single connection.\r\n *\r\n * This is an interface for tasks/transactions to implement a connection session, during which you can\r\n * execute multiple queries against the same connection that's released automatically when the task/transaction is finished.\r\n *\r\n * Each task/transaction manages the connection automatically. When executed on the root {@link Database} object, the connection\r\n * is allocated from the pool, and once the method's callback has finished, the connection is released back to the pool.\r\n * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n *\r\n * @see\r\n * {@link Task#ctx ctx},\r\n * {@link Task#batch batch},\r\n * {@link Task#sequence sequence},\r\n * {@link Task#page page}\r\n *\r\n * @example\r\n * db.task(t => {\r\n *       // t = task protocol context;\r\n *       // t.ctx = Task Context;\r\n *       return t.one('select * from users where id=$1', 123)\r\n *           .then(user => {\r\n *               return t.any('select * from events where login=$1', user.name);\r\n *           });\r\n *   })\r\n * .then(events => {\r\n *       // success;\r\n *   })\r\n * .catch(error => {\r\n *       // error;\r\n *   });\r\n *\r\n */\n\nfunction Task(ctx, tag, isTX, config) {\n  const $p = config.promise;\n  /**\r\n   * @member {TaskContext} Task#ctx\r\n   * @readonly\r\n   * @description\r\n   * Task/Transaction Context object - contains individual properties for each task/transaction.\r\n   *\r\n   * @see event {@link event:query query}\r\n   *\r\n   * @example\r\n   *\r\n   * db.task(t => {\r\n   *     return t.ctx; // task context object\r\n   * })\r\n   *     .then(ctx => {\r\n   *         console.log('Task Duration:', ctx.duration);\r\n   *     });\r\n   *\r\n   * @example\r\n   *\r\n   * db.tx(t => {\r\n   *     return t.ctx; // transaction context object\r\n   * })\r\n   *     .then(ctx => {\r\n   *         console.log('Transaction Duration:', ctx.duration);\r\n   *     });\r\n   */\n\n  this.ctx = ctx.ctx = {}; // task context object;\n\n  npm.utils.addReadProp(this.ctx, 'isTX', isTX);\n\n  if ('context' in ctx) {\n    npm.utils.addReadProp(this.ctx, 'context', ctx.context);\n  }\n\n  npm.utils.addReadProp(this.ctx, 'connected', !ctx.db);\n  npm.utils.addReadProp(this.ctx, 'tag', tag);\n  npm.utils.addReadProp(this.ctx, 'dc', ctx.dc);\n  npm.utils.addReadProp(this.ctx, 'level', ctx.level);\n  npm.utils.addReadProp(this.ctx, 'inTransaction', ctx.inTransaction);\n\n  if (isTX) {\n    npm.utils.addReadProp(this.ctx, 'txLevel', ctx.txLevel);\n  }\n\n  npm.utils.addReadProp(this.ctx, 'parent', ctx.parentCtx); // generic query method;\n\n  this.query = function (query, values, qrm) {\n    if (!ctx.db) {\n      return $p.reject(new Error(npm.text.looseQuery));\n    }\n\n    return config.$npm.query.call(this, ctx, query, values, qrm);\n  };\n  /**\r\n   * @method Task#batch\r\n   * @description\r\n   * Settles a predefined array of mixed values by redirecting to method $[spex.batch].\r\n   *\r\n   * For complete method documentation see $[spex.batch].\r\n   *\r\n   * @param {array} values\r\n   * @param {Object} [options]\r\n   * Optional Parameters.\r\n   * @param {function} [options.cb]\r\n   *\r\n   * @returns {external:Promise}\r\n   */\n\n\n  this.batch = function (values, options) {\n    return config.$npm.spex.batch.call(this, values, options);\n  };\n  /**\r\n   * @method Task#page\r\n   * @description\r\n   * Resolves a dynamic sequence of arrays/pages with mixed values, by redirecting to method $[spex.page].\r\n   *\r\n   * For complete method documentation see $[spex.page].\r\n   *\r\n   * @param {function} source\r\n   * @param {Object} [options]\r\n   * Optional Parameters.\r\n   * @param {function} [options.dest]\r\n   * @param {number} [options.limit=0]\r\n   *\r\n   * @returns {external:Promise}\r\n   */\n\n\n  this.page = function (source, options) {\n    return config.$npm.spex.page.call(this, source, options);\n  };\n  /**\r\n   * @method Task#sequence\r\n   * @description\r\n   * Resolves a dynamic sequence of mixed values by redirecting to method $[spex.sequence].\r\n   *\r\n   * For complete method documentation see $[spex.sequence].\r\n   *\r\n   * @param {function} source\r\n   * @param {Object} [options]\r\n   * Optional Parameters.\r\n   * @param {function} [options.dest]\r\n   * @param {number} [options.limit=0]\r\n   * @param {boolean} [options.track=false]\r\n   *\r\n   * @returns {external:Promise}\r\n   */\n\n\n  this.sequence = function (source, options) {\n    return config.$npm.spex.sequence.call(this, source, options);\n  };\n}\n/**\r\n * @private\r\n * @method Task.callback\r\n * Callback invocation helper.\r\n *\r\n * @param ctx\r\n * @param obj\r\n * @param cb\r\n * @param config\r\n * @returns {Promise.<TResult>}\r\n */\n\n\nconst callback = (ctx, obj, cb, config) => {\n  const $p = config.promise;\n  let result;\n\n  if (cb.constructor.name === 'GeneratorFunction') {\n    cb = config.$npm.async(cb);\n  }\n\n  try {\n    result = cb.call(obj, obj); // invoking the callback function;\n  } catch (err) {\n    npm.events.error(ctx.options, err, {\n      client: ctx.db && ctx.db.client,\n      // the error can be due to loss of connectivity\n      dc: ctx.dc,\n      ctx: ctx.ctx\n    });\n    return $p.reject(err); // reject with the error;\n  }\n\n  if (result && typeof result.then === 'function') {\n    return result; // result is a valid promise object;\n  }\n\n  return $p.resolve(result);\n};\n/**\r\n * @private\r\n * @method Task.execute\r\n * Executes a task.\r\n *\r\n * @param ctx\r\n * @param obj\r\n * @param isTX\r\n * @param config\r\n * @returns {Promise.<TResult>}\r\n */\n\n\nconst execute = (ctx, obj, isTX, config) => {\n  const $p = config.promise; // updates the task context and notifies the client;\n\n  function update(start, success, result) {\n    const c = ctx.ctx;\n\n    if (start) {\n      npm.utils.addReadProp(c, 'start', new Date());\n    } else {\n      c.finish = new Date();\n      c.success = success;\n      c.result = result;\n      c.duration = c.finish - c.start;\n      npm.utils.lock(c, true);\n    }\n\n    (isTX ? npm.events.transact : npm.events.task)(ctx.options, {\n      client: ctx.db && ctx.db.client,\n      // loss of connectivity is possible at this point\n      dc: ctx.dc,\n      ctx: c\n    });\n  }\n\n  let cbData, cbReason, success, spName; // Save-Point Name;\n\n  const capSQL = ctx.options.capSQL; // capitalize sql;\n\n  update(true);\n\n  if (isTX) {\n    // executing a transaction;\n    spName = 'level_' + ctx.txLevel;\n    return begin().then(() => callback(ctx, obj, ctx.cb, config).then(data => {\n      cbData = data; // save callback data;\n\n      success = true;\n      return commit();\n    }, err => {\n      if (npm.utils.isConnectivityError(err)) {\n        // Cannot execute ROLLBACK after a connectivity error:\n        return $p.reject(err);\n      }\n\n      cbReason = err; // save callback failure reason;\n\n      return rollback();\n    }).then(() => {\n      if (success) {\n        update(false, true, cbData);\n        return cbData;\n      }\n\n      update(false, false, cbReason);\n      return $p.reject(cbReason);\n    }, err => {\n      // either COMMIT or ROLLBACK has failed, which is impossible\n      // to replicate in a test environment, so skipping from the test;\n      // istanbul ignore next:\n      update(false, false, err); // istanbul ignore next:\n\n      return $p.reject(err);\n    }), err => {\n      // BEGIN has failed, which is impossible to replicate in a test\n      // environment, so skipping the whole block from the test;\n      // istanbul ignore next:\n      update(false, false, err); // istanbul ignore next:\n\n      return $p.reject(err);\n    });\n  }\n\n  function begin() {\n    if (!ctx.txLevel && ctx.mode instanceof npm.mode.TransactionMode) {\n      return exec(ctx.mode.begin(capSQL), 'savepoint');\n    }\n\n    return exec('begin', 'savepoint');\n  }\n\n  function commit() {\n    return exec('commit', 'release savepoint');\n  }\n\n  function rollback() {\n    return exec('rollback', 'rollback to savepoint');\n  }\n\n  function exec(top, nested) {\n    if (ctx.txLevel) {\n      return obj.none((capSQL ? nested.toUpperCase() : nested) + ' ' + spName);\n    }\n\n    return obj.none(capSQL ? top.toUpperCase() : top);\n  } // executing a task;\n\n\n  return callback(ctx, obj, ctx.cb, config).then(data => {\n    update(false, true, data);\n    return data;\n  }).catch(error => {\n    update(false, false, error);\n    return $p.reject(error);\n  });\n};\n\nmodule.exports = config => {\n  const npmLocal = config.$npm; // istanbul ignore next:\n  // we keep 'npm.query' initialization here, even though it is always\n  // pre-initialized by the 'database' module, for integrity purpose.\n\n  npmLocal.query = npmLocal.query || npm.query(config);\n  npmLocal.async = npmLocal.async || npm.async(config);\n  npmLocal.spex = npmLocal.spex || npm.spex(config.promiseLib);\n  return {\n    Task,\n    execute,\n    callback\n  };\n};\n/**\r\n * @typedef TaskContext\r\n * @description\r\n * Task/Transaction Context used via property {@link Task#ctx ctx} inside tasks (methods {@link Database#task Database.task} and {@link Database#taskIf Database.taskIf})\r\n * and transactions (methods {@link Database#tx Database.tx} and {@link Database#txIf Database.txIf}).\r\n *\r\n * Properties `context`, `connected`, `parent`, `level`, `dc`, `isTX`, `tag`, `start` and `useCount` are set just before the operation has started,\r\n * while properties `finish`, `duration`, `success` and `result` are set immediately after the operation has finished.\r\n *\r\n * @property {*} context\r\n * If the operation was invoked with a calling context - `task.call(context,...)` or `tx.call(context,...)`,\r\n * this property is set with the context that was passed in. Otherwise, the property doesn't exist.\r\n *\r\n * @property {*} dc\r\n * _Database Context_ that was passed into the {@link Database} object during construction.\r\n *\r\n * @property {boolean} isTX\r\n * Indicates whether this operation is a transaction (as opposed to a regular task).\r\n *\r\n * @property {number} duration\r\n * Number of milliseconds consumed by the operation.\r\n *\r\n * Set after the operation has finished, it is simply a shortcut for `finish - start`.\r\n *\r\n * @property {number} level\r\n * Task nesting level, starting from 0, counting both regular tasks and transactions.\r\n *\r\n * @property {number} txLevel\r\n * Transaction nesting level, starting from 0. Transactions on level 0 use `BEGIN/COMMIT/ROLLBACK`,\r\n * while transactions on nested levels use the corresponding `SAVEPOINT` commands.\r\n *\r\n * This property exists only within the context of a transaction (`isTX = true`).\r\n *\r\n * @property {boolean} inTransaction\r\n * Available in both tasks and transactions, it simplifies checking when there is a transaction\r\n * going on either on this level or above.\r\n *\r\n * For example, when you want to check for a containing transaction while inside a task, and\r\n * only start a transaction when there is none yet.\r\n *\r\n * @property {TaskContext} parent\r\n * Parent task/transaction context, or `null` when it is top-level.\r\n *\r\n * @property {boolean} connected\r\n * Indicates when the task/transaction acquired the connection on its own (`connected = true`), and will release it once\r\n * the operation has finished. When the value is `false`, the operation is reusing an existing connection.\r\n *\r\n * @property {*} tag\r\n * Tag value as it was passed into the task. See methods {@link Database#task task} and {@link Database#tx tx}.\r\n *\r\n * @property {Date} start\r\n * Date/Time of when this operation started the execution.\r\n *\r\n * @property {number} useCount\r\n * Number of times the connection has been previously used, starting with 0 for a freshly\r\n * allocated physical connection.\r\n *\r\n * @property {Date} finish\r\n * Once the operation has finished, this property is set to the Data/Time of when it happened.\r\n *\r\n * @property {boolean} success\r\n * Once the operation has finished, this property indicates whether it was successful.\r\n *\r\n * @property {*} result\r\n * Once the operation has finished, this property contains the result, depending on property `success`:\r\n * - data resolved by the operation, if `success = true`\r\n * - error / rejection reason, if `success = false`\r\n *\r\n */","map":null,"metadata":{},"sourceType":"script"}