{"ast":null,"code":"'use strict';\n/**\n * Parse out a criterion key into something more intelligible. Massive is more\n * flexible than Postgres' query parser, with more alternate aliases for\n * operations and looser rules about quoting, especially with JSON fields. This\n * necessitates some pretty gnarly parsing.\n *\n * @module util/parseKey\n * @param  {String} key A reference to a database column. The field name may be quoted using double quotes to allow names which otherwise would not conform with database naming conventions. Optional components include, in order, [] and . notation to describe elements of a JSON field; ::type to describe a cast; and finally, an argument to the appendix function.\n * @param {Object} appendix A function which when invoked with an optional component of the key returns a value to be used later. So far used for operations (from {@linkcode where}) and ordering (from {@linkcode order}.\n * @return {Object} An object describing the parsed key.\n */\n\nexports = module.exports = function (key, appendix) {\n  key = key.trim();\n  const jsonShape = []; // describe a JSON path: true is a field, false an array index\n\n  let elements = []; // collect actual JSON path elements (for document queries)\n\n  let parsed = [[]]; // we're going to collect token arrays\n\n  let buffer = parsed[0]; // start with the first token\n\n  let inQuotedField = false; // ensure we pick up everything in quotes\n\n  let hasCast = false; // make sure we pull the appropriate token for castType\n\n  let i = 0;\n  let char = key.charAt(i);\n\n  do {\n    if (inQuotedField && char !== '\"') {\n      buffer.push(char);\n    } else {\n      switch (char) {\n        case '\"':\n          // quoted field\n          if (i === 0) {\n            inQuotedField = true; // just starting out, use the initial token\n          } else {\n            inQuotedField = false; // finishing the quoted field, new token\n\n            buffer = parsed[parsed.push([]) - 1];\n          }\n\n          break;\n\n        case ':':\n          // cast; new token, but we ignore the : characters since we only care\n          // about type\n          if (!hasCast) {\n            hasCast = true;\n            buffer = parsed[parsed.push([]) - 1];\n          }\n\n          break;\n\n        case '.':\n          // json path traversal. new token, and note that it's a field to ensure\n          // proper element/index handling later.\n          jsonShape.push(true);\n          buffer = parsed[parsed.push([]) - 1];\n          break;\n\n        case '[':\n          // json array index. new token, and note that it's an index for later.\n          jsonShape.push(false);\n          buffer = parsed[parsed.push([]) - 1];\n          break;\n\n        case ']':\n          // terminate json array index. starts a new token, no jsonShape push\n          buffer = parsed[parsed.push([]) - 1];\n          break;\n\n        case ' ':\n        case '\\t':\n        case '\\r':\n        case '\\n':\n          // whitespace; separates tokens\n          buffer = parsed[parsed.push([]) - 1];\n          break;\n\n        default:\n          // eslint-disable-line no-fallthrough\n          buffer.push(char);\n          break;\n      }\n    }\n\n    i++;\n  } while (char = key.charAt(i)); // eslint-disable-line no-cond-assign\n\n\n  parsed = parsed.reduce(function (acc, p) {\n    const str = p.join('').trim();\n\n    if (str) {\n      acc.push(str);\n    }\n\n    return acc;\n  }, []);\n  const field = parsed.shift();\n  let castType, appended;\n  let quotedField = \"\\\"\".concat(field, \"\\\"\");\n\n  if (jsonShape.length === 1) {\n    elements.push(parsed.shift());\n\n    if (jsonShape[0]) {\n      // object key\n      quotedField = \"\".concat(quotedField, \"->>'\").concat(elements[0], \"'\");\n    } else {\n      // array index\n      quotedField = \"\".concat(quotedField, \"->>\").concat(elements[0]);\n    }\n  } else if (jsonShape.length > 0) {\n    elements = parsed.splice(0, jsonShape.length);\n    quotedField = \"\".concat(quotedField, \"#>>'{\").concat(elements.join(','), \"}'\");\n  }\n\n  if (hasCast) {\n    castType = parsed.shift();\n\n    if (jsonShape.length > 0) {\n      quotedField = \"(\".concat(quotedField, \")::\").concat(castType);\n    } else {\n      quotedField = \"\".concat(quotedField, \"::\").concat(castType);\n    }\n  }\n\n  if (appendix) {\n    // anything remaining goes to appendix\n    appended = appendix(parsed.join(' ').toLowerCase());\n  }\n\n  return {\n    rawField: field,\n    field: quotedField,\n    elements,\n    appended,\n    isJSON: jsonShape.length > 0\n  };\n};","map":null,"metadata":{},"sourceType":"script"}