{"ast":null,"code":"'use strict';\n\nvar BatchError = require('../errors/batch');\n/**\r\n * @method batch\r\n * @description\r\n * Settles (resolves or rejects) every [mixed value]{@tutorial mixed} in the input array.\r\n *\r\n * The method resolves with an array of results, the same as the standard $[promise.all],\r\n * while providing comprehensive error details in case of a reject, in the form of\r\n * type {@link errors.BatchError BatchError}.\r\n *\r\n * @param {Array} values\r\n * Array of [mixed values]{@tutorial mixed} (it can be empty), to be resolved asynchronously, in no particular order.\r\n *\r\n * Passing in anything other than an array will reject with {@link external:TypeError TypeError} =\r\n * `Method 'batch' requires an array of values.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.cb]\r\n * Optional callback (or generator) to receive the result for each settled value.\r\n *\r\n * Callback Parameters:\r\n *  - `index` = index of the value in the source array\r\n *  - `success` - indicates whether the value was resolved (`true`), or rejected (`false`)\r\n *  - `result` = resolved data, if `success`=`true`, or else the rejection reason\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise to indicate that notifications are handled asynchronously.\r\n * And if the returned promise resolves, it signals a successful handling, while any resolved\r\n * data is ignored.\r\n *\r\n * If the function returns a rejected promise or throws an error, the entire method rejects\r\n * with {@link errors.BatchError BatchError} where the corresponding value in property `data`\r\n * is set to `{success, result, origin}`:\r\n *  - `success` = `false`\r\n *  - `result` = the rejection reason or the error thrown by the notification callback\r\n *  - `origin` = the original data passed into the callback as object `{success, result}`\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * The method resolves with an array of individual resolved results, the same as the standard $[promise.all].\r\n * In addition, the array is extended with a hidden read-only property `duration` - number of milliseconds\r\n * spent resolving all the data.\r\n *\r\n * The method rejects with {@link errors.BatchError BatchError} when any of the following occurs:\r\n *  - one or more values rejected or threw an error while being resolved as a [mixed value]{@tutorial mixed}\r\n *  - notification callback `cb` returned a rejected promise or threw an error\r\n *\r\n */\n\n\nfunction batch(values, options, config) {\n  var $p = config.promise,\n      utils = config.utils;\n\n  if (!Array.isArray(values)) {\n    return $p.reject(new TypeError('Method \\'batch\\' requires an array of values.'));\n  }\n\n  if (!values.length) {\n    var empty = [];\n    utils.extend(empty, 'duration', 0);\n    return $p.resolve(empty);\n  }\n\n  options = options || {};\n  var cb = utils.wrap(options.cb),\n      self = this,\n      start = Date.now();\n  return $p(function (resolve, reject) {\n    var cbTime,\n        errors = [],\n        remaining = values.length,\n        result = new Array(remaining);\n    values.forEach(function (item, i) {\n      utils.resolve.call(self, item, null, function (data) {\n        result[i] = data;\n        step(i, true, data);\n      }, function (reason) {\n        result[i] = {\n          success: false,\n          result: reason\n        };\n        errors.push(i);\n        step(i, false, reason);\n      });\n    });\n\n    function step(idx, pass, data) {\n      if (cb) {\n        var cbResult,\n            cbNow = Date.now(),\n            cbDelay = idx ? cbNow - cbTime : undefined;\n        cbTime = cbNow;\n\n        try {\n          cbResult = cb.call(self, idx, pass, data, cbDelay);\n        } catch (e) {\n          setError(e);\n        }\n\n        if (utils.isPromise(cbResult)) {\n          cbResult.then(check).catch(function (error) {\n            setError(error);\n            check();\n          });\n        } else {\n          check();\n        }\n      } else {\n        check();\n      }\n\n      function setError(e) {\n        var r = pass ? {\n          success: false\n        } : result[idx];\n\n        if (pass) {\n          result[idx] = r;\n          errors.push(idx);\n        }\n\n        r.result = e;\n        r.origin = {\n          success: pass,\n          result: data\n        };\n      }\n\n      function check() {\n        if (! --remaining) {\n          if (errors.length) {\n            errors.sort();\n\n            if (errors.length < result.length) {\n              for (var i = 0, k = 0; i < result.length; i++) {\n                if (i === errors[k]) {\n                  k++;\n                } else {\n                  result[i] = {\n                    success: true,\n                    result: result[i]\n                  };\n                }\n              }\n            }\n\n            reject(new BatchError(result, errors, Date.now() - start));\n          } else {\n            utils.extend(result, 'duration', Date.now() - start);\n            resolve(result);\n          }\n        }\n\n        return null; // this dummy return is just to prevent Bluebird warnings;\n      }\n    }\n  });\n}\n\nmodule.exports = function (config) {\n  return function (values, options) {\n    return batch.call(this, values, options, config);\n  };\n};","map":null,"metadata":{},"sourceType":"script"}