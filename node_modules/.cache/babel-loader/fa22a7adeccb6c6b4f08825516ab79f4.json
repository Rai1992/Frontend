{"ast":null,"code":"'use strict';\n/**\r\n * @method stream.read\r\n * @description\r\n * Consumes and processes data from a $[Readable] stream.\r\n *\r\n * It reads the entire stream, using either **paused mode** (default), or in chunks (see `options.readChunks`)\r\n * with support for both synchronous and asynchronous data processing.\r\n *\r\n * **NOTE:** Once the method has finished, the onus is on the caller to release the stream\r\n * according to its protocol.\r\n *\r\n * @param {Object} stream\r\n * $[Readable] stream object.\r\n *\r\n * Passing in anything else will throw `Readable stream is required.`\r\n *\r\n * @param {Function|generator} receiver\r\n * Data processing callback (or generator).\r\n *\r\n * Passing in anything else will throw `Invalid stream receiver.`\r\n *\r\n * Parameters:\r\n *  - `index` = index of the call made to the function\r\n *  - `data` = array of all data reads from the stream's buffer\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function is called with the same `this` context as the calling method.\r\n *\r\n * It can optionally return a promise object, if data processing is asynchronous.\r\n * And if a promise is returned, the method will not read data from the stream again,\r\n * until the promise has been resolved.\r\n *\r\n * If the function throws an error or returns a rejected promise, the method rejects\r\n * with the same error / rejection reason.\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Boolean} [options.closable=false]\r\n * Instructs the method to resolve on event `close` supported by the stream, as opposed to event\r\n * `end` that's used by default.\r\n *\r\n * @param {Boolean} [options.readChunks=false]\r\n * By default, the method handles event `readable` of the stream to consume data in a simplified form,\r\n * item by item. If you enable this option, the method will instead handle event `data` of the stream,\r\n * to consume chunks of data.\r\n *\r\n * @param {Number} [options.readSize]\r\n * When the value is greater than 0, it sets the read size from the stream's buffer\r\n * when the next data is available. By default, the method uses as few reads as possible\r\n * to get all the data currently available in the buffer.\r\n *\r\n * NOTE: This option is ignored when option `readChunks` is enabled.\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When finished successfully, resolves with object `{calls, reads, length, duration}`:\r\n *  - `calls` = number of calls made into the `receiver`\r\n *  - `reads` = number of successful reads from the stream\r\n *  - `length` = total length for all the data reads from the stream\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When it fails, the method rejects with the error/reject specified,\r\n * which can happen as a result of:\r\n *  - event `error` emitted by the stream\r\n *  - receiver throws an error or returns a rejected promise\r\n */\n\nfunction read(stream, receiver, options, config) {\n  var $p = config.promise,\n      utils = config.utils;\n\n  if (!utils.isReadableStream(stream)) {\n    return $p.reject(new TypeError('Readable stream is required.'));\n  }\n\n  if (typeof receiver !== 'function') {\n    return $p.reject(new TypeError('Invalid stream receiver.'));\n  }\n\n  receiver = utils.wrap(receiver);\n  options = options || {};\n  var cbTime,\n      ready,\n      waiting,\n      stop,\n      readSize = options.readSize > 0 ? parseInt(options.readSize) : null,\n      self = this,\n      reads = 0,\n      length = 0,\n      start = Date.now(),\n      index = 0,\n      receiveEvent = options.readChunks ? 'data' : 'readable';\n  return $p(function (resolve, reject) {\n    function onReceive(data) {\n      ready = true;\n      process(data);\n    }\n\n    function onEnd() {\n      if (!options.closable) {\n        success();\n      }\n    }\n\n    function onClose() {\n      success();\n    }\n\n    function onError(error) {\n      fail(error);\n    }\n\n    stream.on(receiveEvent, onReceive);\n    stream.on('end', onEnd);\n    stream.on('close', onClose);\n    stream.on('error', onError);\n\n    function process(data) {\n      if (!ready || stop || waiting) {\n        return;\n      }\n\n      ready = false;\n      var cache;\n\n      if (options.readChunks) {\n        cache = data; // istanbul ignore else;\n        // we cannot test the else condition, as it requires a special broken stream interface.\n\n        if (!Array.isArray(cache)) {\n          cache = [cache];\n        }\n\n        length += cache.length;\n        reads++;\n      } else {\n        cache = [];\n        waiting = true;\n\n        do {\n          var page = stream.read(readSize);\n\n          if (page) {\n            cache.push(page); // istanbul ignore next: requires a unique stream that\n            // creates objects without property `length` defined.\n\n            length += page.length || 0;\n            reads++;\n          }\n        } while (page);\n\n        if (!cache.length) {\n          waiting = false;\n          return;\n        }\n      }\n\n      var result,\n          cbNow = Date.now(),\n          cbDelay = index ? cbNow - cbTime : undefined;\n      cbTime = cbNow;\n\n      try {\n        result = receiver.call(self, index++, cache, cbDelay);\n      } catch (e) {\n        fail(e);\n        return;\n      }\n\n      if (utils.isPromise(result)) {\n        result.then(function () {\n          waiting = false;\n          process();\n          return null; // this dummy return is just to prevent Bluebird warnings;\n        }).catch(function (error) {\n          fail(error);\n        });\n      } else {\n        waiting = false;\n        process();\n      }\n    }\n\n    function success() {\n      cleanup();\n      resolve({\n        calls: index,\n        reads: reads,\n        length: length,\n        duration: Date.now() - start\n      });\n    }\n\n    function fail(error) {\n      stop = true;\n      cleanup();\n      reject(error);\n    }\n\n    function cleanup() {\n      stream.removeListener(receiveEvent, onReceive);\n      stream.removeListener('close', onClose);\n      stream.removeListener('error', onError);\n      stream.removeListener('end', onEnd);\n    }\n  });\n}\n\nmodule.exports = function (config) {\n  return function (stream, receiver, options) {\n    return read.call(this, stream, receiver, options, config);\n  };\n};","map":null,"metadata":{},"sourceType":"script"}