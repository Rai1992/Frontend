{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst parseKey = require('../util/parse-key');\n\nconst where = require('./where');\n\nconst orderBy = require('./order-by');\n/**\n * Represents a SELECT query.\n *\n * @class\n * @param {Readable} source - Database object to query.\n * @param {Object|String|UUID|Number} criteria - A criteria object, prebuilt\n * predicate, or primitive pk value.\n * @param {Object} [options] - {@link https://massivejs.org/docs/options-objects|Select options}.\n */\n\n\nconst Select = function (source, criteria = {}, options = {}) {\n  options = _.defaults(options, {\n    only: false,\n    orderBody: false,\n    generator: 'tableGenerator',\n    single: false\n  });\n  this.source = source.delimitedFullName;\n  this.only = options.only;\n  this.offset = options.offset;\n  this.limit = options.limit;\n  this.build = options.build;\n  this.document = options.document;\n  this.decompose = options.decompose;\n  this.generator = options.generator;\n  this.pageLength = options.pageLength;\n  this.single = options.single;\n  this.stream = options.stream;\n  this.forUpdate = options.forUpdate;\n  this.forShare = options.forShare;\n\n  switch (options.order) {\n    case null:\n      // null options.order indicates ORDER BY should be omitted entirely for\n      // aggregation etc\n      this.order = '';\n      break;\n\n    case undefined:\n      this.order = source.pk ? \"ORDER BY \\\"\".concat(source.pk.join('\", \"'), \"\\\"\") : 'ORDER BY 1';\n      break;\n\n    default:\n      this.order = orderBy(options.order, options.orderBody);\n      break;\n  }\n\n  this.fields = []; // add user-defined fields\n\n  this.fields = _.castArray(options.fields || []).reduce((all, field) => {\n    if (options.document) {\n      // document fields need to be aliased\n      all.push({\n        value: parseKey(\"body.\".concat(field)).field,\n        alias: field\n      });\n    } else {\n      all.push(parseKey(field).field);\n    }\n\n    return all;\n  }, this.fields); // interpolate unsafe user-defined expressions\n\n  _.forEach(options.exprs || [], (expr, name) => {\n    this.fields.push({\n      value: expr,\n      alias: name\n    });\n  });\n\n  if (!this.fields.length) {\n    if (!options.fields && !options.exprs) {\n      // nothing specified, select all\n      this.fields.push('*');\n    } else {\n      // explicit empty array, error state\n      this.error = 'The fields array cannot be empty';\n    }\n  } else if (options.document) {\n    // if the user *did* specify something, but we're querying a document table\n    // and so require the id field in addition to whatever they're after\n    this.fields.push('id');\n  }\n\n  if (!!source.isPkSearch && source.isPkSearch(criteria)) {\n    // we can't detect functions on one of n possible prototypes with hasOwnProperty above\n    if (_.isPlainObject(criteria)) {\n      // id:val search\n      this.where = where(criteria);\n    } else {\n      // primitive unary pk search\n      this.where = where(_.fromPairs([[source.pk[0], criteria]]));\n      this.single = true;\n    }\n  } else {\n    // standard case for Readables\n    this.where = where(criteria, 0, this.generator);\n  }\n\n  this.params = this.where.params; // with pageLength set for keyset pagination, add last values of ordering\n  // fields to criteria\n\n  if (this.pageLength) {\n    if (!Object.prototype.hasOwnProperty.call(options, 'order')) {\n      this.error = 'Keyset paging with pageLength requires options.order';\n    } else if (Object.prototype.hasOwnProperty.call(options, 'offset') || Object.prototype.hasOwnProperty.call(options, 'limit')) {\n      this.error = 'Keyset paging cannot be used with offset and limit';\n    } else if (Object.hasOwnProperty.call(options.order[0], 'last')) {\n      const paginationColumns = options.order.map(o => orderBy.fullAttribute(o)).join(',');\n      const placeholders = options.order.map((o, idx) => \"$\".concat(idx + this.params.length + 1)).join(',');\n      const comparison = options.order[0].direction && options.order[0].direction.toLowerCase() === 'desc' ? '<' : '>';\n      this.params = this.params.concat(options.order.map(o => o.last));\n      this.pagination = \"(\".concat(paginationColumns, \") \").concat(comparison, \" (\").concat(placeholders, \")\");\n    }\n  }\n};\n/**\n * Format this object into a SQL SELECT.\n *\n * @return {String} A SQL SELECT statement.\n */\n\n\nSelect.prototype.format = function () {\n  if (this.error) {\n    throw new Error(this.error);\n  }\n\n  const selectList = this.fields.map(f => {\n    if (_.isPlainObject(f)) {\n      // aliased definitions for document fields\n      return \"\".concat(f.value, \" AS \\\"\").concat(f.alias, \"\\\"\");\n    }\n\n    return f;\n  });\n  let sql = \"SELECT \".concat(selectList.join(','), \" FROM \");\n\n  if (this.only) {\n    sql += 'ONLY ';\n  }\n\n  sql += \"\".concat(this.source, \" WHERE \").concat(this.where.conditions, \" \");\n\n  if (this.pagination) {\n    sql += \"AND \".concat(this.pagination, \" \");\n  }\n\n  sql += \"\".concat(this.order);\n\n  if (this.forUpdate) {\n    sql += ' FOR UPDATE';\n  }\n\n  if (this.forShare) {\n    sql += ' FOR SHARE';\n  }\n\n  if (this.pageLength) {\n    sql += \" FETCH FIRST \".concat(this.pageLength, \" ROWS ONLY\");\n  }\n\n  if (this.offset) {\n    sql += ' OFFSET ' + this.offset;\n  }\n\n  if (this.single) {\n    sql += ' LIMIT 1';\n  } else if (this.limit) {\n    sql += \" LIMIT \".concat(this.limit);\n  }\n\n  return sql;\n};\n\nmodule.exports = Select;","map":null,"metadata":{},"sourceType":"script"}