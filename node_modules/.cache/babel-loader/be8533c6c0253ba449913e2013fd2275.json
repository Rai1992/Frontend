{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst parseKey = require('../util/parse-key');\n\nconst prepareParams = require('../util/prepare-params');\n/**\n * Represents an INSERT query.\n *\n * @class\n * @param {Table} source - Database object to query.\n * @param {Object|Array} record - A map of field names to values to be inserted,\n * or an array of same.\n * @param {Object} [options] - {@link https://massivejs.org/docs/options-objects|Insert options}.\n */\n\n\nconst Insert = function (source, record, options = {}) {\n  this.source = source;\n  this.only = options.only;\n  this.build = options.build;\n  this.decompose = options.decompose;\n  this.document = options.document;\n  this.generator = options.generator;\n  this.stream = options.stream;\n  this.onConflictIgnore = options.onConflictIgnore;\n  this.onConflictUpdate = options.onConflictUpdate;\n  this.onConflictUpdateExcludes = options.onConflictUpdateExcludes;\n  this.deepInsert = Object.prototype.hasOwnProperty.call(options, 'deepInsert') && !!options.deepInsert; // get fields to return from options\n\n  this.fields = options.fields ? options.fields.map(f => parseKey(f).field) : ['*'];\n\n  if (_.isArray(record)) {\n    this.records = record;\n  } else {\n    this.single = true;\n    this.records = [record];\n  }\n\n  const fields = [..._.reduce(this.records, (set, r) => {\n    _.forEach(_.keys(r), set.add.bind(set));\n\n    return set;\n  }, new Set())];\n  this.columns = _.intersection(fields, this.source.columns);\n  this.junctions = _.difference(fields, this.source.columns);\n  const recordParams = prepareParams(this.columns, this.records);\n\n  if (this.deepInsert && this.junctions.length) {\n    // append all junction params (that aren't stubbing out the foreign keys)\n    // to the insert's parameter list\n    // TODO generate junction field set to allow more flexibility between\n    // junction records for the same relationship\n    this.params = _.reduce(this.junctions, (allParams, j) => {\n      const junction = this.records[0][j];\n      const junctionParams = prepareParams(Object.keys(junction[0]), junction);\n      return allParams.concat(junctionParams.filter(v => v !== undefined));\n    }, recordParams);\n  } else {\n    this.params = recordParams;\n  }\n};\n/**\n * Format this object into a SQL INSERT.\n *\n * @return {String} A SQL INSERT statement.\n */\n\n\nInsert.prototype.format = function () {\n  if (this.deepInsert && this.junctions.length && this.records.length > 1) {\n    throw new Error('Found potential deep insert definitions in the record array. Deep insert is only supported for single records. If you are not attempting a deep insert, ensure that your records do not contain non-column keys or use the {deepInsert: false} option.');\n  }\n\n  const quotedColumns = this.columns.map(f => \"\\\"\".concat(f, \"\\\"\"));\n  let sql = \"INSERT INTO \".concat(this.source.delimitedFullName, \" (\").concat(quotedColumns.join(', '), \") VALUES \");\n  let offset = 1;\n  const values = this.records.reduce(acc => {\n    acc.push(_.range(offset, offset + this.columns.length).map(n => \"$\".concat(n)));\n    offset += this.columns.length;\n    return acc;\n  }, []);\n  sql += \"\".concat(values.map(v => '(' + v.join(', ') + ')').join(', '), \" \");\n\n  if (this.onConflictIgnore) {\n    sql += 'ON CONFLICT DO NOTHING ';\n  } else if (this.onConflictUpdate) {\n    const conflictFields = this.onConflictUpdate.map(f => \"\\\"\".concat(f, \"\\\"\"));\n    const excludedFieldsArray = (this.onConflictUpdateExclude || []).concat(this.onConflictUpdate);\n\n    const excludedFields = _.difference(this.columns, excludedFieldsArray).map(f => \"\\\"\".concat(f, \"\\\" = EXCLUDED.\\\"\").concat(f, \"\\\"\"));\n\n    sql += \"ON CONFLICT (\".concat(conflictFields.join(', '), \") DO UPDATE SET \").concat(excludedFields.join(', '), \" \");\n  }\n\n  sql += \"RETURNING \".concat(this.fields.join(', '));\n\n  if (this.deepInsert && this.junctions.length) {\n    const sourcePkList = \"\\\"\".concat(this.source.pk.join('\", \"'), \"\\\"\");\n\n    const junctionQueries = _.reduce(this.junctions, (queries, j, idx) => {\n      if (!Array.isArray(this.records[0][j])) {\n        throw new Error('Attempted a deep insert with a bad junction definition. If you did not intend a deep insert, ensure that your record only contains values for database columns or disable this functionality with the {deepInsert: false} option.');\n      }\n\n      const jTable = j.split('.').map(token => \"\\\"\".concat(token, \"\\\"\")).join('.');\n      return queries.concat(this.records[0][j].map((r, jdx) => {\n        // separate out keyColumns so they are consistently positioned in the\n        // CTE since they won't necessarily be ordered in the source map\n        const keyColumns = [];\n        const valColumns = [];\n\n        _.keys(r).forEach(k => {\n          if (r[k] === undefined) {\n            keyColumns.push(k);\n          } else {\n            valColumns.push(k);\n          }\n        });\n\n        const allQuotedColumns = keyColumns.concat(valColumns).map(k => \"\\\"\".concat(k, \"\\\"\"));\n\n        const rValues = _.range(offset, offset + valColumns.length).map(n => \"$\".concat(n));\n\n        offset += valColumns.length;\n        return \"q_\".concat(idx, \"_\").concat(jdx, \" AS (INSERT INTO \").concat(jTable, \" (\").concat(allQuotedColumns.join(', '), \") SELECT \").concat(sourcePkList, \", \").concat(rValues.join(', '), \" FROM inserted)\");\n      }));\n    }, []);\n\n    sql = \"WITH inserted AS (\".concat(sql, \"), \").concat(junctionQueries.join(', '), \" SELECT * FROM inserted\");\n  }\n\n  return sql;\n};\n\nmodule.exports = Insert;","map":null,"metadata":{},"sourceType":"script"}