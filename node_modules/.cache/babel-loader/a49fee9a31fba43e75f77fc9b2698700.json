{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n'use strict';\n\nconst npm = {\n  assertOptions: require('assert-options'),\n  result: require('./result'),\n  special: require('./special'),\n  Context: require('./cnContext'),\n  events: require('./events'),\n  utils: require('./utils'),\n  pubUtils: require('./utils/public'),\n  connect: require('./connect'),\n  dbPool: require('./dbPool'),\n  query: require('./query'),\n  task: require('./task'),\n  text: require('./text')\n};\n/**\r\n * @class Database\r\n * @description\r\n *\r\n * Represents the database protocol, extensible via event {@link event:extend extend}.\r\n * This type is not available directly, it can only be created via the library's base call.\r\n *\r\n * **IMPORTANT:**\r\n *\r\n * For any given connection, you should only create a single {@link Database} object in a separate module,\r\n * to be shared in your application (see the code example below). If instead you keep creating the {@link Database}\r\n * object dynamically, your application will suffer from loss in performance, and will be getting a warning in a\r\n * development environment (when `NODE_ENV` = `development`):\r\n *\r\n * `WARNING: Creating a duplicate database object for the same connection.`\r\n *\r\n * If you ever see this warning, rectify your {@link Database} object initialization, so there is only one object\r\n * per connection details. See the example provided below.\r\n *\r\n * See also: property `noWarnings` in {@link module:pg-promise Initialization Options}.\r\n *\r\n * Note however, that in special cases you may need to re-create the database object, if its connection pool has been\r\n * shut-down externally. And in this case the library won't be showing any warning.\r\n *\r\n * @param {string|object} cn\r\n * Database connection details, which can be:\r\n *\r\n * - a configuration object\r\n * - a connection string\r\n *\r\n * For details see {@link https://github.com/vitaly-t/pg-promise/wiki/Connection-Syntax Connection Syntax}.\r\n *\r\n * The value can be accessed from the database object via property {@link Database.$cn $cn}.\r\n *\r\n * @param {*} [dc]\r\n * Database Context.\r\n *\r\n * Any object or value to be propagated through the protocol, to allow implementations and event handling\r\n * that depend on the database context.\r\n *\r\n * This is mainly to facilitate the use of multiple databases which may need separate protocol extensions,\r\n * or different implementations within a single task / transaction callback, depending on the database context.\r\n *\r\n * This parameter also adds uniqueness to the connection context that's used in combination with the connection\r\n * parameters, i.e. use of unique database context will prevent getting the warning about creating a duplicate\r\n * Database object.\r\n *\r\n * The value can be accessed from the database object via property {@link Database#$dc $dc}.\r\n *\r\n * @returns {Database}\r\n *\r\n * @see\r\n *\r\n * {@link Database#query query},\r\n * {@link Database#none none},\r\n * {@link Database#one one},\r\n * {@link Database#oneOrNone oneOrNone},\r\n * {@link Database#many many},\r\n * {@link Database#manyOrNone manyOrNone},\r\n * {@link Database#any any},\r\n * {@link Database#func func},\r\n * {@link Database#proc proc},\r\n * {@link Database#result result},\r\n * {@link Database#multiResult multiResult},\r\n * {@link Database#multi multi},\r\n * {@link Database#map map},\r\n * {@link Database#each each},\r\n * {@link Database#stream stream},\r\n * {@link Database#task task},\r\n * {@link Database#taskIf taskIf},\r\n * {@link Database#tx tx},\r\n * {@link Database#txIf txIf},\r\n * {@link Database#connect connect},\r\n * {@link Database#$config $config},\r\n * {@link Database#$cn $cn},\r\n * {@link Database#$dc $dc},\r\n * {@link Database#$pool $pool},\r\n * {@link event:extend extend}\r\n *\r\n * @example\r\n * // Proper way to initialize and share the Database object\r\n *\r\n * // Loading and initializing the library:\r\n * const pgp = require('pg-promise')({\r\n *     // Initialization Options\r\n * });\r\n *\r\n * // Preparing the connection details:\r\n * const cn = 'postgres://username:password@host:port/database';\r\n *\r\n * // Creating a new database instance from the connection details:\r\n * const db = pgp(cn);\r\n *\r\n * // Exporting the database object for shared use:\r\n * module.exports = db;\r\n */\n\nfunction Database(cn, dc, config) {\n  const dbThis = this,\n        $p = config.promise,\n        poolConnection = typeof cn === 'string' ? {\n    connectionString: cn\n  } : cn,\n        pool = new config.pgp.pg.Pool(poolConnection),\n        endMethod = pool.end;\n  let destroyed;\n\n  pool.end = cb => {\n    const res = endMethod.call(pool, cb);\n    dbThis.$destroy();\n    return res;\n  };\n\n  pool.on('error', onError);\n  /**\r\n   * @method Database#connect\r\n   *\r\n   * @description\r\n   * Acquires a new or existing connection, depending on the current state of the connection pool, and parameter `direct`.\r\n   *\r\n   * This method creates a shared connection for executing a chain of queries against it. The connection must be released\r\n   * in the end of the chain by calling method `done()` on the connection object.\r\n   *\r\n   * It should not be used just for chaining queries on the same connection, methods {@link Database#task task} and\r\n   * {@link Database#tx tx} (for transactions) are to be used for that. This method is primarily for special cases, like\r\n   * `LISTEN` notifications.\r\n   *\r\n   * **NOTE:** Even though this method exposes a {@link external:Client Client} object via property `client`,\r\n   * you cannot call `client.end()` directly, or it will print an error into the console:\r\n   * `Abnormal client.end() call, due to invalid code or failed server connection.`\r\n   * You should only call method `done()` to release the connection.\r\n   *\r\n   * @param {object} [options]\r\n   * Connection Options.\r\n   *\r\n   * @param {boolean} [options.direct=false]\r\n   * Creates a new connection directly, as a stand-alone {@link external:Client Client} object, bypassing the connection pool.\r\n   *\r\n   * By default, all connections are acquired from the connection pool. But if you set this option, the library will instead\r\n   * create a new {@link external:Client Client} object directly (separately from the pool), and then call its `connect` method.\r\n   *\r\n   * **WARNING:**\r\n   *\r\n   * Do not use this option for regular query execution, because it exclusively occupies one physical channel, and it cannot scale.\r\n   * This option is only suitable for global connection usage, such as event listeners.\r\n   *\r\n   * @param {function} [options.onLost]\r\n   * Notification callback of the lost/broken connection, called with the following parameters:\r\n   *  - `err` - the original connectivity error\r\n   *  - `e` - error context object, which contains:\r\n   *    - `cn` - safe connection string/config (with the password hashed);\r\n   *    - `dc` - Database Context, as was used during {@link Database} construction;\r\n   *    - `start` - Date/Time (`Date` type) when the connection was established;\r\n   *    - `client` - {@link external:Client Client} object that has lost the connection.\r\n   *\r\n   * The notification is mostly valuable with `direct: true`, to be able to re-connect direct/permanent connections by calling\r\n   * method {@link Database#connect connect} again.\r\n   *\r\n   * You do not need to call `done` on lost connections, as it happens automatically. However, if you had event listeners\r\n   * set up on the connection's `client` object, you should remove them to avoid leaks:\r\n   *\r\n   * ```js\r\n   * function onLostConnection(err, e) {\r\n   *     e.client.removeListener('my-event', myHandler);\r\n   * }\r\n   * ```\r\n   *\r\n   * For a complete example see $[Robust Listeners].\r\n   *\r\n   * @returns {external:Promise}\r\n   * A promise object that represents the connection result:\r\n   *  - resolves with the complete {@link Database} protocol, extended with:\r\n   *    - property `client` of type {@link external:Client Client} that represents the open connection\r\n   *    - method `done()` that must be called in the end, in order to release the connection\r\n   *    - methods `batch`, `page` and `sequence`, same as inside a {@link Task}\r\n   *  - rejects with a connection-related error when it fails to connect.\r\n   *\r\n   * @see\r\n   * {@link Database#task Database.task},\r\n   * {@link Database#taskIf Database.taskIf},\r\n   * {@link Database#tx Database.tx},\r\n   * {@link Database#txIf Database.txIf}\r\n   *\r\n   * @example\r\n   *\r\n   * let sco; // shared connection object;\r\n   *\r\n   * db.connect()\r\n   *     .then(obj => {\r\n   *         // obj.client = new connected Client object;\r\n   *\r\n   *         sco = obj; // save the connection object;\r\n   *\r\n   *         // execute all the queries you need:\r\n   *         return sco.any('SELECT * FROM Users');\r\n   *     })\r\n   *     .then(data => {\r\n   *         // success\r\n   *     })\r\n   *     .catch(error => {\r\n   *         // error\r\n   *     })\r\n   *     .finally(() => {\r\n   *         // release the connection, if it was successful:\r\n   *         if (sco) {\r\n   *             sco.done();\r\n   *         }\r\n   *     });\r\n   *\r\n   */\n\n  this.connect = function (options) {\n    options = options || {};\n    const ctx = createContext();\n    ctx.cnOptions = options;\n    const self = {\n      // Generic query method:\n      query(query, values, qrm) {\n        if (!ctx.db) {\n          return $p.reject(new Error(npm.text.queryDisconnected));\n        }\n\n        return config.$npm.query.call(this, ctx, query, values, qrm);\n      },\n\n      // Connection release method:\n      done() {\n        if (!ctx.db) {\n          throw new Error(npm.text.looseQuery);\n        }\n\n        ctx.disconnect();\n      },\n\n      batch(values, opt) {\n        return config.$npm.spex.batch.call(this, values, opt);\n      },\n\n      page(source, opt) {\n        return config.$npm.spex.page.call(this, source, opt);\n      },\n\n      sequence(source, opt) {\n        return config.$npm.spex.sequence.call(this, source, opt);\n      }\n\n    };\n    const connection = options.direct ? config.$npm.connect.direct(ctx) : config.$npm.connect.pool(ctx, dbThis);\n    return connection.then(db => {\n      ctx.connect(db);\n      self.client = db.client;\n      extend(ctx, self);\n      return self;\n    });\n  };\n  /**\r\n   * @method Database#query\r\n   *\r\n   * @description\r\n   * Base query method that executes a generic query, expecting the return data according to parameter `qrm`.\r\n   *\r\n   * It performs the following steps:\r\n   *\r\n   *  1. Validates and formats the query via {@link formatting.format as.format}, according to the `query` and `values` passed in;\r\n   *  2. For a root-level query (against the {@link Database} object), it requests a new connection from the pool;\r\n   *  3. Executes the query;\r\n   *  4. For a root-level query (against the {@link Database} object), it releases the connection back to the pool;\r\n   *  5. Resolves/rejects, according to the data returned from the query and the value of `qrm`.\r\n   *\r\n   * Direct use of this method is not suitable for chaining queries, for performance reasons. It should be done\r\n   * through either task or transaction context, see $[Chaining Queries].\r\n   *\r\n   * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n   *\r\n   * @param {string|function|object} query\r\n   * Query to be executed, which can be any of the following types:\r\n   * - A non-empty query string\r\n   * - A function that returns a query string or another function, i.e. recursive resolution\r\n   *   is supported, passing in `values` as `this`, and as the first parameter.\r\n   * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n   * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n   * - {@link QueryFile} object\r\n   *\r\n   * @param {array|value} [values]\r\n   * Query formatting parameters.\r\n   *\r\n   * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n   * - a single value - to replace all `$1` occurrences\r\n   * - an array of values - to replace all `$1`, `$2`, ... variables\r\n   * - an object - to apply $[Named Parameters] formatting\r\n   *\r\n   * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n   * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n   * as an override for its internal `values`.\r\n   *\r\n   * @param {queryResult} [qrm=queryResult.any]\r\n   * {@link queryResult Query Result Mask}\r\n   *\r\n   * @returns {external:Promise}\r\n   * A promise object that represents the query result according to `qrm`.\r\n   */\n\n\n  this.query = function (query, values, qrm) {\n    const self = this,\n          ctx = createContext();\n    return config.$npm.connect.pool(ctx, dbThis).then(db => {\n      ctx.connect(db);\n      return config.$npm.query.call(self, ctx, query, values, qrm);\n    }).then(data => {\n      ctx.disconnect();\n      return data;\n    }).catch(error => {\n      ctx.disconnect();\n      return $p.reject(error);\n    });\n  };\n  /**\r\n   * @member {object} Database#$config\r\n   * @readonly\r\n   * @description\r\n   * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n   *\r\n   * Properties available in the object:\r\n   * - `pgp` - instance of the entire library after initialization\r\n   * - `options` - the library's {@link module:pg-promise Initialization Options} object\r\n   * - `promiseLib` - instance of the promise library that's used\r\n   * - `promise` - generic promise interface that uses `promiseLib` via 4 basic methods:\r\n   *   - `promise((resolve, reject) => {})` - to create a new promise\r\n   *   - `promise.resolve(value)` - to resolve with a value\r\n   *   - `promise.reject(reason)` - to reject with a reason\r\n   *   - `promise.all(iterable)` - to resolve an iterable list of promises\r\n   * - `version` - this library's version\r\n   * - `$npm` _(hidden property)_ - internal module cache\r\n   *\r\n   * @example\r\n   *\r\n   * // Using the promise protocol as configured by pg-promise:\r\n   *\r\n   * const $p = db.$config.promise;\r\n   *\r\n   * const resolvedPromise = $p.resolve('some data');\r\n   * const rejectedPromise = $p.reject('some reason');\r\n   *\r\n   * const newPromise = $p((resolve, reject) => {\r\n   *     // call either resolve(data) or reject(reason) here\r\n   * });\r\n   */\n\n\n  npm.utils.addReadProp(this, '$config', config, true);\n  /**\r\n   * @member {string|object} Database#$cn\r\n   * @readonly\r\n   * @description\r\n   * Database connection, as was passed in during the object's construction.\r\n   *\r\n   * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n   *\r\n   * @see Database\r\n   */\n\n  npm.utils.addReadProp(this, '$cn', cn, true);\n  /**\r\n   * @member {*} Database#$dc\r\n   * @readonly\r\n   * @description\r\n   * Database Context, as was passed in during the object's construction.\r\n   *\r\n   * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n   *\r\n   * @see Database\r\n   */\n\n  npm.utils.addReadProp(this, '$dc', dc, true);\n  /**\r\n   * @member {external:pg-pool} Database#$pool\r\n   * @readonly\r\n   * @description\r\n   * A $[pg-pool] object associated with the database object, as each {@link Database} creates its own $[pg-pool] instance.\r\n   *\r\n   * This is a hidden property, primarily for integrating type {@link Database} with third-party libraries that support\r\n   * $[pg-pool] directly. Note however, that if you pass the pool object into a library that calls `pool.end()`, you will no longer be able\r\n   * to use this {@link Database} object, and each query method will be rejecting with {@link external:Error Error} =\r\n   * `Connection pool of the database object has been destroyed.`\r\n   *\r\n   * You can also use this object to shut down the pool, by calling `$pool.end()`.\r\n   *\r\n   * For more details see $[Library de-initialization].\r\n   *\r\n   * @see\r\n   * {@link Database}\r\n   * {@link module:pg-promise~end pgp.end}\r\n   *\r\n   * @example\r\n   *\r\n   * // Shutting down the connection pool of this database object,\r\n   * // after all queries have finished in a run-though process:\r\n   *\r\n   * .then(() => {}) // processing the data\r\n   * .catch() => {}) // handling the error\r\n   * .finally(db.$pool.end); // shutting down the pool\r\n   *\r\n   */\n\n  npm.utils.addReadProp(this, '$pool', pool, true);\n  /**\r\n   * @member {function} Database.$destroy\r\n   * @readonly\r\n   * @private\r\n   * @description\r\n   * Permanently shuts down the database object.\r\n   */\n\n  npm.utils.addReadProp(this, '$destroy', () => {\n    if (!destroyed) {\n      if (!pool.ending) {\n        endMethod.call(pool);\n      }\n\n      npm.dbPool.unregister(dbThis);\n      pool.removeListener('error', onError);\n      destroyed = true;\n    }\n  }, true);\n  npm.dbPool.register(this);\n  extend(createContext(), this); // extending root protocol;\n\n  function createContext() {\n    return new npm.Context({\n      cn,\n      dc,\n      options: config.options\n    });\n  }\n\n  function transform(value, cb, thisArg) {\n    if (typeof cb === 'function') {\n      value = value.then(data => {\n        return cb.call(thisArg, data);\n      });\n    }\n\n    return value;\n  } ////////////////////////////////////////////////////\n  // Injects additional methods into an access object,\n  // extending the protocol's base method 'query'.\n\n\n  function extend(ctx, obj) {\n    /**\r\n     * @method Database#none\r\n     * @description\r\n     * Executes a query that expects no data to be returned. If the query returns any kind of data,\r\n     * the method rejects.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value} [values]\r\n     * Query formatting parameters.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise<null>}\r\n     * A promise object that represents the query result:\r\n     * - When no records are returned, it resolves with `null`.\r\n     * - When any data is returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n     *   - `.message` = `No return data was expected.`\r\n     *   - `.code` = {@link errors.queryResultErrorCode.notEmpty queryResultErrorCode.notEmpty}\r\n     */\n    obj.none = function (query, values) {\n      return obj.query.call(this, query, values, npm.result.none);\n    };\n    /**\r\n     * @method Database#one\r\n     * @description\r\n     * Executes a query that expects exactly one row of data. When 0 or more than 1 rows are returned,\r\n     * the method rejects.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value} [values]\r\n     * Query formatting parameters.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {function} [cb]\r\n     * Value transformation callback, to allow in-line value change.\r\n     * When specified, the return value replaces the original resolved value.\r\n     *\r\n     * The function takes only one parameter - value resolved from the query.\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the transformation callback.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the query result:\r\n     * - When 1 row is returned, it resolves with that row as a single object.\r\n     * - When no rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n     *   - `.message` = `No data returned from the query.`\r\n     *   - `.code` = {@link errors.queryResultErrorCode.noData queryResultErrorCode.noData}\r\n     * - When multiple rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n     *   - `.message` = `Multiple rows were not expected.`\r\n     *   - `.code` = {@link errors.queryResultErrorCode.multiple queryResultErrorCode.multiple}\r\n     * - Resolves with the new value, if transformation callback `cb` was specified.\r\n     *\r\n     * @see\r\n     * {@link Database#oneOrNone oneOrNone}\r\n     *\r\n     * @example\r\n     *\r\n     * // a query with in-line value transformation:\r\n     * db.one('INSERT INTO Events VALUES($1) RETURNING id', [123], event => event.id)\r\n     *     .then(data => {\r\n     *         // data = a new event id, rather than an object with it\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * // a query with in-line value transformation + conversion:\r\n     * db.one('SELECT count(*) FROM Users', [], c => +c.count)\r\n     *     .then(count => {\r\n     *         // count = a proper integer value, rather than an object with a string\r\n     *     });\r\n     *\r\n     */\n\n\n    obj.one = function (query, values, cb, thisArg) {\n      const v = obj.query.call(this, query, values, npm.result.one);\n      return transform(v, cb, thisArg);\n    };\n    /**\r\n     * @method Database#many\r\n     * @description\r\n     * Executes a query that expects one or more rows. When the query returns no rows, the method rejects.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value} [values]\r\n     * Query formatting parameters.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the query result:\r\n     * - When 1 or more rows are returned, it resolves with the array of rows.\r\n     * - When no rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n     *   - `.message` = `No data returned from the query.`\r\n     *   - `.code` = {@link errors.queryResultErrorCode.noData queryResultErrorCode.noData}\r\n     */\n\n\n    obj.many = function (query, values) {\n      return obj.query.call(this, query, values, npm.result.many);\n    };\n    /**\r\n     * @method Database#oneOrNone\r\n     * @description\r\n     * Executes a query that expects 0 or 1 rows, to resolve with the row-object when 1 row is returned,\r\n     * and with `null` when nothing is returned. When the query returns more than 1 row, the method rejects.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value} [values]\r\n     * Query formatting parameters.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {function} [cb]\r\n     * Value transformation callback, to allow in-line value change.\r\n     * When specified, the return value replaces the original resolved value.\r\n     *\r\n     * The function takes only one parameter - value resolved from the query.\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the transformation callback.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the query result:\r\n     * - When no rows are returned, it resolves with `null`.\r\n     * - When 1 row is returned, it resolves with that row as a single object.\r\n     * - When multiple rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n     *   - `.message` = `Multiple rows were not expected.`\r\n     *   - `.code` = {@link errors.queryResultErrorCode.multiple queryResultErrorCode.multiple}\r\n     * - Resolves with the new value, if transformation callback `cb` was specified.\r\n     *\r\n     * @see\r\n     * {@link Database#one one},\r\n     * {@link Database#none none},\r\n     * {@link Database#manyOrNone manyOrNone}\r\n     *\r\n     * @example\r\n     *\r\n     * // a query with in-line value transformation:\r\n     * db.oneOrNone('SELECT id FROM Events WHERE type = $1', ['entry'], e => e && e.id)\r\n     *     .then(data => {\r\n     *         // data = the event id or null (rather than object or null)\r\n     *     });\r\n     *\r\n     */\n\n\n    obj.oneOrNone = function (query, values, cb, thisArg) {\n      const v = obj.query.call(this, query, values, npm.result.one | npm.result.none);\n      return transform(v, cb, thisArg);\n    };\n    /**\r\n     * @method Database#manyOrNone\r\n     * @description\r\n     * Executes a query that expects any number of rows.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value} [values]\r\n     * Query formatting parameters.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise<Array>}\r\n     * A promise object that represents the query result:\r\n     * - When no rows are returned, it resolves with an empty array.\r\n     * - When 1 or more rows are returned, it resolves with the array of rows.\r\n     *\r\n     * @see\r\n     * {@link Database#any any},\r\n     * {@link Database#many many},\r\n     * {@link Database#none none}\r\n     *\r\n     */\n\n\n    obj.manyOrNone = function (query, values) {\n      return obj.query.call(this, query, values, npm.result.many | npm.result.none);\n    };\n    /**\r\n     * @method Database#any\r\n     * @description\r\n     * Executes a query that expects any number of rows.\r\n     * This is simply a shorter alias for method {@link Database#manyOrNone manyOrNone}.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value} [values]\r\n     * Query formatting parameters.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise<Array>}\r\n     * A promise object that represents the query result:\r\n     * - When no rows are returned, it resolves with an empty array.\r\n     * - When 1 or more rows are returned, it resolves with the array of rows.\r\n     *\r\n     * @see\r\n     * {@link Database#manyOrNone manyOrNone},\r\n     * {@link Database#map map},\r\n     * {@link Database#each each}\r\n     *\r\n     */\n\n\n    obj.any = function (query, values) {\n      return obj.query.call(this, query, values, npm.result.any);\n    };\n    /**\r\n     * @method Database#result\r\n     * @description\r\n     * Executes a query without any expectation for the return data, to resolve with the\r\n     * original $[Result] object when successful.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value} [values]\r\n     * Query formatting parameters.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {function} [cb]\r\n     * Value transformation callback, to allow in-line value change.\r\n     * When specified, the return value replaces the original resolved value.\r\n     *\r\n     * The function takes only one parameter - value resolved from the query.\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the transformation callback.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the query result:\r\n     * - resolves with the original $[Result] object (by default);\r\n     * - resolves with the new value, if transformation callback `cb` was specified.\r\n     *\r\n     * @example\r\n     *\r\n     * // use of value transformation:\r\n     * // deleting rows and returning the number of rows deleted\r\n     * db.result('DELETE FROM Events WHERE id = $1', [123], r => r.rowCount)\r\n     *     .then(data => {\r\n     *         // data = number of rows that were deleted\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * // use of value transformation:\r\n     * // getting only column details from a table\r\n     * db.result('SELECT * FROM Users LIMIT 0', null, r => r.fields)\r\n     *     .then(data => {\r\n     *         // data = array of column descriptors\r\n     *     });\r\n     *\r\n     */\n\n\n    obj.result = function (query, values, cb, thisArg) {\n      const v = obj.query.call(this, query, values, npm.special.cache.resultQuery);\n      return transform(v, cb, thisArg);\n    };\n    /**\r\n     * @method Database#multiResult\r\n     * @description\r\n     * Executes a multi-query string, without any expectation for the return data, to resolve with an array\r\n     * of the original $[Result] objects when successful.\r\n     *\r\n     * The operation is atomic, i.e. all queries are executed in a single transaction, unless there are explicit\r\n     * `BEGIN/COMMIT` commands included in the query string to divide it into multiple transactions.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Multi-query string to be executed, which can be any of the following types:\r\n     * - A non-empty string that can contain any number of queries\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value} [values]\r\n     * Query formatting parameters.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise<external:Result[]>}\r\n     *\r\n     * @see {@link Database#multi multi}\r\n     *\r\n     */\n\n\n    obj.multiResult = function (query, values) {\n      return obj.query.call(this, query, values, npm.special.cache.multiResultQuery);\n    };\n    /**\r\n     * @method Database#multi\r\n     * @description\r\n     * Executes a multi-query string without any expectation for the return data, to resolve with an array\r\n     * of arrays of rows when successful.\r\n     *\r\n     * The operation is atomic, i.e. all queries are executed in a single transaction, unless there are explicit\r\n     * `BEGIN/COMMIT` commands included in the query string to divide it into multiple transactions.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Multi-query string to be executed, which can be any of the following types:\r\n     * - A non-empty string that can contain any number of queries\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value} [values]\r\n     * Query formatting parameters.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise<Array<Array>>}\r\n     *\r\n     * @see {@link Database#multiResult multiResult}\r\n     *\r\n     * @example\r\n     *\r\n     * db.multi('SELECT * FROM users;SELECT * FROM products')\r\n     *    .then(([users, products]) => {\r\n     *        // we get data from all queries at once\r\n     *    })\r\n     *    .catch(error => {\r\n     *        // error\r\n     *    });\r\n     */\n\n\n    obj.multi = function (query, values) {\n      return obj.query.call(this, query, values, npm.special.cache.multiResultQuery).then(data => data.map(a => a.rows));\n    };\n    /**\r\n     * @method Database#stream\r\n     * @description\r\n     * Custom data streaming, with the help of $[pg-query-stream].\r\n     *\r\n     * This method doesn't work with the $[Native Bindings], and if option `pgNative`\r\n     * is set, it will reject with `Streaming doesn't work with Native Bindings.`\r\n     *\r\n     * @param {QueryStream} qs\r\n     * Stream object of type $[QueryStream].\r\n     *\r\n     * @param {Database.streamInitCB} initCB\r\n     * Stream initialization callback.\r\n     *\r\n     * It is invoked with the same `this` context as the calling method.\r\n     *\r\n     * @returns {external:Promise}\r\n     * Result of the streaming operation.\r\n     *\r\n     * Once the streaming has finished successfully, the method resolves with\r\n     * `{processed, duration}`:\r\n     * - `processed` - total number of rows processed;\r\n     * - `duration` - streaming duration, in milliseconds.\r\n     *\r\n     * Possible rejections messages:\r\n     * - `Invalid or missing stream object.`\r\n     * - `Invalid stream state.`\r\n     * - `Invalid or missing stream initialization callback.`\r\n     */\n\n\n    obj.stream = function (qs, init) {\n      return obj.query.call(this, qs, init, npm.special.cache.streamQuery);\n    };\n    /**\r\n     * @method Database#func\r\n     * @description\r\n     * Executes a query against a database function by its name: `SELECT * FROM funcName(values)`.\r\n     *\r\n     * @param {string} funcName\r\n     * Name of the function to be executed.\r\n     *\r\n     * @param {array|value} [values]\r\n     * Parameters for the function - one value or an array of values.\r\n     *\r\n     * @param {queryResult} [qrm=queryResult.any] - {@link queryResult Query Result Mask}.\r\n     *\r\n     * @returns {external:Promise}\r\n     *\r\n     * A promise object as returned from method {@link Database#query query}, according to parameter `qrm`.\r\n     *\r\n     * @see\r\n     * {@link Database#query query},\r\n     * {@link Database#proc proc}\r\n     */\n\n\n    obj.func = function (funcName, values, qrm) {\n      return obj.query.call(this, {\n        funcName\n      }, values, qrm);\n    };\n    /**\r\n     * @method Database#proc\r\n     * @description\r\n     * Executes a query against a stored procedure via its name: `SELECT * FROM procName(values)`,\r\n     * expecting back 0 or 1 rows. It resolves either with the resulting row-object, or with\r\n     * `null` when none returned.\r\n     *\r\n     * The method simply forwards into {@link Database#func func}`(procName, values, queryResult.one|queryResult.none)`.\r\n     *\r\n     * @param {string} procName\r\n     * Name of the stored procedure to be executed.\r\n     *\r\n     * @param {array|value} [values]\r\n     * Parameters for the procedure - one value or an array of values.\r\n     *\r\n     * @param {function} [cb]\r\n     * Value transformation callback, to allow in-line value change.\r\n     * When specified, the return value replaces the original resolved value.\r\n     *\r\n     * The function takes only one parameter - value resolved from the query.\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the transformation callback.\r\n     *\r\n     * @returns {external:Promise}\r\n     *\r\n     * It calls {@link Database#func func}(`procName`, `values`, `queryResult.one|queryResult.none`),\r\n     * and then returns the same result as method {@link Database#oneOrNone oneOrNone}.\r\n     *\r\n     * And if transformation callback `cb` was specified, it resolves with the new value.\r\n     *\r\n     * @see\r\n     * {@link Database#oneOrNone oneOrNone},\r\n     * {@link Database#func func}\r\n     */\n\n\n    obj.proc = function (procName, values, cb, thisArg) {\n      const v = obj.func.call(this, procName, values, npm.result.one | npm.result.none);\n      return transform(v, cb, thisArg);\n    };\n    /**\r\n     * @method Database#map\r\n     * @description\r\n     * Creates a new array with the results of calling a provided function on every element in the array of rows\r\n     * resolved by method {@link Database#any any}.\r\n     *\r\n     * It is a convenience method to reduce the following code:\r\n     *\r\n     * ```js\r\n     * db.any(query, values)\r\n     *     .then(data => {\r\n     *         return data.map((row, index, data) => {\r\n     *              // return a new element\r\n     *         });\r\n     *     });\r\n     * ```\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value} values\r\n     * Query formatting parameters.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {function} cb\r\n     * Function that produces an element of the new array, taking three arguments:\r\n     * - `row` - the current row object being processed in the array\r\n     * - `index` - the index of the current row being processed in the array\r\n     * - `data` - the original array of rows resolved by method {@link Database#any any}\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the callback.\r\n     *\r\n     * @returns {external:Promise<Array>}\r\n     * Resolves with the new array of values returned from the callback.\r\n     *\r\n     * @see\r\n     * {@link Database#any any},\r\n     * {@link Database#each each},\r\n     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map Array.map}\r\n     *\r\n     * @example\r\n     *\r\n     * db.map('SELECT id FROM Users WHERE status = $1', ['active'], row => row.id)\r\n     *     .then(data => {\r\n     *         // data = array of active user id-s\r\n     *     })\r\n     *     .catch(error => {\r\n     *        // error\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * db.tx(t => {\r\n     *     return t.map('SELECT id FROM Users WHERE status = $1', ['active'], row => {\r\n     *        return t.none('UPDATE Events SET checked = $1 WHERE userId = $2', [true, row.id]);\r\n     *     }).then(t.batch);\r\n     * })\r\n     *     .then(data => {\r\n     *         // success\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * // Build a list of active users, each with the list of user events:\r\n     * db.task(t => {\r\n     *     return t.map('SELECT id FROM Users WHERE status = $1', ['active'], user => {\r\n     *         return t.any('SELECT * FROM Events WHERE userId = $1', user.id)\r\n     *             .then(events=> {\r\n     *                 user.events = events;\r\n     *                 return user;\r\n     *             });\r\n     *     }).then(t.batch);\r\n     * })\r\n     *     .then(data => {\r\n     *         // success\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     */\n\n\n    obj.map = function (query, values, cb, thisArg) {\n      return obj.any.call(this, query, values).then(data => data.map(cb, thisArg));\n    };\n    /**\r\n     * @method Database#each\r\n     * @description\r\n     * Executes a provided function once per array element, for an array of rows resolved by method {@link Database#any any}.\r\n     *\r\n     * It is a convenience method to reduce the following code:\r\n     *\r\n     * ```js\r\n     * db.any(query, values)\r\n     *     .then(data => {\r\n     *         data.forEach((row, index, data) => {\r\n     *              // process the row\r\n     *         });\r\n     *         return data;\r\n     *     });\r\n     * ```\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value} [values]\r\n     * Query formatting parameters.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {function} cb\r\n     * Function to execute for each row, taking three arguments:\r\n     * - `row` - the current row object being processed in the array\r\n     * - `index` - the index of the current row being processed in the array\r\n     * - `data` - the array of rows resolved by method {@link Database#any any}\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the callback.\r\n     *\r\n     * @returns {external:Promise<Array<Object>>}\r\n     * Resolves with the original array of rows.\r\n     *\r\n     * @see\r\n     * {@link Database#any any},\r\n     * {@link Database#map map},\r\n     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach Array.forEach}\r\n     *\r\n     * @example\r\n     *\r\n     * db.each('SELECT id, code, name FROM Events', [], row => {\r\n     *     row.code = parseInt(row.code);\r\n     * })\r\n     *     .then(data => {\r\n     *         // data = array of events, with 'code' converted into integer\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     */\n\n\n    obj.each = function (query, values, cb, thisArg) {\n      return obj.any.call(this, query, values).then(data => {\n        data.forEach(cb, thisArg);\n        return data;\n      });\n    };\n    /**\r\n     * @method Database#task\r\n     * @description\r\n     * Executes a callback function with automatically managed connection.\r\n     *\r\n     * When invoked on the root {@link Database} object, the method allocates the connection from the pool,\r\n     * executes the callback, and once finished - releases the connection back to the pool.\r\n     * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n     *\r\n     * This method should be used whenever executing more than one query at once, so the allocated connection\r\n     * is reused between all queries, and released only after the task has finished (see $[Chaining Queries]).\r\n     *\r\n     * The callback function is called with one parameter - database protocol (same as `this`), extended with methods\r\n     * {@link Task#batch batch}, {@link Task#page page}, {@link Task#sequence sequence}, plus property {@link Task#ctx ctx} -\r\n     * the task context object. See class {@link Task} for more details.\r\n     *\r\n     * @param {string|number|Object} [options]\r\n     * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n     *\r\n     * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n     * it is expected to be an object with options as listed below.\r\n     *\r\n     * @param {} [options.tag]\r\n     * Traceable context for the task (see $[tags]).\r\n     *\r\n     * @param {function|generator} cb\r\n     * Task callback function, to return the result that will determine either success or failure for the operation.\r\n     *\r\n     * The function can be either the first of the second parameter passed into the method.\r\n     *\r\n     * It also can be an $[ES6 generator] or an ES7 `async` function.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object with the result from the callback function.\r\n     *\r\n     * @see\r\n     * {@link Task},\r\n     * {@link Database#taskIf taskIf},\r\n     * {@link Database#tx tx},\r\n     * $[tags],\r\n     * $[Chaining Queries]\r\n     *\r\n     * @example\r\n     *\r\n     * db.task('my-task', t => {\r\n     *         // t.ctx = task context object\r\n     *\r\n     *         return t.one('SELECT id FROM Users WHERE name = $1', 'John')\r\n     *             .then(user => {\r\n     *                 return t.any('SELECT * FROM Events WHERE userId = $1', user.id);\r\n     *             });\r\n     *     })\r\n     *     .then(data => {\r\n     *         // success\r\n     *         // data = as returned from the task's callback\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * // using an ES6 generator for the callback:\r\n     * db.task('my-task', function * (t) {\r\n     *         // t.ctx = task context object\r\n     *\r\n     *         const user = yield t.one('SELECT id FROM Users WHERE name = $1', 'John');\r\n     *         return yield t.any('SELECT * FROM Events WHERE userId = $1', user.id);\r\n     *     })\r\n     *     .then(data => {\r\n     *         // success\r\n     *         // data = as returned from the task's callback\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     */\n\n\n    obj.task = function () {\n      const args = npm.pubUtils.taskArgs(arguments);\n      npm.assertOptions(args.options, ['tag']);\n      return taskProcessor.call(this, args, false);\n    };\n    /**\r\n     * @method Database#taskIf\r\n     * @description\r\n     * Executes a conditional task that results in an actual new {@link Database#task task}, if either condition is met or\r\n     * when it is necessary (on the top level), or else it reuses the current connection context.\r\n     *\r\n     * The default condition is `not in task or transaction`, to start a task only if currently not inside another task or transaction,\r\n     * which is the same as calling the following:\r\n     *\r\n     * ```js\r\n     * db.taskIf({cnd: t => !t.ctx}, cb => {})\r\n     * ```\r\n     *\r\n     * It can be useful, if you want to simplify/reduce the task + log events footprint, by creating new tasks only when necessary.\r\n     *\r\n     * @param {string|number|Object} [options]\r\n     * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n     *\r\n     * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n     * it is expected to be an object with options as listed below.\r\n     *\r\n     * @param {} [options.tag]\r\n     * Traceable context for the task/transaction (see $[tags]).\r\n     *\r\n     * @param {boolean|function} [options.cnd]\r\n     * Condition for creating a ({@link Database#task task}), if it is met.\r\n     * It can be either a simple boolean, or a callback function that takes the task context as `this` and as the first parameter.\r\n     *\r\n     * Default condition (when it is not specified):\r\n     *\r\n     * ```js\r\n     * {cnd: t => !t.ctx}\r\n     * ```\r\n     *\r\n     * @param {function|generator} cb\r\n     * Task callback function, to return the result that will determine either success or failure for the operation.\r\n     *\r\n     * The function can be either the first or the second parameter passed into the method.\r\n     *\r\n     * It also can be an $[ES6 generator] or an ES7 `async` function.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object with the result from the callback function.\r\n     *\r\n     * @see\r\n     * {@link Task},\r\n     * {@link Database#task Database.task},\r\n     * {@link Database#tx Database.tx},\r\n     * {@link Database#txIf Database.txIf},\r\n     * {@link TaskContext}\r\n     *\r\n     */\n\n\n    obj.taskIf = function () {\n      const args = npm.pubUtils.taskArgs(arguments);\n      npm.assertOptions(args.options, ['tag', 'cnd']);\n\n      try {\n        let cnd = args.options.cnd;\n\n        if ('cnd' in args.options) {\n          cnd = typeof cnd === 'function' ? cnd.call(obj, obj) : !!cnd;\n        } else {\n          cnd = !obj.ctx; // create task, if it is the top level\n        } // reusable only if condition fails, and not top-level:\n\n\n        args.options.reusable = !cnd && !!obj.ctx;\n      } catch (e) {\n        return $p.reject(e);\n      }\n\n      return taskProcessor.call(this, args, false);\n    };\n    /**\r\n     * @method Database#tx\r\n     * @description\r\n     * Executes a callback function as a transaction, with automatically managed connection.\r\n     *\r\n     * When invoked on the root {@link Database} object, the method allocates the connection from the pool,\r\n     * executes the callback, and once finished - releases the connection back to the pool.\r\n     * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n     *\r\n     * A transaction wraps a regular {@link Database#task task} into additional queries:\r\n     * - it executes `BEGIN` just before invoking the callback function\r\n     * - it executes `COMMIT`, if the callback didn't throw any error or return a rejected promise\r\n     * - it executes `ROLLBACK`, if the callback did throw an error or return a rejected promise\r\n     * - it executes corresponding `SAVEPOINT` commands when the method is called recursively.\r\n     *\r\n     * The callback function is called with one parameter - database protocol (same as `this`), extended with methods\r\n     * {@link Task#batch batch}, {@link Task#page page}, {@link Task#sequence sequence}, plus property {@link Task#ctx ctx} -\r\n     * the transaction context object. See class {@link Task} for more details.\r\n     *\r\n     * Note that transactions should be chosen over tasks only where necessary, because unlike regular tasks,\r\n     * transactions are blocking operations, and must be used with caution.\r\n     *\r\n     * @param {string|number|Object} [options]\r\n     * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n     *\r\n     * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n     * it is expected to be an object with options as listed below.\r\n     *\r\n     * @param {} [options.tag]\r\n     * Traceable context for the transaction (see $[tags]).\r\n     *\r\n     * @param {txMode.TransactionMode} [options.mode]\r\n     * Transaction Configuration Mode - extends the transaction-opening command with additional configuration.\r\n     *\r\n     * @param {function|generator} cb\r\n     * Transaction callback function, to return the result that will determine either success or failure for the operation.\r\n     *\r\n     * The function can be either the first of the second parameter passed into the method.\r\n     *\r\n     * It also can be an $[ES6 generator] or an ES7 `async` function.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object with the result from the callback function.\r\n     *\r\n     * @see\r\n     * {@link Task},\r\n     * {@link Database#task Database.task},\r\n     * {@link Database#taskIf Database.taskIf},\r\n     * {@link TaskContext},\r\n     * $[tags],\r\n     * $[Chaining Queries]\r\n     *\r\n     * @example\r\n     *\r\n     * db.tx('my-transaction', t => {\r\n     *         // t.ctx = transaction context object\r\n     *\r\n     *         return t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25])\r\n     *             .then(user => {\r\n     *                 return t.batch([\r\n     *                     t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']),\r\n     *                     t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'login'])\r\n     *                 ]);\r\n     *             });\r\n     *     })\r\n     *     .then(data => {\r\n     *         // success\r\n     *         // data = as returned from the transaction's callback\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * // using an ES6 generator for the callback:\r\n     * db.tx('my-transaction', function * (t) {\r\n     *         // t.ctx = transaction context object\r\n     *\r\n     *         const user = yield t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25]);\r\n     *         return yield t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']);\r\n     *     })\r\n     *     .then(data => {\r\n     *         // success\r\n     *         // data = as returned from the transaction's callback\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     */\n\n\n    obj.tx = function () {\n      const args = npm.pubUtils.taskArgs(arguments);\n      npm.assertOptions(args.options, ['tag', 'mode']);\n      return taskProcessor.call(this, args, true);\n    };\n    /**\r\n     * @method Database#txIf\r\n     * @description\r\n     * Executes a conditional transaction that results in an actual transaction ({@link Database#tx tx}), if the condition is met,\r\n     * or else it executes a regular {@link Database#task task}.\r\n     *\r\n     * The default condition is `not in transaction`, to start a transaction only if currently not in transaction,\r\n     * or else start a task, which is the same as calling the following:\r\n     *\r\n     * ```js\r\n     * db.txIf({cnd: t => !t.ctx || !t.ctx.inTransaction}, cb => {})\r\n     * ```\r\n     *\r\n     * It is useful when you want to avoid $[Nested Transactions] - savepoints.\r\n     *\r\n     * @param {string|number|Object} [options]\r\n     * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n     *\r\n     * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n     * it is expected to be an object with options as listed below.\r\n     *\r\n     * @param {} [options.tag]\r\n     * Traceable context for the task/transaction (see $[tags]).\r\n     *\r\n     * @param {txMode.TransactionMode} [options.mode]\r\n     * Transaction Configuration Mode - extends the transaction-opening command with additional configuration.\r\n     *\r\n     * @param {boolean|function} [options.cnd]\r\n     * Condition for opening a transaction ({@link Database#tx tx}), if it is met, or a {@link Database#task task} when the condition is not met.\r\n     * It can be either a simple boolean, or a callback function that takes the task/tx context as `this` and as the first parameter.\r\n     *\r\n     * Default condition (when it is not specified):\r\n     *\r\n     * ```js\r\n     * {cnd: t => !t.ctx || !t.ctx.inTransaction}\r\n     * ```\r\n     *\r\n     * @param {boolean|function} [options.reusable=false]\r\n     * When `cnd` is/returns false, reuse context of the current task/transaction, if one exists.\r\n     * It can be either a simple boolean, or a callback function that takes the task/tx context as `this`\r\n     * and as the first parameter.\r\n     *\r\n     * By default, when `cnd` is/returns false, the method creates a new task. This option tells\r\n     * the method to reuse the current task/transaction context, and not create a new task.\r\n     *\r\n     * This option is ignored when executing against the top level of the protocol, because on\r\n     * that level, if no transaction is suddenly needed, a new task becomes necessary.\r\n     *\r\n     * @param {function|generator} cb\r\n     * Transaction/task callback function, to return the result that will determine either\r\n     * success or failure for the operation.\r\n     *\r\n     * The function can be either the first or the second parameter passed into the method.\r\n     *\r\n     * It also can be an $[ES6 generator] or an ES7 `async` function.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object with the result from the callback function.\r\n     *\r\n     * @see\r\n     * {@link Task},\r\n     * {@link Database#task Database.task},\r\n     * {@link Database#taskIf Database.taskIf},\r\n     * {@link Database#tx Database.tx},\r\n     * {@link TaskContext}\r\n     *\r\n     */\n\n\n    obj.txIf = function () {\n      const args = npm.pubUtils.taskArgs(arguments);\n      npm.assertOptions(args.options, ['tag', 'mode', 'cnd', 'reusable']);\n\n      try {\n        let cnd;\n\n        if ('cnd' in args.options) {\n          cnd = args.options.cnd;\n          cnd = typeof cnd === 'function' ? cnd.call(obj, obj) : !!cnd;\n        } else {\n          cnd = !obj.ctx || !obj.ctx.inTransaction;\n        }\n\n        args.options.cnd = cnd;\n        const reusable = args.options.reusable;\n        args.options.reusable = !cnd && obj.ctx && typeof reusable === 'function' ? reusable.call(obj, obj) : !!reusable;\n      } catch (e) {\n        return $p.reject(e);\n      }\n\n      return taskProcessor.call(this, args, args.options.cnd);\n    }; // Task method;\n    // Resolves with result from the callback function;\n\n\n    function taskProcessor(params, isTX) {\n      if (typeof params.cb !== 'function') {\n        return $p.reject(new TypeError('Callback function is required.'));\n      }\n\n      if (params.options.reusable) {\n        return config.$npm.task.callback(obj.ctx, obj, params.cb, config);\n      }\n\n      const taskCtx = ctx.clone(); // task context object;\n\n      if (isTX) {\n        taskCtx.txLevel = taskCtx.txLevel >= 0 ? taskCtx.txLevel + 1 : 0;\n      }\n\n      taskCtx.inTransaction = taskCtx.txLevel >= 0;\n      taskCtx.level = taskCtx.level >= 0 ? taskCtx.level + 1 : 0;\n      taskCtx.cb = params.cb; // callback function;\n\n      taskCtx.mode = params.options.mode; // transaction mode;\n\n      if (this !== obj) {\n        taskCtx.context = this; // calling context object;\n      }\n\n      const tsk = new config.$npm.task.Task(taskCtx, params.options.tag, isTX, config);\n      taskCtx.taskCtx = tsk.ctx;\n      extend(taskCtx, tsk);\n\n      if (taskCtx.db) {\n        // reuse existing connection;\n        npm.utils.addReadProp(tsk.ctx, 'useCount', taskCtx.db.useCount);\n        return config.$npm.task.execute(taskCtx, tsk, isTX, config);\n      } // connection required;\n\n\n      return config.$npm.connect.pool(taskCtx, dbThis).then(db => {\n        taskCtx.connect(db);\n        npm.utils.addReadProp(tsk.ctx, 'useCount', db.useCount);\n        return config.$npm.task.execute(taskCtx, tsk, isTX, config);\n      }).then(data => {\n        taskCtx.disconnect();\n        return data;\n      }).catch(error => {\n        taskCtx.disconnect();\n        return $p.reject(error);\n      });\n    } // lock all default properties to read-only,\n    // to prevent override by the client.\n\n\n    npm.utils.lock(obj, false, ctx.options); // extend the protocol;\n\n    npm.events.extend(ctx.options, obj, ctx.dc); // freeze the protocol permanently;\n\n    npm.utils.lock(obj, true, ctx.options);\n  }\n} // this event only happens when the connection is lost physically,\n// which cannot be tested automatically; removing from coverage:\n// istanbul ignore next\n\n\nfunction onError(err) {\n  // this client was never seen by pg-promise, which\n  // can happen if it failed to initialize\n  if (!err.client.$ctx) {\n    return;\n  }\n\n  const ctx = err.client.$ctx;\n  npm.events.error(ctx.options, err, {\n    cn: npm.utils.getSafeConnection(ctx.cn),\n    dc: ctx.dc\n  });\n}\n\nmodule.exports = config => {\n  const npmLocal = config.$npm;\n  npmLocal.connect = npmLocal.connect || npm.connect(config);\n  npmLocal.query = npmLocal.query || npm.query(config);\n  npmLocal.task = npmLocal.task || npm.task(config);\n  return Database;\n};\n/**\r\n * @callback Database.streamInitCB\r\n * @description\r\n * Stream initialization callback, used by {@link Database#stream Database.stream}.\r\n *\r\n * @param {external:Stream} stream\r\n * Stream object to initialize streaming.\r\n *\r\n * @example\r\n * const QueryStream = require('pg-query-stream');\r\n * const JSONStream = require('JSONStream');\r\n *\r\n * // you can also use pgp.as.format(query, values, options)\r\n * // to format queries properly, via pg-promise;\r\n * const qs = new QueryStream('SELECT * FROM users');\r\n *\r\n * db.stream(qs, stream => {\r\n *         // initiate streaming into the console:\r\n *         stream.pipe(JSONStream.stringify()).pipe(process.stdout);\r\n *     })\r\n *     .then(data => {\r\n *         console.log('Total rows processed:', data.processed,\r\n *           'Duration in milliseconds:', data.duration);\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n */\n\n/**\r\n * @external Stream\r\n * @see https://nodejs.org/api/stream.html\r\n */\n\n/**\r\n * @external pg-pool\r\n * @alias pg-pool\r\n * @see https://github.com/brianc/node-pg-pool\r\n */\n\n/**\r\n * @external Result\r\n * @see https://node-postgres.com/api/result\r\n */","map":null,"metadata":{},"sourceType":"script"}