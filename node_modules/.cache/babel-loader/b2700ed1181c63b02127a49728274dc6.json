{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n'use strict';\n\nconst npm = {\n  events: require('./events'),\n  utils: require('./utils'),\n  text: require('./text')\n}; ////////////////////////////////////////////\n// Streams query data into any destination,\n// with the help of pg-query-stream library.\n\nfunction $stream(ctx, qs, initCB, config) {\n  const $p = config.promise; // istanbul ignore next:\n  // we do not provide code coverage for the Native Bindings specifics\n\n  if (ctx.options.pgNative) {\n    return $p.reject(new Error(npm.text.nativeStreaming));\n  }\n\n  if (!qs || !qs.constructor || qs.constructor.name !== 'PgQueryStream') {\n    // stream object wasn't passed in correctly;\n    return $p.reject(new TypeError(npm.text.invalidStream));\n  }\n\n  if (qs._reading || qs._closed) {\n    // stream object is in the wrong state;\n    return $p.reject(new Error(npm.text.invalidStreamState));\n  }\n\n  if (typeof initCB !== 'function') {\n    // parameter `initCB` must be passed as the initialization callback;\n    return $p.reject(new TypeError(npm.text.invalidStreamCB));\n  }\n\n  let error = npm.events.query(ctx.options, getContext());\n\n  if (error) {\n    error = getError(error);\n    npm.events.error(ctx.options, error, getContext());\n    return $p.reject(error);\n  }\n\n  const stream = ctx.db.client.query(qs);\n  stream.on('data', onData);\n  stream.on('error', onError);\n  stream.on('end', onEnd);\n\n  try {\n    initCB.call(this, stream); // the stream must be initialized during the call;\n  } catch (e) {\n    release();\n    error = getError(e);\n    npm.events.error(ctx.options, error, getContext());\n    return $p.reject(error);\n  }\n\n  const start = Date.now();\n  let resolve,\n      reject,\n      nRows = 0,\n      cache = [];\n\n  function onData(data) {\n    cache.push(data);\n    nRows++;\n\n    if (cache.length >= qs.batchSize) {\n      notify();\n    }\n  }\n\n  function onError(e) {\n    release();\n    stream.close();\n    e = getError(e);\n    npm.events.error(ctx.options, e, getContext());\n    reject(e);\n  }\n\n  function onEnd() {\n    release();\n    notify();\n    resolve({\n      processed: nRows,\n      // total number of rows processed;\n      duration: Date.now() - start // duration, in milliseconds;\n\n    });\n  }\n\n  function release() {\n    stream.removeListener('data', onData);\n    stream.removeListener('error', onError);\n    stream.removeListener('end', onEnd);\n  }\n\n  function notify() {\n    if (cache.length) {\n      const context = getContext();\n      error = npm.events.receive(ctx.options, cache, undefined, context);\n      cache = [];\n\n      if (error) {\n        onError(error);\n      }\n    }\n  }\n\n  function getError(e) {\n    return e instanceof npm.utils.InternalError ? e.error : e;\n  }\n\n  function getContext() {\n    let client;\n\n    if (ctx.db) {\n      client = ctx.db.client;\n    } else {\n      error = new Error(npm.text.looseQuery);\n    }\n\n    return {\n      client,\n      dc: ctx.dc,\n      query: qs.cursor.text,\n      params: qs.cursor.values,\n      ctx: ctx.ctx\n    };\n  }\n\n  return $p((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n}\n\nmodule.exports = $stream;","map":null,"metadata":{},"sourceType":"script"}