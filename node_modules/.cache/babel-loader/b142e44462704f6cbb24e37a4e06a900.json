{"ast":null,"code":"'use strict';\n\nconst errorLib = require('./error');\n\nconst utils = require('./utils');\n\nconst PEC = errorLib.parsingErrorCode; // symbols that need no spaces around them:\n\nconst compressors = '.,;:()[]=<>+-*/|!?@#'; ////////////////////////////////////////////\n// Parses and minimizes a PostgreSQL script.\n\nfunction minify(sql, options) {\n  if (typeof sql !== 'string') {\n    throw new TypeError('Input SQL must be a text string.');\n  }\n\n  if (!sql.length) {\n    return '';\n  }\n\n  options = options || {};\n  let idx = 0,\n      // current index\n  result = '',\n      // resulting sql\n  space = false; // add a space on the next step\n\n  const len = sql.length,\n        // sql length\n  EOL = utils.getEOL(sql); // end-of-line\n\n  do {\n    const s = sql[idx],\n          // current symbol;\n    s1 = sql[idx + 1]; // next symbol;\n\n    if (isGap(s)) {\n      while (++idx < len && isGap(sql[idx]));\n\n      if (idx < len) {\n        space = true;\n      }\n\n      idx--;\n      continue;\n    }\n\n    if (s === '-' && s1 === '-') {\n      const lb = sql.indexOf(EOL, idx + 2);\n\n      if (lb < 0) {\n        break;\n      }\n\n      idx = lb - 1;\n      skipGaps();\n      continue;\n    }\n\n    if (s === '/' && s1 === '*') {\n      let c = idx + 1,\n          open = 0,\n          close = 0,\n          lastOpen;\n\n      while (++c < len - 1 && close <= open) {\n        if (sql[c] === '/' && sql[c + 1] === '*') {\n          lastOpen = c;\n          open++;\n          c++;\n        } else {\n          if (sql[c] === '*' && sql[c + 1] === '/') {\n            close++;\n            c++;\n          }\n        }\n      }\n\n      if (close <= open) {\n        idx = lastOpen;\n        throwError(PEC.unclosedMLC);\n      }\n\n      if (sql[idx + 2] !== '!') {\n        idx = c - 1;\n        skipGaps();\n        continue;\n      }\n    }\n\n    let closeIdx, text;\n\n    if (s === '\"') {\n      closeIdx = sql.indexOf('\"', idx + 1);\n\n      if (closeIdx < 0) {\n        throwError(PEC.unclosedQI);\n      }\n\n      text = sql.substr(idx, closeIdx - idx + 1);\n\n      if (text.indexOf(EOL) > 0) {\n        throwError(PEC.multiLineQI);\n      }\n\n      if (options.compress) {\n        space = false;\n      }\n\n      addSpace();\n      result += text;\n      idx = closeIdx;\n      skipGaps();\n      continue;\n    }\n\n    if (s === '\\'') {\n      closeIdx = idx;\n\n      do {\n        closeIdx = sql.indexOf('\\'', closeIdx + 1);\n\n        if (closeIdx > 0) {\n          let i = closeIdx;\n\n          while (sql[--i] === '\\\\');\n\n          if ((closeIdx - i) % 2) {\n            let step = closeIdx;\n\n            while (++step < len && sql[step] === '\\'');\n\n            if ((step - closeIdx) % 2) {\n              closeIdx = step - 1;\n              break;\n            }\n\n            closeIdx = step === len ? -1 : step;\n          }\n        }\n      } while (closeIdx > 0);\n\n      if (closeIdx < 0) {\n        throwError(PEC.unclosedText);\n      }\n\n      if (options.compress) {\n        space = false;\n      }\n\n      addSpace();\n      text = sql.substr(idx, closeIdx - idx + 1);\n      const hasLB = text.indexOf(EOL) > 0;\n\n      if (hasLB) {\n        text = text.split(EOL).map(m => {\n          return m.replace(/^\\s+|\\s+$/g, '');\n        }).join('\\\\n');\n      }\n\n      const hasTabs = text.indexOf('\\t') > 0;\n\n      if (hasLB || hasTabs) {\n        const prev = idx ? sql[idx - 1] : '';\n\n        if (prev !== 'E' && prev !== 'e') {\n          const r = result ? result[result.length - 1] : '';\n\n          if (r && r !== ' ' && compressors.indexOf(r) < 0) {\n            result += ' ';\n          }\n\n          result += 'E';\n        }\n\n        if (hasTabs) {\n          text = text.replace(/\\t/g, '\\\\t');\n        }\n      }\n\n      result += text;\n      idx = closeIdx;\n      skipGaps();\n      continue;\n    }\n\n    if (options.compress && compressors.indexOf(s) >= 0) {\n      space = false;\n      skipGaps();\n    }\n\n    addSpace();\n    result += s;\n  } while (++idx < len);\n\n  return result;\n\n  function skipGaps() {\n    if (options.compress) {\n      while (idx < len - 1 && isGap(sql[idx + 1])) {\n        idx++;\n      }\n    }\n  }\n\n  function addSpace() {\n    if (space) {\n      if (result.length) {\n        result += ' ';\n      }\n\n      space = false;\n    }\n  }\n\n  function throwError(code) {\n    const position = utils.getIndexPos(sql, idx, EOL);\n    throw new errorLib.SQLParsingError(code, position);\n  }\n} ////////////////////////////////////\n// Identifies a gap / empty symbol.\n\n\nfunction isGap(s) {\n  return s === ' ' || s === '\\t' || s === '\\r' || s === '\\n';\n}\n\nmodule.exports = minify;","map":null,"metadata":{},"sourceType":"script"}