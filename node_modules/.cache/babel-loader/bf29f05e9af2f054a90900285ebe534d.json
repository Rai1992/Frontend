{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n'use strict';\n\nconst npm = {\n  assertOptions: require('assert-options'),\n  utils: require('../utils'),\n  formatting: require('../formatting')\n};\n/**\r\n * @class helpers.TableName\r\n * @description\r\n *\r\n * **Alternative Syntax:** `TableName({table, [schema]})` &#8658; {@link helpers.TableName}\r\n *\r\n * Prepares and escapes a full table name that can be injected into queries directly.\r\n *\r\n * This is a read-only type that can be used wherever parameter `table` is supported.\r\n *\r\n * It supports $[Custom Type Formatting], which means you can use the type directly as a formatting\r\n * parameter, without specifying any escaping.\r\n *\r\n * @param {string|object} table\r\n * Table name details, depending on the type:\r\n *\r\n * - table name, if `table` is a string\r\n * - object `{table, [schema]}`\r\n *\r\n * @param {string} [schema]\r\n * Database schema name.\r\n *\r\n * When `table` is passed in as `{table, [schema]}`, this parameter is ignored.\r\n *\r\n * @property {string} name\r\n * Formatted/escaped full table name, based on properties `schema` + `table`.\r\n *\r\n * @property {string} table\r\n * Table name.\r\n *\r\n * @property {string} schema\r\n * Database schema name.\r\n *\r\n * It is `undefined` when no schema was specified (or if it was an empty string).\r\n *\r\n * @returns {helpers.TableName}\r\n *\r\n * @see\r\n * {@link helpers.TableName#toPostgres toPostgres}\r\n *\r\n * @example\r\n *\r\n * const table = new pgp.helpers.TableName('my-table', 'my-schema');\r\n * console.log(table);\r\n * //=> \"my-schema\".\"my-table\"\r\n *\r\n * // Formatting the type directly:\r\n * pgp.as.format('SELECT * FROM $1', table);\r\n * //=> SELECT * FROM \"my-schema\".\"my-table\"\r\n *\r\n */\n\nfunction TableName(table, schema) {\n  if (!(this instanceof TableName)) {\n    return new TableName(table, schema);\n  }\n\n  if (typeof table !== 'string') {\n    table = npm.assertOptions(table, ['table', 'schema']);\n    schema = table.schema;\n    table = table.table;\n  }\n\n  if (!npm.utils.isText(table)) {\n    throw new TypeError('Table name must be a non-empty text string.');\n  }\n\n  if (!npm.utils.isNull(schema)) {\n    if (typeof schema !== 'string') {\n      throw new TypeError('Invalid schema name.');\n    }\n\n    if (schema.length > 0) {\n      this.schema = schema;\n    }\n  }\n\n  this.table = table;\n  this.name = npm.formatting.as.name(table);\n\n  if (this.schema) {\n    this.name = npm.formatting.as.name(schema) + '.' + this.name;\n  }\n\n  this[npm.formatting.as.ctf.rawType] = true; // do not format the content when used as a formatting value\n\n  Object.freeze(this);\n}\n/**\r\n * @method helpers.TableName#toPostgres\r\n * @description\r\n * $[Custom Type Formatting], based on $[Symbolic CTF], i.e. the actual method is available only via {@link external:Symbol Symbol}:\r\n *\r\n * ```js\r\n * const ctf = pgp.as.ctf; // Custom Type Formatting symbols namespace\r\n * const fullName = tn[ctf.toPostgres]; // tn = an object of type TableName\r\n * ```\r\n *\r\n * This is a raw formatting type (`rawType = true`), i.e. when used as a query-formatting parameter, type `TableName`\r\n * injects full table name as raw text.\r\n *\r\n * @param {helpers.TableName} [self]\r\n * Optional self-reference, for ES6 arrow functions.\r\n *\r\n * @returns {string}\r\n * Escaped full table name that includes optional schema name, if specified.\r\n */\n\n\nTableName.prototype[npm.formatting.as.ctf.toPostgres] = function (self) {\n  self = this || self;\n  return self.name;\n};\n/**\r\n * @method helpers.TableName#toString\r\n * @description\r\n * Creates a well-formatted string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @returns {string}\r\n */\n\n\nTableName.prototype.toString = function () {\n  return this.name;\n};\n\nnpm.utils.addInspection(TableName, function () {\n  return this.toString();\n});\nmodule.exports = TableName;","map":null,"metadata":{},"sourceType":"script"}