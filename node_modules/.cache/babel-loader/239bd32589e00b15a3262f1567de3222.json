{"ast":null,"code":"'use strict';\n\nconst Result = require('pg/lib/result.js');\n\nconst prepare = require('pg/lib/utils.js').prepareValue;\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst util = require('util');\n\nvar nextUniqueID = 1; // concept borrowed from org.postgresql.core.v3.QueryExecutorImpl\n\nfunction Cursor(text, values, config) {\n  EventEmitter.call(this);\n  this._conf = config || {};\n  this.text = text;\n  this.values = values ? values.map(prepare) : null;\n  this.connection = null;\n  this._queue = [];\n  this.state = 'initialized';\n  this._result = new Result(this._conf.rowMode);\n  this._cb = null;\n  this._rows = null;\n  this._portal = null;\n}\n\nutil.inherits(Cursor, EventEmitter);\n\nCursor.prototype.submit = function (connection) {\n  this.connection = connection;\n  this._portal = 'C_' + nextUniqueID++;\n  const con = connection;\n  con.parse({\n    text: this.text\n  }, true);\n  con.bind({\n    portal: this._portal,\n    values: this.values\n  }, true);\n  con.describe({\n    type: 'P',\n    name: this._portal // AWS Redshift requires a portal name\n\n  }, true);\n  con.flush();\n\n  const ifNoData = () => {\n    this.state = 'idle';\n\n    this._shiftQueue();\n  };\n\n  if (this._conf.types) {\n    this._result._getTypeParser = this._conf.types.getTypeParser;\n  }\n\n  con.once('noData', ifNoData);\n  con.once('rowDescription', () => {\n    con.removeListener('noData', ifNoData);\n  });\n};\n\nCursor.prototype._shiftQueue = function () {\n  if (this._queue.length) {\n    this._getRows.apply(this, this._queue.shift());\n  }\n};\n\nCursor.prototype.handleRowDescription = function (msg) {\n  this._result.addFields(msg.fields);\n\n  this.state = 'idle';\n\n  this._shiftQueue();\n};\n\nCursor.prototype.handleDataRow = function (msg) {\n  const row = this._result.parseRow(msg.fields);\n\n  this.emit('row', row, this._result);\n\n  this._rows.push(row);\n};\n\nCursor.prototype._sendRows = function () {\n  this.state = 'idle';\n  setImmediate(() => {\n    const cb = this._cb; // remove callback before calling it\n    // because likely a new one will be added\n    // within the call to this callback\n\n    this._cb = null;\n\n    if (cb) {\n      this._result.rows = this._rows;\n      cb(null, this._rows, this._result);\n    }\n\n    this._rows = [];\n  });\n};\n\nCursor.prototype.handleCommandComplete = function (msg) {\n  this._result.addCommandComplete(msg);\n\n  this.connection.sync();\n};\n\nCursor.prototype.handlePortalSuspended = function () {\n  this._sendRows();\n};\n\nCursor.prototype.handleReadyForQuery = function () {\n  this._sendRows();\n\n  this.emit('end', this._result);\n  this.state = 'done';\n};\n\nCursor.prototype.handleEmptyQuery = function () {\n  this.connection.sync();\n};\n\nCursor.prototype.handleError = function (msg) {\n  this.state = 'error';\n  this._error = msg; // satisfy any waiting callback\n\n  if (this._cb) {\n    this._cb(msg);\n  } // dispatch error to all waiting callbacks\n\n\n  for (var i = 0; i < this._queue.length; i++) {\n    this._queue.pop()[1](msg);\n  }\n\n  if (this.listenerCount('error') > 0) {\n    // only dispatch error events if we have a listener\n    this.emit('error', msg);\n  } // call sync to keep this connection from hanging\n\n\n  this.connection.sync();\n};\n\nCursor.prototype._getRows = function (rows, cb) {\n  this.state = 'busy';\n  this._cb = cb;\n  this._rows = [];\n  const msg = {\n    portal: this._portal,\n    rows: rows\n  };\n  this.connection.execute(msg, true);\n  this.connection.flush();\n};\n\nCursor.prototype.end = function (cb) {\n  if (this.state !== 'initialized') {\n    this.connection.sync();\n  }\n\n  this.connection.once('end', cb);\n  this.connection.end();\n};\n\nCursor.prototype.close = function (cb) {\n  if (this.state === 'done') {\n    return setImmediate(cb);\n  }\n\n  this.connection.close({\n    type: 'P'\n  });\n  this.connection.sync();\n  this.state = 'done';\n\n  if (cb) {\n    this.connection.once('closeComplete', function () {\n      cb();\n    });\n  }\n};\n\nCursor.prototype.read = function (rows, cb) {\n  if (this.state === 'idle') {\n    return this._getRows(rows, cb);\n  }\n\n  if (this.state === 'busy' || this.state === 'initialized') {\n    return this._queue.push([rows, cb]);\n  }\n\n  if (this.state === 'error') {\n    return setImmediate(() => cb(this._error));\n  }\n\n  if (this.state === 'done') {\n    return setImmediate(() => cb(null, []));\n  } else {\n    throw new Error('Unknown state: ' + this.state);\n  }\n};\n\nmodule.exports = Cursor;","map":null,"metadata":{},"sourceType":"script"}