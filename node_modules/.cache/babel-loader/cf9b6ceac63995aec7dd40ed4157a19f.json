{"ast":null,"code":"'use strict';\n\nvar PageError = require('../errors/page');\n/**\r\n * @method page\r\n * @description\r\n * Resolves a dynamic sequence of pages/arrays with [mixed values]{@tutorial mixed}.\r\n *\r\n * The method acquires pages (arrays of [mixed values]{@tutorial mixed}) from the `source` function, one by one,\r\n * and resolves each page as a {@link batch}, till no more pages left or an error/reject occurs.\r\n *\r\n * @param {Function|generator} source\r\n * Expected to return a [mixed value]{@tutorial mixed} that resolves with the next page of data (array of [mixed values]{@tutorial mixed}).\r\n * Returning or resolving with `undefined` ends the sequence, and the method resolves.\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * Parameters:\r\n *  - `index` = index of the page being requested\r\n *  - `data` = previously returned page, resolved as a {@link batch} (`undefined` when `index=0`)\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * If the function throws an error or returns a rejected promise, the method rejects with\r\n * {@link errors.PageError PageError}, which will have property `source` set.\r\n *\r\n * And if the function returns or resolves with anything other than an array or `undefined`,\r\n * the method rejects with the same {@link errors.PageError PageError}, but with `error` set to\r\n * `Unexpected data returned from the source.`\r\n *\r\n * Passing in anything other than a function will reject with {@link external:TypeError TypeError} = `Parameter 'source' must be a function.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.dest]\r\n * Optional destination function (or generator), to receive a resolved {@link batch} of data\r\n * for each page, process it and respond as required.\r\n *\r\n * Parameters:\r\n *  - `index` = page index in the sequence\r\n *  - `data` = page data resolved as a {@link batch}\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise object, if notifications are handled asynchronously.\r\n * And if a promise is returned, the method will not request another page from the `source`\r\n * function until the promise has been resolved.\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.PageError PageError}, which will have property `dest` set.\r\n *\r\n * @param {Number} [options.limit=0]\r\n * Limits the maximum number of pages to be requested from the `source`. If the value is greater\r\n * than 0, the method will successfully resolve once the specified limit has been reached.\r\n *\r\n * When `limit` isn't specified (default), the sequence is unlimited, and it will continue\r\n * till one of the following occurs:\r\n *  - `source` returns or resolves with `undefined` or an invalid value (non-array)\r\n *  - either `source` or `dest` functions throw an error or return a rejected promise\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When successful, the method resolves with object `{pages, total, duration}`:\r\n *  - `pages` = number of pages resolved\r\n *  - `total` = the sum of all page sizes (total number of values resolved)\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When the method fails, it rejects with {@link errors.PageError PageError}.\r\n *\r\n */\n\n\nfunction page(source, options, config) {\n  var $p = config.promise,\n      spex = config.spex,\n      utils = config.utils;\n\n  if (typeof source !== 'function') {\n    return $p.reject(new TypeError('Parameter \\'source\\' must be a function.'));\n  }\n\n  options = options || {};\n  source = utils.wrap(source);\n  var request,\n      srcTime,\n      destTime,\n      limit = options.limit > 0 ? parseInt(options.limit) : 0,\n      dest = utils.wrap(options.dest),\n      self = this,\n      start = Date.now(),\n      total = 0;\n  return $p(function (resolve, reject) {\n    function loop(idx) {\n      var srcNow = Date.now(),\n          srcDelay = idx ? srcNow - srcTime : undefined;\n      srcTime = srcNow;\n      utils.resolve.call(self, source, [idx, request, srcDelay], function (value) {\n        if (value === undefined) {\n          success();\n        } else {\n          if (value instanceof Array) {\n            spex.batch(value).then(function (data) {\n              request = data;\n              total += data.length;\n\n              if (dest) {\n                var destResult,\n                    destNow = Date.now(),\n                    destDelay = idx ? destNow - destTime : undefined;\n                destTime = destNow;\n\n                try {\n                  destResult = dest.call(self, idx, data, destDelay);\n                } catch (err) {\n                  fail({\n                    error: err,\n                    dest: data\n                  }, 4, dest.name);\n                  return;\n                }\n\n                if (utils.isPromise(destResult)) {\n                  destResult.then(next).catch(function (error) {\n                    fail({\n                      error: error,\n                      dest: data\n                    }, 3, dest.name);\n                  });\n                } else {\n                  next();\n                }\n              } else {\n                next();\n              }\n\n              return null; // this dummy return is just to prevent Bluebird warnings;\n            }).catch(function (error) {\n              fail({\n                error: error\n              }, 0);\n            });\n          } else {\n            fail({\n              error: new Error('Unexpected data returned from the source.'),\n              source: request\n            }, 5, source.name);\n          }\n        }\n      }, function (reason, isRej) {\n        fail({\n          error: reason,\n          source: request\n        }, isRej ? 1 : 2, source.name);\n      });\n\n      function next() {\n        if (limit === ++idx) {\n          success();\n        } else {\n          loop(idx);\n        }\n\n        return null; // this dummy return is just to prevent Bluebird warnings;\n      }\n\n      function success() {\n        resolve({\n          pages: idx,\n          total: total,\n          duration: Date.now() - start\n        });\n      }\n\n      function fail(reason, code, cbName) {\n        reason.index = idx;\n        reject(new PageError(reason, code, cbName, Date.now() - start));\n      }\n    }\n\n    loop(0);\n  });\n}\n\nmodule.exports = function (config) {\n  return function (source, options) {\n    return page.call(this, source, options, config);\n  };\n};","map":null,"metadata":{},"sourceType":"script"}