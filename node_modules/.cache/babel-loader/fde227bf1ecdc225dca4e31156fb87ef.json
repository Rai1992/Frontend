{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n'use strict';\n\nconst npm = {\n  assertOptions: require('assert-options'),\n  os: require('os'),\n  utils: require('../utils'),\n  formatting: require('../formatting'),\n  patterns: require('../patterns')\n};\n/**\r\n *\r\n * @class helpers.Column\r\n * @description\r\n *\r\n * It is a read-only structure that contains details for a single column, to be primarily used by {@link helpers.ColumnSet ColumnSet}.\r\n *\r\n * The class parses and validates all the details, and prepares them for high-performance query generation.\r\n *\r\n * @param {string|helpers.ColumnConfig} col\r\n * Column details, depending on the type.\r\n *\r\n * When it is a string, it is expected to contain a name for both the column and the source property, assuming that the two are the same.\r\n * The name must adhere to JavaScript syntax for variable names. The name can be appended with any format modifier as supported by\r\n * {@link formatting.format as.format} (`^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`), which is then removed from the name and put\r\n * into property `mod`. If the name starts with `?`, it is removed, while setting flag `cnd` = `true`.\r\n *\r\n * If the string doesn't adhere to the above requirements, the method will throw {@link external:TypeError TypeError} = `Invalid column syntax`.\r\n *\r\n * When `col` is a simple {@link helpers.ColumnConfig ColumnConfig}-like object, it is used as an input configurator to set all the properties\r\n * of the class.\r\n *\r\n * @property {string} name\r\n * Destination column name + source property name (if `prop` is skipped). The name must adhere to JavaScript syntax for variables,\r\n * unless `prop` is specified, in which case `name` represents only the column name, and therefore can be any non-empty string.\r\n *\r\n * @property {string} [prop]\r\n * Source property name, if different from the column's name. It must adhere to JavaScript syntax for variables.\r\n *\r\n * It is ignored when it is the same as `name`.\r\n *\r\n * @property {string} [mod]\r\n * Formatting modifier, as supported by method {@link formatting.format as.format}: `^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`.\r\n *\r\n * @property {string} [cast]\r\n * Server-side type casting, without `::` in front.\r\n *\r\n * @property {boolean} [cnd]\r\n * Conditional column flag.\r\n *\r\n * Used by methods {@link helpers.update update} and {@link helpers.sets sets}, ignored by methods {@link helpers.insert insert} and\r\n * {@link helpers.values values}. It indicates that the column is reserved for a `WHERE` condition, not to be set or updated.\r\n *\r\n * It can be set from a string initialization, by adding `?` in front of the name.\r\n *\r\n * @property {*} [def]\r\n * Default value for the property, to be used only when the source object doesn't have the property.\r\n * It is ignored when property `init` is set.\r\n *\r\n * @property {helpers.initCB} [init]\r\n * Override callback for the value.\r\n *\r\n * @property {helpers.skipCB} [skip]\r\n * An override for skipping columns dynamically.\r\n *\r\n * Used by methods {@link helpers.update update} (for a single object) and {@link helpers.sets sets}, ignored by methods\r\n * {@link helpers.insert insert} and {@link helpers.values values}.\r\n *\r\n * It is also ignored when conditional flag `cnd` is set.\r\n *\r\n * @returns {helpers.Column}\r\n *\r\n * @see\r\n * {@link helpers.ColumnConfig ColumnConfig},\r\n * {@link helpers.Column#castText castText},\r\n * {@link helpers.Column#escapedName escapedName},\r\n * {@link helpers.Column#variable variable}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')({\r\n *     capSQL: true // if you want all generated SQL capitalized\r\n * });\r\n *\r\n * const Column = pgp.helpers.Column;\r\n *\r\n * // creating a column from just a name:\r\n * const col1 = new Column('colName');\r\n * console.log(col1);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * // }\r\n *\r\n * // creating a column from a name + modifier:\r\n * const col2 = new Column('colName:csv');\r\n * console.log(col2);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * //    mod: \":csv\"\r\n * // }\r\n *\r\n * // creating a column from a configurator:\r\n * const col3 = new Column({\r\n *     name: 'colName', // required\r\n *     prop: 'propName', // optional\r\n *     mod: '^', // optional\r\n *     def: 123 // optional\r\n * });\r\n * console.log(col3);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * //    prop: \"propName\"\r\n * //    mod: \"^\"\r\n * //    def: 123\r\n * // }\r\n *\r\n */\n\nfunction Column(col) {\n  if (!(this instanceof Column)) {\n    return new Column(col);\n  }\n\n  if (typeof col === 'string') {\n    const info = parseColumn(col);\n    this.name = info.name;\n\n    if ('mod' in info) {\n      this.mod = info.mod;\n    }\n\n    if ('cnd' in info) {\n      this.cnd = info.cnd;\n    }\n  } else {\n    col = npm.assertOptions(col, ['name', 'prop', 'mod', 'cast', 'cnd', 'def', 'init', 'skip']);\n\n    if ('name' in col) {\n      if (!npm.utils.isText(col.name)) {\n        throw new TypeError('Invalid \\'name\\' value: ' + JSON.stringify(col.name) + '. A non-empty string was expected.');\n      }\n\n      if (npm.utils.isNull(col.prop) && !isValidVariable(col.name)) {\n        throw new TypeError('Invalid \\'name\\' syntax: ' + JSON.stringify(col.name) + '.');\n      }\n\n      this.name = col.name; // column name + property name (if 'prop' isn't specified)\n\n      if (!npm.utils.isNull(col.prop)) {\n        if (!npm.utils.isText(col.prop)) {\n          throw new TypeError('Invalid \\'prop\\' value: ' + JSON.stringify(col.prop) + '. A non-empty string was expected.');\n        }\n\n        if (!isValidVariable(col.prop)) {\n          throw new TypeError('Invalid \\'prop\\' syntax: ' + JSON.stringify(col.prop) + '.');\n        }\n\n        if (col.prop !== col.name) {\n          // optional property name, if different from the column's name;\n          this.prop = col.prop;\n        }\n      }\n\n      if (!npm.utils.isNull(col.mod)) {\n        if (typeof col.mod !== 'string' || !isValidMod(col.mod)) {\n          throw new TypeError('Invalid \\'mod\\' value: ' + JSON.stringify(col.mod) + '.');\n        }\n\n        this.mod = col.mod; // optional format modifier;\n      }\n\n      if (!npm.utils.isNull(col.cast)) {\n        this.cast = parseCast(col.cast); // optional SQL type casting\n      }\n\n      if ('cnd' in col) {\n        this.cnd = !!col.cnd;\n      }\n\n      if ('def' in col) {\n        this.def = col.def; // optional default\n      }\n\n      if (typeof col.init === 'function') {\n        this.init = col.init; // optional value override (overrides 'def' also)\n      }\n\n      if (typeof col.skip === 'function') {\n        this.skip = col.skip;\n      }\n    } else {\n      throw new TypeError('Invalid column details.');\n    }\n  }\n\n  const variable = '${' + (this.prop || this.name) + (this.mod || '') + '}',\n        castText = this.cast ? '::' + this.cast : '',\n        escapedName = npm.formatting.as.name(this.name);\n  /**\r\n   * @name helpers.Column#variable\r\n   * @type string\r\n   * @readonly\r\n   * @description\r\n   * Full-syntax formatting variable, ready for direct use in query templates.\r\n   *\r\n   * @example\r\n   *\r\n   * const cs = new pgp.helpers.ColumnSet([\r\n   *     'id',\r\n   *     'coordinate:json',\r\n   *     {\r\n   *         name: 'places',\r\n   *         mod: ':csv',\r\n   *         cast: 'int[]'\r\n   *     }\r\n   * ]);\r\n   *\r\n   * // cs.columns[0].variable = ${id}\r\n   * // cs.columns[1].variable = ${coordinate:json}\r\n   * // cs.columns[2].variable = ${places:csv}::int[]\r\n   */\n\n  Object.defineProperty(this, 'variable', {\n    value: variable,\n    enumerable: true\n  });\n  /**\r\n   * @name helpers.Column#castText\r\n   * @type string\r\n   * @readonly\r\n   * @description\r\n   * Full-syntax sql type casting, if there is any, or else an empty string.\r\n   */\n\n  Object.defineProperty(this, 'castText', {\n    value: castText,\n    enumerable: true\n  });\n  /**\r\n   * @name helpers.Column#escapedName\r\n   * @type string\r\n   * @readonly\r\n   * @description\r\n   * Escaped name of the column, ready to be injected into queries directly.\r\n   *\r\n   */\n\n  Object.defineProperty(this, 'escapedName', {\n    value: escapedName,\n    enumerable: true\n  });\n  Object.freeze(this);\n}\n\nfunction parseCast(name) {\n  if (typeof name === 'string') {\n    const s = name.replace(/^[:\\s]*|\\s*$/g, '');\n\n    if (s) {\n      return s;\n    }\n  }\n\n  throw new TypeError('Invalid \\'cast\\' value: ' + JSON.stringify(name) + '.');\n}\n\nfunction parseColumn(name) {\n  const m = name.match(npm.patterns.validColumn);\n\n  if (m && m[0] === name) {\n    const res = {};\n\n    if (name[0] === '?') {\n      res.cnd = true;\n      name = name.substr(1);\n    }\n\n    const mod = name.match(npm.patterns.hasValidModifier);\n\n    if (mod) {\n      res.name = name.substr(0, mod.index);\n      res.mod = mod[0];\n    } else {\n      res.name = name;\n    }\n\n    return res;\n  }\n\n  throw new TypeError('Invalid column syntax: ' + JSON.stringify(name) + '.');\n}\n\nfunction isValidMod(mod) {\n  return npm.patterns.validModifiers.indexOf(mod) !== -1;\n}\n\nfunction isValidVariable(name) {\n  const m = name.match(npm.patterns.validVariable);\n  return !!m && m[0] === name;\n}\n/**\r\n * @method helpers.Column#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\n\n\nColumn.prototype.toString = function (level) {\n  level = level > 0 ? parseInt(level) : 0;\n  const gap0 = npm.utils.messageGap(level),\n        gap1 = npm.utils.messageGap(level + 1),\n        lines = [gap0 + 'Column {', gap1 + 'name: ' + JSON.stringify(this.name)];\n\n  if ('prop' in this) {\n    lines.push(gap1 + 'prop: ' + JSON.stringify(this.prop));\n  }\n\n  if ('mod' in this) {\n    lines.push(gap1 + 'mod: ' + JSON.stringify(this.mod));\n  }\n\n  if ('cast' in this) {\n    lines.push(gap1 + 'cast: ' + JSON.stringify(this.cast));\n  }\n\n  if ('cnd' in this) {\n    lines.push(gap1 + 'cnd: ' + JSON.stringify(this.cnd));\n  }\n\n  if ('def' in this) {\n    lines.push(gap1 + 'def: ' + JSON.stringify(this.def));\n  }\n\n  if ('init' in this) {\n    lines.push(gap1 + 'init: [Function]');\n  }\n\n  if ('skip' in this) {\n    lines.push(gap1 + 'skip: [Function]');\n  }\n\n  lines.push(gap0 + '}');\n  return lines.join(npm.os.EOL);\n};\n\nnpm.utils.addInspection(Column, function () {\n  return this.toString();\n});\n/**\r\n * @typedef helpers.ColumnConfig\r\n * @description\r\n * A simple structure with column details, to be passed into the {@link helpers.Column Column} constructor for initialization.\r\n *\r\n * @property {string} name\r\n * Destination column name + source property name (if `prop` is skipped). The name must adhere to JavaScript syntax for variables,\r\n * unless `prop` is specified, in which case `name` represents only the column name, and therefore can be any non-empty string.\r\n *\r\n * @property {string} [prop]\r\n * Source property name, if different from the column's name. It must adhere to JavaScript syntax for variables.\r\n *\r\n * It is ignored when it is the same as `name`.\r\n *\r\n * @property {string} [mod]\r\n * Formatting modifier, as supported by method {@link formatting.format as.format}: `^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`.\r\n *\r\n * @property {string} [cast]\r\n * Server-side type casting. Leading `::` is allowed, but not needed (automatically removed when specified).\r\n *\r\n * @property {boolean} [cnd]\r\n * Conditional column flag.\r\n *\r\n * Used by methods {@link helpers.update update} and {@link helpers.sets sets}, ignored by methods {@link helpers.insert insert} and\r\n * {@link helpers.values values}. It indicates that the column is reserved for a `WHERE` condition, not to be set or updated.\r\n *\r\n * It can be set from a string initialization, by adding `?` in front of the name.\r\n *\r\n * @property {*} [def]\r\n * Default value for the property, to be used only when the source object doesn't have the property.\r\n * It is ignored when property `init` is set.\r\n *\r\n * @property {helpers.initCB} [init]\r\n * Override callback for the value.\r\n *\r\n * @property {helpers.skipCB} [skip]\r\n * An override for skipping columns dynamically.\r\n *\r\n * Used by methods {@link helpers.update update} (for a single object) and {@link helpers.sets sets}, ignored by methods\r\n * {@link helpers.insert insert} and {@link helpers.values values}.\r\n *\r\n * It is also ignored when conditional flag `cnd` is set.\r\n *\r\n */\n\n/**\r\n * @callback helpers.initCB\r\n * @description\r\n * A callback function type used by parameter `init` within {@link helpers.ColumnConfig ColumnConfig}.\r\n *\r\n * It works as an override for the corresponding property value in the `source` object.\r\n *\r\n * The function is called with `this` set to the `source` object.\r\n *\r\n * @param {*} col\r\n * Column-to-property descriptor.\r\n *\r\n * @param {object} col.source\r\n * The source object, equals to `this` that's passed into the function.\r\n *\r\n * @param {string} col.name\r\n * Resolved name of the property within the `source` object, i.e. the value of `name` when `prop` is not used\r\n * for the column, or the value of `prop` when it is specified.\r\n *\r\n * @param {*} col.value\r\n *\r\n * Property value, set to one of the following:\r\n *\r\n * - Value of the property within the `source` object (`value` = `source[name]`), if the property exists\r\n * - If the property doesn't exist and `def` is set in the column, then `value` is set to the value of `def`\r\n * - If the property doesn't exist and `def` is not set in the column, then `value` is set to `undefined`\r\n *\r\n * @param {boolean} col.exists\r\n * Indicates whether the property exists in the `source` object (`exists = name in source`).\r\n *\r\n * @returns {*}\r\n * The new value to be used for the corresponding column.\r\n */\n\n/**\r\n * @callback helpers.skipCB\r\n * @description\r\n * A callback function type used by parameter `skip` within {@link helpers.ColumnConfig ColumnConfig}.\r\n *\r\n * It is to dynamically determine when the property with specified `name` in the `source` object is to be skipped.\r\n *\r\n * The function is called with `this` set to the `source` object.\r\n *\r\n * @param {*} col\r\n * Column-to-property descriptor.\r\n *\r\n * @param {object} col.source\r\n * The source object, equals to `this` that's passed into the function.\r\n *\r\n * @param {string} col.name\r\n * Resolved name of the property within the `source` object, i.e. the value of `name` when `prop` is not used\r\n * for the column, or the value of `prop` when it is specified.\r\n *\r\n * @param {*} col.value\r\n *\r\n * Property value, set to one of the following:\r\n *\r\n * - Value of the property within the `source` object (`value` = `source[name]`), if the property exists\r\n * - If the property doesn't exist and `def` is set in the column, then `value` is set to the value of `def`\r\n * - If the property doesn't exist and `def` is not set in the column, then `value` is set to `undefined`\r\n *\r\n * @param {boolean} col.exists\r\n * Indicates whether the property exists in the `source` object (`exists = name in source`).\r\n *\r\n * @returns {boolean}\r\n * A truthy value that indicates whether the column is to be skipped.\r\n *\r\n */\n\nmodule.exports = Column;","map":null,"metadata":{},"sourceType":"script"}