{"ast":null,"code":"'use strict';\n/** @module where */\n\nconst _ = require('lodash');\n\nconst parseKey = require('../util/parse-key');\n\nconst ops = require('./operations');\n/**\n * Generate a predicate for a query against an ordinary table.\n *\n * @param {Object} condition - A condition object (generated by parseKey).\n * @return {Object} A predicate object.\n */\n\n\nconst tableGenerator = function (condition) {\n  if (condition.appended.mutator) {\n    condition = condition.appended.mutator(condition);\n  } else if (condition.value) {\n    condition.params.push(condition.value);\n    condition.value = \"$\".concat(condition.offset);\n  }\n\n  return {\n    predicate: \"\".concat(condition.field, \" \").concat(condition.appended.operator, \" \").concat(condition.value),\n    params: condition.params\n  };\n};\n/**\n * Generate a predicate for a document query.\n *\n * @param {Object} condition - A condition object (generated by parseKey).\n * @param {String} key - The key corresponding to condition in criteria.\n * @param {Array} criteria - The full criteria object for this WHERE clause.\n * @return {Object} A predicate object.\n */\n\n\nconst docGenerator = function (condition, key, criteria) {\n  // case to check if key exist or not\n  if (condition.appended.operator === 'IS' || condition.appended.operator === 'IS NOT') {\n    condition.rawField = \"(\\\"body\\\" ->> '\".concat(condition.rawField, \"')\");\n  } else if (_.isArray(condition.value) && _.isPlainObject(condition.value[0])) {\n    // if we have an array of objects, this is a deep traversal\n    // we'll need to use a contains query to be sure we flex the index\n    condition.rawField = '\"body\"';\n    condition.appended.operator = '@>'; // only the array of objects matters when we're matching a nested\n    // structure, other keys in criteria must be handled separately\n\n    condition.params.push(JSON.stringify(_.pick(criteria, [key])));\n    condition.value = \"$\".concat(condition.offset);\n  } else if (condition.appended.operator === '=' && condition.elements.length === 0 && !_.isArray(condition.value)) {\n    // if we have equality here and no traversal, just use a JSON contains\n    const param = {};\n    param[condition.rawField] = condition.value;\n    condition.params.push(JSON.stringify(param));\n    condition.rawField = '\"body\"';\n    condition.appended.operator = '@>';\n    condition.value = \"$\".concat(condition.offset);\n  } else {\n    // we're querying a key on the document body!\n    // first build the full path; because the rawField is actually the\n    // outermost JSON key, prepend it to the rest of the elements.\n    const elements = condition.elements.slice();\n    elements.unshift(condition.rawField);\n    let cast = ''; // comparison stuff - same as method above but this time\n    // we'll be coercing the document key values using pg's ::\n    // not ideal, but it works nicely\n\n    if (_.isBoolean(condition.value)) {\n      cast = '::boolean';\n    } else if (_.isNumber(condition.value)) {\n      cast = '::decimal';\n    } else if (_.isDate(condition.value)) {\n      cast = '::timestamptz';\n      condition.params.push(condition.value);\n      condition.value = \"$\".concat(condition.offset);\n    } else if (condition.appended.mutator) {\n      condition = condition.appended.mutator(condition);\n    } else {\n      condition.params.push(condition.value);\n      condition.value = \"$\".concat(condition.offset);\n    }\n\n    if (elements.length === 1) {\n      condition.rawField = \"(\\\"body\\\" ->> '\".concat(elements[0], \"')\").concat(cast);\n    } else {\n      condition.rawField = \"(\\\"body\\\" #>> '{\".concat(elements.join(','), \"}')\").concat(cast);\n    }\n  }\n\n  return {\n    predicate: \"\".concat(condition.rawField, \" \").concat(condition.appended.operator, \" \").concat(condition.value),\n    params: condition.params\n  };\n};\n/**\n * Build a disjunction (logical OR).\n *\n * @param {Array} conditions - An array of nested criteria objects. Individual\n * objects will be arrayified (so an 'or' key can work with a single object).\n * @param {Number} offset - Offset prepared statement parameter ordinals.\n * @param {Function} generator - Generator function to use to build SQL\n * predicates.\n * @return {Object} A disjunction node.\n */\n\n\nconst generateDisjunction = (conditions, offset, generator) => {\n  return _.reduce(conditions, (disjunction, subconditions) => {\n    // each member of an 'or' array is itself a conjunction, so build it and\n    // integrate it into the disjunction predicate structure\n\n    /* eslint-disable no-use-before-define */\n    const conjunction = generateConjunction(subconditions, disjunction.offset + disjunction.params.length, generator);\n    /* eslint-enable no-use-before-define */\n\n    disjunction.params = disjunction.params.concat(conjunction.params);\n    disjunction.predicates.push(\"(\".concat(conjunction.predicates.join(' AND '), \")\"));\n    return disjunction;\n  }, {\n    params: [],\n    predicates: [],\n    offset\n  });\n};\n/**\n * Build an inner conjunction (logical OR).\n *\n * @param {Array} conditions - An array of nested criteria objects. Individual\n * objects will be arrayified (so an 'and' key can work with a single object).\n * @param {Number} offset - Offset prepared statement parameter ordinals.\n * @param {Function} generator - Generator function to use to build SQL\n * predicates.\n * @return {Object} A nested conjunction node.\n */\n\n\nconst generateInnerConjunction = (conditions, offset, generator) => {\n  return _.reduce(conditions, (conjunction, subconditions) => {\n    // each member of an 'and' array is itself a conjunction, so build it and\n    // integrate it into the conjunction predicate structure\n\n    /* eslint-disable no-use-before-define */\n    const innerConjunction = generateConjunction(subconditions, conjunction.offset + conjunction.params.length, generator);\n    /* eslint-enable no-use-before-define */\n\n    conjunction.params = conjunction.params.concat(innerConjunction.params);\n    conjunction.predicates.push(\"(\".concat(innerConjunction.predicates.join(' AND '), \")\"));\n    return conjunction;\n  }, {\n    params: [],\n    predicates: [],\n    offset\n  });\n};\n/**\n * Build a conjunction (logical AND).\n *\n * @param {Object} criteria - A criteria object.\n * @param {Number} offset - Offset prepared statement parameter ordinals\n * @param {Function} generator - Generator function to use to build SQL\n * predicates.\n * @return {Object} A conjunction node.\n */\n\n\nconst generateConjunction = (criteria, offset, generator) => {\n  return _.reduce(criteria, (conjunction, value, key) => {\n    if (key === 'or') {\n      const disjunction = generateDisjunction(value, conjunction.offset + conjunction.params.length, generator);\n      conjunction.params = conjunction.params.concat(disjunction.params);\n      conjunction.predicates.push(\"(\".concat(disjunction.predicates.join(' OR '), \")\"));\n      return conjunction;\n    } else if (key === 'and') {\n      const inner_conjunction = generateInnerConjunction(value, conjunction.offset + conjunction.params.length, generator);\n      conjunction.params = conjunction.params.concat(inner_conjunction.params);\n      conjunction.predicates.push(\"(\".concat(inner_conjunction.predicates.join(' AND '), \")\"));\n      return conjunction;\n    }\n\n    const condition = parseKey(key, ops);\n\n    if (!!value && condition.isJSON) {\n      if (_.isArray(value)) {\n        condition.value = value.map(v => v.toString());\n      } else {\n        condition.value = value.toString();\n      }\n    } else {\n      condition.value = value;\n    }\n\n    condition.offset = conjunction.offset + conjunction.params.length + 1;\n    condition.params = [];\n    const result = exports[generator](condition, key, criteria);\n    conjunction.predicates.push(result.predicate);\n\n    if (result.params) {\n      conjunction.params = conjunction.params.concat(result.params);\n    }\n\n    return conjunction;\n  }, {\n    params: [],\n    predicates: [],\n    offset: offset || 0\n  });\n};\n/**\n * Query conditions generator.\n *\n * @param {Object} criteria - Query criteria mapping column names (optionally\n * including operation eg 'my_field <>') to the parameter values. Predicates\n * generated from a criteria object are joined together with `and`; an `or` key\n * denotes an array of nested criteria objects, the collected predicates from\n * each of which are parenthesized and joined with `or`.\n * @param {Number} [offset=0] - Added to the token index value in the prepared\n * statement (with offset 0, parameters will start $1, $2, $3).\n * @param {String} [generator=generator] - Generator functions mutate the SQL\n * output.\n *\n * @return {Object} An object representing the query conditions. The\n * `conditions` field contains the final SQL string, the `params` field the\n * parameters for the prepared statement, and the `predicates` field the raw\n * predicate mapping.\n */\n\n\nexports = module.exports = function where(criteria, offset = 0, generator = 'tableGenerator') {\n  if (_.isPlainObject(criteria) && _.isEmpty(criteria)) {\n    return {\n      conditions: 'TRUE',\n      params: []\n    };\n  }\n\n  if (Object.prototype.hasOwnProperty.call(criteria, 'conditions') && Object.prototype.hasOwnProperty.call(criteria, 'params')) {\n    // this is a pre-built predicate coming from full-text search or\n    // Readable.where\n    //\n    // searchDoc can override the default generator (filter in columns, then\n    // text search against the body) but if there isn't a nestedGenerator\n    // passed then defer to the original\n    if (_.isPlainObject(criteria.params)) {\n      // where() with named parameters\n      return {\n        conditions: criteria.conditions,\n        params: criteria.params\n      };\n    }\n\n    if (_.isPlainObject(criteria.where) && !_.isEmpty(criteria.where)) {\n      const subWhere = where(criteria.where || {}, criteria.params.length, criteria.nestedGenerator || generator);\n      return {\n        conditions: \"\".concat(criteria.conditions, \" AND \").concat(subWhere.conditions),\n        params: criteria.params.concat(subWhere.params)\n      };\n    }\n\n    return {\n      conditions: criteria.conditions,\n      params: criteria.params\n    };\n  }\n\n  const conjunction = generateConjunction(criteria, offset, generator);\n  return {\n    conditions: conjunction.predicates.join(' AND '),\n    params: conjunction.params\n  };\n};\n\nexports.tableGenerator = tableGenerator;\nexports.docGenerator = docGenerator;","map":null,"metadata":{},"sourceType":"script"}