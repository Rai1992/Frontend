{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n'use strict';\n\nconst npm = {\n  assertOptions: require('assert-options'),\n  pgUtils: require('pg/lib/utils'),\n  patterns: require('./patterns'),\n  utils: require('./utils')\n}; // Format Modification Flags;\n\nconst fmFlags = {\n  raw: 1,\n  // Raw-Text variable\n  alias: 2,\n  // SQL Alias\n  name: 4,\n  // SQL Name/Identifier\n  json: 8,\n  // JSON modifier\n  csv: 16,\n  // CSV modifier\n  value: 32 // escaped, but without ''\n\n}; // Format Modification Map;\n\nconst fmMap = {\n  '^': fmFlags.raw,\n  ':raw': fmFlags.raw,\n  ':alias': fmFlags.alias,\n  '~': fmFlags.name,\n  ':name': fmFlags.name,\n  ':json': fmFlags.json,\n  ':csv': fmFlags.csv,\n  ':list': fmFlags.csv,\n  ':value': fmFlags.value,\n  '#': fmFlags.value\n}; // Global symbols for Custom Type Formatting:\n\nconst ctfSymbols = {\n  toPostgres: Symbol.for('ctf.toPostgres'),\n  rawType: Symbol.for('ctf.rawType')\n};\nObject.freeze(ctfSymbols);\nconst maxVariable = 100000; // maximum supported variable is '$100000'\n////////////////////////////////////////////////////\n// Converts a single value into its Postgres format.\n\nfunction formatValue(value, fm, cc) {\n  if (typeof value === 'function') {\n    return formatValue(resolveFunc(value, cc), fm, cc);\n  }\n\n  const ctf = getCTF(value); // Custom Type Formatting\n\n  if (ctf) {\n    fm |= ctf.rawType ? fmFlags.raw : 0;\n    return formatValue(resolveFunc(ctf.toPostgres, value), fm, cc);\n  }\n\n  const isRaw = !!(fm & fmFlags.raw);\n  fm &= ~fmFlags.raw;\n\n  switch (fm) {\n    case fmFlags.alias:\n      return $as.alias(value);\n\n    case fmFlags.name:\n      return $as.name(value);\n\n    case fmFlags.json:\n      return $as.json(value, isRaw);\n\n    case fmFlags.csv:\n      return $as.csv(value);\n\n    case fmFlags.value:\n      return $as.value(value);\n\n    default:\n      break;\n  }\n\n  if (isNull(value)) {\n    throwIfRaw(isRaw);\n    return 'null';\n  }\n\n  switch (typeof value) {\n    case 'string':\n      return $to.text(value, isRaw);\n\n    case 'boolean':\n      return $to.bool(value);\n\n    case 'number':\n      return $to.number(value);\n\n    case 'symbol':\n      throw new TypeError('Type Symbol has no meaning for PostgreSQL: ' + value.toString());\n\n    default:\n      if (value instanceof Date) {\n        return $to.date(value, isRaw);\n      }\n\n      if (value instanceof Array) {\n        return $to.array(value);\n      }\n\n      if (value instanceof Buffer) {\n        return $to.buffer(value, isRaw);\n      }\n\n      return $to.json(value, isRaw);\n  }\n} ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Converts array of values into PostgreSQL Array Constructor: array[...], as per PostgreSQL documentation:\n// http://www.postgresql.org/docs/9.6/static/arrays.html\n//\n// Arrays of any depth/dimension are supported.\n//\n// Top-level empty arrays are formatted as literal '{}' to avoid the necessity of explicit type casting,\n// as the server cannot automatically infer type of an empty non-literal array.\n\n\nfunction formatArray(array) {\n  const loop = a => '[' + a.map(v => v instanceof Array ? loop(v) : formatValue(v)).join() + ']';\n\n  return array.length ? 'array' + loop(array) : '\\'{}\\'';\n} ///////////////////////////////////////////////////////////////////\n// Formats array/object/value as a list of comma-separated values.\n\n\nfunction formatCSV(values) {\n  if (values instanceof Array) {\n    return values.map(v => formatValue(v)).join();\n  }\n\n  if (typeof values === 'object' && values !== null) {\n    return Object.keys(values).map(v => formatValue(values[v])).join();\n  }\n\n  return values === undefined ? '' : formatValue(values);\n} ///////////////////////////////\n// Query formatting helpers;\n\n\nconst formatAs = {\n  object(query, obj, raw, options) {\n    options = options && typeof options === 'object' ? options : {};\n    return query.replace(npm.patterns.namedParameters, name => {\n      const v = formatAs.stripName(name.replace(/^\\$[{(<[/]|[\\s})>\\]/]/g, ''), raw),\n            c = npm.utils.getIfHas(obj, v.name);\n\n      if (!c.valid) {\n        throw new Error('Invalid property name \\'' + v.name + '\\'.');\n      }\n\n      if (c.has) {\n        return formatValue(c.value, v.fm, c.target);\n      }\n\n      if (v.name === 'this') {\n        return formatValue(obj, v.fm);\n      }\n\n      if ('def' in options) {\n        const d = options.def,\n              value = typeof d === 'function' ? d.call(obj, v.name, obj) : d;\n        return formatValue(value, v.fm, obj);\n      }\n\n      if (options.partial) {\n        return name;\n      } // property must exist as the object's own or inherited;\n\n\n      throw new Error('Property \\'' + v.name + '\\' doesn\\'t exist.');\n    });\n  },\n\n  array(query, array, raw, options) {\n    options = options && typeof options === 'object' ? options : {};\n    return query.replace(npm.patterns.multipleValues, name => {\n      const v = formatAs.stripName(name.substr(1), raw);\n      const idx = v.name - 1;\n\n      if (idx >= maxVariable) {\n        throw new RangeError('Variable $' + v.name + ' exceeds supported maximum of $' + maxVariable);\n      }\n\n      if (idx < array.length) {\n        return formatValue(array[idx], v.fm);\n      }\n\n      if ('def' in options) {\n        const d = options.def,\n              value = typeof d === 'function' ? d.call(array, idx, array) : d;\n        return formatValue(value, v.fm);\n      }\n\n      if (options.partial) {\n        return name;\n      }\n\n      throw new RangeError('Variable $' + v.name + ' out of range. Parameters array length: ' + array.length);\n    });\n  },\n\n  value(query, value, raw) {\n    return query.replace(npm.patterns.singleValue, name => {\n      const v = formatAs.stripName(name, raw);\n      return formatValue(value, v.fm);\n    });\n  },\n\n  stripName(name, raw) {\n    const mod = name.match(npm.patterns.hasValidModifier);\n\n    if (mod) {\n      return {\n        name: name.substr(0, mod.index),\n        fm: fmMap[mod[0]] | (raw ? fmFlags.raw : 0)\n      };\n    }\n\n    return {\n      name,\n      fm: raw ? fmFlags.raw : null\n    };\n  }\n\n}; ////////////////////////////////////////////\n// Simpler check for null/undefined;\n\nfunction isNull(value) {\n  return value === undefined || value === null;\n} //////////////////////////////////////////////////////////////////\n// Checks if the value supports Custom Type Formatting,\n// to return {toPostgres, rawType}, if it does, or null otherwise.\n\n\nfunction getCTF(value) {\n  if (!isNull(value)) {\n    let toPostgres = value[ctfSymbols.toPostgres],\n        rawType = !!value[ctfSymbols.rawType];\n\n    if (typeof toPostgres !== 'function') {\n      toPostgres = value.toPostgres;\n      rawType = !!value.rawType;\n    }\n\n    if (typeof toPostgres === 'function') {\n      if (toPostgres.constructor.name !== 'Function') {\n        throw new Error('CTF does not support asynchronous toPostgres functions.');\n      }\n\n      return {\n        toPostgres,\n        rawType\n      };\n    }\n  }\n\n  return null;\n} /////////////////////////////////////////\n// Wraps a text string in single quotes;\n\n\nfunction wrapText(text) {\n  return '\\'' + text + '\\'';\n} ////////////////////////////////////////////////\n// Replaces each single-quote symbol ' with two,\n// for compliance with PostgreSQL strings.\n\n\nfunction safeText(text) {\n  return text.replace(/'/g, '\\'\\'');\n} /////////////////////////////////////////////\n// Throws an exception, if flag 'raw' is set.\n\n\nfunction throwIfRaw(raw) {\n  if (raw) {\n    throw new TypeError('Values null/undefined cannot be used as raw text.');\n  }\n} /////////////////////////////////////////////////////////////////////////////\n// Recursively resolves parameter-function, with an optional Calling Context.\n\n\nfunction resolveFunc(value, cc) {\n  while (typeof value === 'function') {\n    if (value.constructor.name !== 'Function') {\n      // Constructor name for asynchronous functions have different names:\n      // - 'GeneratorFunction' for ES6 generators\n      // - 'AsyncFunction' for ES7 async functions\n      throw new Error('Cannot use asynchronous functions with query formatting.');\n    }\n\n    value = value.call(cc, cc);\n  }\n\n  return value;\n} ///////////////////////////////////////////////////////////////////////////////////\n// It implements two types of formatting, depending on the 'values' passed:\n//\n// 1. format '$1, $2, etc', when 'values' is of type string, boolean, number, date,\n//    function or null (or an array of the same types, plus undefined values);\n// 2. format $*propName*, when 'values' is an object (not null and not Date),\n//    and where * is any of the supported open-close pairs: {}, (), [], <>, //\n//\n\n\nfunction $formatQuery(query, values, raw, options) {\n  if (typeof query !== 'string') {\n    throw new TypeError('Parameter \\'query\\' must be a text string.');\n  }\n\n  const ctf = getCTF(values);\n\n  if (ctf) {\n    // Custom Type Formatting\n    return $formatQuery(query, resolveFunc(ctf.toPostgres, values), raw || ctf.rawType, options);\n  }\n\n  if (typeof values === 'object' && values !== null) {\n    if (values instanceof Array) {\n      // $1, $2,... formatting to be applied;\n      return formatAs.array(query, values, raw, options);\n    }\n\n    if (!(values instanceof Date || values instanceof Buffer)) {\n      // $*propName* formatting to be applied;\n      return formatAs.object(query, values, raw, options);\n    }\n  } // $1 formatting to be applied, if values != undefined;\n\n\n  return values === undefined ? query : formatAs.value(query, values, raw);\n} //////////////////////////////////////////////////////\n// Formats a standard PostgreSQL function call query;\n\n\nfunction $formatFunction(funcName, values, capSQL) {\n  const sql = capSQL ? 'SELECT * FROM ' : 'select * from ';\n  return sql + funcName + '(' + formatCSV(values) + ')';\n}\n\nfunction $formatSqlName(name) {\n  return '\"' + name.replace(/\"/g, '\"\"') + '\"';\n}\n/**\r\n * @namespace formatting\r\n * @description\r\n * Namespace for all query-formatting functions, available from `pgp.as` before and after initializing the library.\r\n *\r\n * @property {formatting.ctf} ctf\r\n * Namespace for symbols used by $[Custom Type Formatting].\r\n *\r\n * @property {function} alias\r\n * {@link formatting.alias alias} - formats an SQL alias.\r\n *\r\n * @property {function} name\r\n * {@link formatting.name name} - formats an SQL Name/Identifier.\r\n *\r\n * @property {function} text\r\n * {@link formatting.text text} - formats a text string.\r\n *\r\n * @property {function} number\r\n * {@link formatting.number number} - formats a number.\r\n *\r\n * @property {function} buffer\r\n * {@link formatting.buffer buffer} - formats a `Buffer` object.\r\n *\r\n * @property {function} value\r\n * {@link formatting.value value} - formats text as an open value.\r\n *\r\n * @property {function} json\r\n * {@link formatting.json json} - formats any value as JSON.\r\n *\r\n * @property {function} array\r\n * {@link formatting.array array} - formats an array of any depth.\r\n *\r\n * @property {function} csv\r\n * {@link formatting.csv csv} - formats an array as a list of comma-separated values.\r\n *\r\n * @property {function} func\r\n * {@link formatting.func func} - formats the value returned from a function.\r\n *\r\n * @property {function} format\r\n * {@link formatting.format format} - formats a query, according to parameters.\r\n *\r\n */\n\n\nconst $as = {\n  /**\r\n   * @namespace formatting.ctf\r\n   * @description\r\n   * Namespace for ES6 symbols used by $[Custom Type Formatting], available from `pgp.as.ctf` before and after initializing the library.\r\n   *\r\n   * It was added to avoid explicit/enumerable extension of types that need to be used as formatting parameters, to keep their type signature intact.\r\n   *\r\n   * @property {external:Symbol} toPostgres\r\n   * Property name for the $[Custom Type Formatting] callback function `toPostgres`.\r\n   *\r\n   * @property {external:Symbol} rawType\r\n   * Property name for the $[Custom Type Formatting] flag `rawType`.\r\n   *\r\n   * @example\r\n   * const ctf = pgp.as.ctf; // Custom Type Formatting symbols\r\n   *\r\n   * class MyType {\r\n   *     constructor() {\r\n   *         this[ctf.rawType] = true; // set it only when toPostgres returns a pre-formatted result\r\n   *     }\r\n   *\r\n   *     [ctf.toPostgres](self) {\r\n   *         // self = this\r\n   *\r\n   *         // return the custom/actual value here\r\n   *     }\r\n   * }\r\n   *\r\n   * const a = new MyType();\r\n   *\r\n   * const s = pgp.as.format('$1', a); // will be custom-formatted\r\n   */\n  ctf: ctfSymbols,\n\n  /**\r\n   * @method formatting.text\r\n   * @description\r\n   * Converts a value into PostgreSQL text presentation, escaped as required.\r\n   *\r\n   * Escaping the result means:\r\n   *  1. Every single-quote (apostrophe) is replaced with two\r\n   *  2. The resulting text is wrapped in apostrophes\r\n   *\r\n   * @param {value|function} value\r\n   * Value to be converted, or a function that returns the value.\r\n   *\r\n   * If the `value` resolves as `null` or `undefined`, while `raw`=`true`,\r\n   * it will throw {@link external:TypeError TypeError} = `Values null/undefined cannot be used as raw text.`\r\n   *\r\n   * @param {boolean} [raw=false]\r\n   * Indicates when not to escape the resulting text.\r\n   *\r\n   * @returns {string}\r\n   *\r\n   * - `null` string, if the `value` resolves as `null` or `undefined`\r\n   * - escaped result of `value.toString()`, if the `value` isn't a string\r\n   * - escaped string version, if `value` is a string.\r\n   *\r\n   *  The result is not escaped, if `raw` was passed in as `true`.\r\n   */\n  text(value, raw) {\n    value = resolveFunc(value);\n\n    if (isNull(value)) {\n      throwIfRaw(raw);\n      return 'null';\n    }\n\n    if (typeof value !== 'string') {\n      value = value.toString();\n    }\n\n    return $to.text(value, raw);\n  },\n\n  /**\r\n   * @method formatting.name\r\n   * @description\r\n   * Properly escapes an sql name or identifier, fixing double-quote symbols and wrapping the result in double quotes.\r\n   *\r\n   * Implements a safe way to format $[SQL Names] that neutralizes SQL Injection.\r\n   *\r\n   * When formatting a query, a variable makes use of this method via modifier `:name` or `~`. See method {@link formatting.format format}.\r\n   *\r\n   * @param {string|function|array|object} name\r\n   * SQL name or identifier, or a function that returns it.\r\n   *\r\n   * The name must be at least 1 character long.\r\n   *\r\n   * If `name` doesn't resolve into a non-empty string, it throws {@link external:TypeError TypeError} = `Invalid sql name: ...`\r\n   *\r\n   * If the `name` contains only a single `*` (trailing spaces are ignored), then `name` is returned exactly as is (unescaped).\r\n   *\r\n   * - If `name` is an Array, it is formatted as a comma-separated list of $[SQL Names]\r\n   * - If `name` is a non-Array object, its keys are formatted as a comma-separated list of $[SQL Names]\r\n   *\r\n   * Passing in an empty array/object will throw {@link external:Error Error} = `Cannot retrieve sql names from an empty array/object.`\r\n   *\r\n   * @returns {string}\r\n   * The SQL Name/Identifier, properly escaped for compliance with the PostgreSQL standard for $[SQL Names] and identifiers.\r\n   *\r\n   * @see\r\n   * {@link formatting.alias alias},\r\n   * {@link formatting.format format}\r\n   *\r\n   * @example\r\n   *\r\n   * // automatically list object properties as sql names:\r\n   * format('INSERT INTO table(${this~}) VALUES(${one}, ${two})', {\r\n   *     one: 1,\r\n   *     two: 2\r\n   * });\r\n   * //=> INSERT INTO table(\"one\",\"two\") VALUES(1, 2)\r\n   *\r\n   */\n  name(name) {\n    name = resolveFunc(name);\n\n    if (name) {\n      if (typeof name === 'string') {\n        return /^\\s*\\*(\\s*)$/.test(name) ? name : $formatSqlName(name);\n      }\n\n      if (typeof name === 'object') {\n        const keys = Array.isArray(name) ? name : Object.keys(name);\n\n        if (!keys.length) {\n          throw new Error('Cannot retrieve sql names from an empty array/object.');\n        }\n\n        return keys.map(value => {\n          if (!value || typeof value !== 'string') {\n            throw new Error('Invalid sql name: ' + JSON.stringify(value));\n          }\n\n          return $formatSqlName(value);\n        }).join();\n      }\n    }\n\n    throw new TypeError('Invalid sql name: ' + JSON.stringify(name));\n  },\n\n  /**\r\n   * @method formatting.alias\r\n   * @description\r\n   * Simpler (non-verbose) version of method {@link formatting.name name}, to handle only a regular string-identifier\r\n   * that's used as an SQL alias, i.e. it doesn't support `*` or an array/object of names, which in the context of\r\n   * an SQL alias would be incorrect.\r\n   *\r\n   * The surrounding double quotes are not added when the alias uses a simple syntax:\r\n   *  - it is a same-case single word, without spaces\r\n   *  - it can contain underscores, and can even start with them\r\n   *  - it can contain digits and `$`, but cannot start with those\r\n   *\r\n   * When formatting a query, a variable makes use of this method via modifier `:alias`. See method {@link formatting.format format}.\r\n   *\r\n   * @param {string|function} name\r\n   * SQL alias name, or a function that returns it.\r\n   *\r\n   * The name must be at least 1 character long.\r\n   *\r\n   * If `name` doesn't resolve into a non-empty string, it throws {@link external:TypeError TypeError} = `Invalid sql alias: ...`\r\n   *\r\n   * @returns {string}\r\n   * The SQL alias, properly escaped for compliance with the PostgreSQL standard for $[SQL Names] and identifiers.\r\n   *\r\n   * @see\r\n   * {@link formatting.name name},\r\n   * {@link formatting.format format}\r\n   *\r\n   */\n  alias(name) {\n    name = resolveFunc(name);\n\n    if (name && typeof name === 'string') {\n      const m = name.match(/^([a-z_][a-z0-9_$]*|[A-Z_][A-Z0-9_$]*)$/);\n\n      if (m && m[0] === name) {\n        return name;\n      }\n\n      return '\"' + name.replace(/\"/g, '\"\"') + '\"';\n    }\n\n    throw new TypeError('Invalid sql alias: ' + JSON.stringify(name));\n  },\n\n  /**\r\n   * @method formatting.value\r\n   * @description\r\n   * Represents an open value, one to be formatted according to its type, properly escaped, but without surrounding quotes for text types.\r\n   *\r\n   * When formatting a query, a variable makes use of this method via modifier `:value` or `#`. See method {@link formatting.format format}.\r\n   *\r\n   * @param {value|function} value\r\n   * Value to be converted, or a function that returns the value.\r\n   *\r\n   * If `value` resolves as `null` or `undefined`, it will throw {@link external:TypeError TypeError} = `Open values cannot be null or undefined.`\r\n   *\r\n   * @returns {string}\r\n   * Formatted and properly escaped string, but without surrounding quotes for text types.\r\n   *\r\n   * @see {@link formatting.format format}\r\n   *\r\n   */\n  value(value) {\n    value = resolveFunc(value);\n\n    if (isNull(value)) {\n      throw new TypeError('Open values cannot be null or undefined.');\n    }\n\n    return safeText(formatValue(value, fmFlags.raw));\n  },\n\n  /**\r\n   * @method formatting.buffer\r\n   * @description\r\n   * Converts an object of type `Buffer` into a hex string compatible with PostgreSQL type `bytea`.\r\n   *\r\n   * @param {Buffer|function} obj\r\n   * Object to be converted, or a function that returns one.\r\n   *\r\n   * @param {boolean} [raw=false]\r\n   * Indicates when not to wrap the resulting string in quotes.\r\n   *\r\n   * The generated hex string doesn't need to be escaped.\r\n   *\r\n   * @returns {string}\r\n   */\n  buffer(obj, raw) {\n    obj = resolveFunc(obj);\n\n    if (isNull(obj)) {\n      throwIfRaw(raw);\n      return 'null';\n    }\n\n    if (obj instanceof Buffer) {\n      return $to.buffer(obj, raw);\n    }\n\n    throw new TypeError(wrapText(obj) + ' is not a Buffer object.');\n  },\n\n  /**\r\n   * @method formatting.bool\r\n   * @description\r\n   * Converts a truthy value into PostgreSQL boolean presentation.\r\n   *\r\n   * @param {boolean|function} value\r\n   * Value to be converted, or a function that returns the value.\r\n   *\r\n   * @returns {string}\r\n   */\n  bool(value) {\n    value = resolveFunc(value);\n\n    if (isNull(value)) {\n      return 'null';\n    }\n\n    return $to.bool(value);\n  },\n\n  /**\r\n   * @method formatting.date\r\n   * @description\r\n   * Converts a `Date`-type value into PostgreSQL date/time presentation,\r\n   * wrapped in quotes (unless flag `raw` is set).\r\n   *\r\n   * @param {Date|function} d\r\n   * Date object to be converted, or a function that returns one.\r\n   *\r\n   * @param {boolean} [raw=false]\r\n   * Indicates when not to escape the value.\r\n   *\r\n   * @returns {string}\r\n   */\n  date(d, raw) {\n    d = resolveFunc(d);\n\n    if (isNull(d)) {\n      throwIfRaw(raw);\n      return 'null';\n    }\n\n    if (d instanceof Date) {\n      return $to.date(d, raw);\n    }\n\n    throw new TypeError(wrapText(d) + ' is not a Date object.');\n  },\n\n  /**\r\n   * @method formatting.number\r\n   * @description\r\n   * Converts a numeric value into its PostgreSQL number presentation,\r\n   * with support for special values `NaN`, `+Infinity` and `-Infinity`.\r\n   *\r\n   * @param {number|function} num\r\n   * Number to be converted, or a function that returns one.\r\n   *\r\n   * @returns {string}\r\n   */\n  number(num) {\n    num = resolveFunc(num);\n\n    if (isNull(num)) {\n      return 'null';\n    }\n\n    if (typeof num !== 'number') {\n      throw new TypeError(wrapText(num) + ' is not a number.');\n    }\n\n    return $to.number(num);\n  },\n\n  /**\r\n   * @method formatting.array\r\n   * @description\r\n   * Converts an array of values into its PostgreSQL presentation as an Array-Type constructor string: `array[]`.\r\n   *\r\n   * Top-level empty arrays are formatted as literal `{}`, to avoid the necessity of explicit type casting,\r\n   * as the server cannot automatically infer type of an empty non-literal array.\r\n   *\r\n   * @param {Array|function} arr\r\n   * Array to be converted, or a function that returns one.\r\n   *\r\n   * @returns {string}\r\n   */\n  array(arr) {\n    arr = resolveFunc(arr);\n\n    if (isNull(arr)) {\n      return 'null';\n    }\n\n    if (arr instanceof Array) {\n      return $to.array(arr);\n    }\n\n    throw new TypeError(wrapText(arr) + ' is not an Array object.');\n  },\n\n  /**\r\n   * @method formatting.csv\r\n   * @description\r\n   * Converts a single value or an array of values into a CSV (comma-separated values) string, with all values formatted\r\n   * according to their JavaScript type.\r\n   *\r\n   * When formatting a query, a variable makes use of this method via modifier `:csv`, with alias `:list` supported from v7.5.1\r\n   *\r\n   * When `values` is an object that's not `null` or `Array`, its properties are enumerated for the actual values.\r\n   *\r\n   * @param {Array|Object|value|function} values\r\n   * Value(s) to be converted, or a function that returns it.\r\n   *\r\n   * @returns {string}\r\n   *\r\n   * @see {@link formatting.format format}\r\n   */\n  csv(values) {\n    return formatCSV(resolveFunc(values));\n  },\n\n  /**\r\n   * @method formatting.json\r\n   * @description\r\n   * Converts any value into JSON (using `JSON.stringify`), and returns it as a valid string, with single-quote\r\n   * symbols fixed, unless flag `raw` is set.\r\n   *\r\n   * When formatting a query, a variable makes use of this method via modifier `:json`. See method {@link formatting.format format}.\r\n   *\r\n   * @param {*} data\r\n   * Object/value to be converted, or a function that returns it.\r\n   *\r\n   * @param {boolean} [raw=false]\r\n   * Indicates when not to escape the result.\r\n   *\r\n   * @returns {string}\r\n   *\r\n   * @see {@link formatting.format format}\r\n   */\n  json(data, raw) {\n    data = resolveFunc(data);\n\n    if (isNull(data)) {\n      throwIfRaw(raw);\n      return 'null';\n    }\n\n    return $to.json(data, raw);\n  },\n\n  /**\r\n   * @method formatting.func\r\n   * @description\r\n   * Calls the function to get the actual value, and then formats the result\r\n   * according to its type + `raw` flag.\r\n   *\r\n   * @param {function} func\r\n   * Function to be called, with support for nesting.\r\n   *\r\n   * @param {boolean} [raw=false]\r\n   * Indicates when not to escape the result.\r\n   *\r\n   * @param {*} [cc]\r\n   * Calling Context: `this` + the only value to be passed into the function on all nested levels.\r\n   *\r\n   * @returns {string}\r\n   */\n  func(func, raw, cc) {\n    if (isNull(func)) {\n      throwIfRaw(raw);\n      return 'null';\n    }\n\n    if (typeof func !== 'function') {\n      throw new TypeError(wrapText(func) + ' is not a function.');\n    }\n\n    const fm = raw ? fmFlags.raw : null;\n    return formatValue(resolveFunc(func, cc), fm, cc);\n  },\n\n  /**\r\n   * @method formatting.format\r\n   * @description\r\n   * Replaces variables in a string according to the type of `values`:\r\n   *\r\n   * - Replaces `$1` occurrences when `values` is of type `string`, `boolean`, `number`, `Date`, `Buffer` or when it is `null`.\r\n   *\r\n   * - Replaces variables `$1`, `$2`, ...`$100000` when `values` is an array of parameters. It throws a {@link external:RangeError RangeError}\r\n   * when the values or variables are out of range.\r\n   *\r\n   * - Replaces `$*propName*`, where `*` is any of `{}`, `()`, `[]`, `<>`, `//`, when `values` is an object that's not a\r\n   * `Date`, `Buffer`, {@link QueryFile} or `null`. Special property name `this` refers to the formatting object itself,\r\n   *   to be injected as a JSON string. When referencing a property that doesn't exist in the formatting object, it throws\r\n   *   {@link external:Error Error} = `Property 'PropName' doesn't exist`, unless option `partial` is used.\r\n   *\r\n   * - Supports $[Nested Named Parameters] of any depth.\r\n   *\r\n   * By default, each variable is automatically formatted according to its type, unless it is a special variable:\r\n   *\r\n   * - Raw-text variables end with `:raw` or symbol `^`, and prevent escaping the text. Such variables are not\r\n   *   allowed to be `null` or `undefined`, or the method will throw {@link external:TypeError TypeError} = `Values null/undefined cannot be used as raw text.`\r\n   *   - `$1:raw`, `$2:raw`,..., and `$*propName:raw*` (see `*` above)\r\n   *   - `$1^`, `$2^`,..., and `$*propName^*` (see `*` above)\r\n   *\r\n   * - Open-value variables end with `:value` or symbol `#`, to be escaped, but not wrapped in quotes. Such variables are\r\n   *   not allowed to be `null` or `undefined`, or the method will throw {@link external:TypeError TypeError} = `Open values cannot be null or undefined.`\r\n   *   - `$1:value`, `$2:value`,..., and `$*propName:value*` (see `*` above)\r\n   *   - `$1#`, `$2#`,..., and `$*propName#*` (see `*` above)\r\n   *\r\n   * - SQL name variables end with `:name` or symbol `~` (tilde), and provide proper escaping for SQL names/identifiers:\r\n   *   - `$1:name`, `$2:name`,..., and `$*propName:name*` (see `*` above)\r\n   *   - `$1~`, `$2~`,..., and `$*propName~*` (see `*` above)\r\n   *\r\n   * - Modifier `:alias` - non-verbose $[SQL Names] escaping.\r\n   *\r\n   * - JSON override ends with `:json` to format the value of any type as a JSON string\r\n   *\r\n   * - CSV override ends with `:csv` or `:list` to format an array as a properly escaped comma-separated list of values.\r\n   *\r\n   * @param {string|QueryFile|object} query\r\n   * A query string, a {@link QueryFile} or any object that implements $[Custom Type Formatting], to be formatted according to `values`.\r\n   *\r\n   * @param {array|object|value} [values]\r\n   * Formatting parameter(s) / variable value(s).\r\n   *\r\n   * @param {object} [options]\r\n   * Formatting Options.\r\n   *\r\n   * @param {boolean} [options.partial=false]\r\n   * Indicates that we intend to do only a partial replacement, i.e. throw no error when encountering a variable or\r\n   * property name that's missing within the formatting parameters.\r\n   *\r\n   * **NOTE:** This option has no meaning when option `def` is used.\r\n   *\r\n   * @param {*} [options.def]\r\n   * Sets default value for every variable that's missing, consequently preventing errors when encountering a variable\r\n   * or property name that's missing within the formatting parameters.\r\n   *\r\n   * It can also be set to a function, to be called with two parameters that depend on the type of formatting being used,\r\n   * and to return the actual default value:\r\n   *\r\n   * - For $[Named Parameters] formatting:\r\n   *   - `name` - name of the property missing in the formatting object\r\n   *   - `obj` - the formatting object, and is the same as `this` context\r\n   *\r\n   * - For $[Index Variables] formatting:\r\n   *   - `index` - element's index (starts with 1) that's outside of the input array\r\n   *   - `arr` - the formatting/input array, and is the same as `this` context\r\n   *\r\n   *   You can tell which type of call it is by checking the type of the first parameter.\r\n   *\r\n   * @returns {string}\r\n   * Formatted query string.\r\n   *\r\n   * The function will throw an error, if any occurs during formatting.\r\n   */\n  format(query, values, options) {\n    options = npm.assertOptions(options, ['partial', 'def']);\n    const ctf = getCTF(query);\n\n    if (ctf) {\n      query = ctf.toPostgres.call(query, query);\n    }\n\n    return $formatQuery(query, values, false, options);\n  }\n\n};\n/* Pre-parsed type formatting */\n\nconst $to = {\n  array(arr) {\n    return formatArray(arr);\n  },\n\n  bool(value) {\n    return value ? 'true' : 'false';\n  },\n\n  buffer(obj, raw) {\n    const s = '\\\\x' + obj.toString('hex');\n    return raw ? s : wrapText(s);\n  },\n\n  date(d, raw) {\n    const s = npm.pgUtils.prepareValue(d);\n    return raw ? s : wrapText(s);\n  },\n\n  json(data, raw) {\n    const s = JSON.stringify(data);\n    return raw ? s : wrapText(safeText(s));\n  },\n\n  number(num) {\n    if (Number.isFinite(num)) {\n      return num.toString();\n    } // Converting NaN/+Infinity/-Infinity according to Postgres documentation:\n    // http://www.postgresql.org/docs/9.6/static/datatype-numeric.html#DATATYPE-FLOAT\n    //\n    // NOTE: strings for 'NaN'/'+Infinity'/'-Infinity' are not case-sensitive.\n\n\n    if (num === Number.POSITIVE_INFINITY) {\n      return wrapText('+Infinity');\n    }\n\n    if (num === Number.NEGATIVE_INFINITY) {\n      return wrapText('-Infinity');\n    }\n\n    return wrapText('NaN');\n  },\n\n  text(value, raw) {\n    return raw ? value : wrapText(safeText(value));\n  }\n\n};\nObject.freeze($as);\nmodule.exports = {\n  formatQuery: $formatQuery,\n  formatFunction: $formatFunction,\n  resolveFunc,\n  as: $as\n};\n/**\r\n * @external Error\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\r\n */\n\n/**\r\n * @external TypeError\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\r\n */\n\n/**\r\n * @external RangeError\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError\r\n */\n\n/**\r\n * @external Symbol\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\r\n */","map":null,"metadata":{},"sourceType":"script"}