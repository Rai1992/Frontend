{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst util = require('util');\n\nconst Readable = require('./readable');\n\nconst Delete = require('./statement/delete');\n\nconst Insert = require('./statement/insert');\n\nconst Update = require('./statement/update');\n\nconst where = require('./statement/where');\n/**\n * A database table or other writable object.\n *\n * @class\n * @extends Entity\n * @extends Readable\n * @param {Object} spec - An {@linkcode Entity} specification representing a table:\n * @param {Object} spec.db - A {@linkcode Database}.\n * @param {String} spec.name - The table or view's name.\n * @param {String} spec.schema - The name of the schema owning the table.\n * @param {String} spec.pk - The table's primary key column.\n */\n\n\nconst Writable = function (spec) {\n  Readable.apply(this, arguments);\n  this.pk = spec.pk;\n  this.columns = spec.columns;\n  this.insertable = spec.is_insertable_into || true;\n};\n\nutil.inherits(Writable, Readable);\n/**\n * Attempts to assemble primary key criteria for a record object representing a\n * row in this table. The criteria must include the full primary key, and must\n * not invoke any operations.\n *\n * @param {Object} record - The record to evaluate.\n * @return {Object} The successfully assembled criteria, or null if primary key\n * information is incomplete or invalid.\n */\n\nWritable.prototype.getPkCriteria = function (record) {\n  let missing = false;\n  const criteria = this.pk.reduce((obj, pkColumn) => {\n    if (Object.prototype.hasOwnProperty.call(record, pkColumn)) {\n      obj[pkColumn] = record[pkColumn];\n    } else {\n      missing = true;\n    }\n\n    return obj;\n  }, {});\n  return missing ? null : criteria;\n};\n/**\n * Insert a record or records into the table.\n *\n * @param {Object|Array} data - A record or records to insert.\n * @param {Object} [options] - {@link https://massivejs.org/docs/options-objects|Insert options}.\n * @return {Promise} If passed a record object, the record as inserted (with\n * default or autogenerated values set); if passed an array, an array\n * containing the inserted records.\n */\n\n\nWritable.prototype.insert = function (data, options) {\n  if (!this.insertable) {\n    return this.db.$p.reject(new Error(\"\".concat(this.name, \" is not writable\")));\n  } else if (!data) {\n    return this.db.$p.reject(new Error('Must provide data to insert'));\n  }\n\n  const insert = new Insert(this, data, options);\n\n  if (insert.params.length === 0) {\n    // just return empty arrays so bulk inserting variable-length lists is more friendly\n    return this.db.$p.resolve([]);\n  }\n\n  return this.db.query(insert);\n};\n/**\n * Update a record with a criteria object and a map of changed fields to their\n * new values.\n *\n * @param {String|Number|Object} criteria - Primary key of the record, or a\n * criteria object.\n * @param {Object} changes - A map of columns to their new values.\n * @param {Object} [options] - {@link https://massivejs.org/docs/options-objects|Update options}.\n * @return {Promise} If updating a single record by its primary key, the\n * modified record; otherwise, an array containing any modified records.\n */\n\n\nWritable.prototype.update = function (criteria, changes, options = {}) {\n  if (!this.insertable) {\n    return this.db.$p.reject(new Error(\"\".concat(this.name, \" is not writable\")));\n  } else if (!_.isObjectLike(changes) || _.isArray(changes)) {\n    return this.db.$p.reject(new Error('Update requires a hash of fields=>values to update to'));\n  } else if (_.isEmpty(changes)) {\n    // there's nothing to update, so just return the matching records\n    return this.find(criteria, options);\n  }\n\n  const update = new Update(this, changes, criteria, options);\n  return this.db.query(update);\n};\n/**\n * Saves an object. If the object does not include a value for the table's\n * primary key, this will emit an INSERT to create a new record; if it does\n * contain the primary key it will emit an UPDATE for the existing record.\n *\n * Either way, the newest available version of the record will be returned.\n *\n * This is not a true Postgres upsert! If you need the behavior of ON CONFLICT\n * DO UPDATE, you'll need to use db.query or create an SQL script file.\n *\n * @param {Object} record - The record to upsert.\n * @param {Object} [options] - {@link https://massivejs.org/docs/options-objects|Insert/update options}.\n * @return {Promise} The inserted or updated record object.\n */\n\n\nWritable.prototype.save = function (record, options = {}) {\n  if (!this.pk) {\n    return this.db.$p.reject(new Error(\"\".concat(this.name, \" has no primary key, use insert or update to write to this table\")));\n  } else if (!_.isObjectLike(record) || _.isArray(record)) {\n    return this.db.$p.reject(new Error('Must provide an object with all fields being modified and the primary key if updating'));\n  }\n\n  const keys = _.keys(record);\n\n  if (_.intersection(keys, this.pk).length === this.pk.length) {\n    const criteria = this.getPkCriteria(record);\n    record = _.omitBy(record, (value, key) => {\n      return _.isFunction(record[key]) || this.pk.indexOf(key) > -1;\n    });\n    options.single = true; // prevent options from being read as changes in the bulk update format\n\n    return this.update(criteria, record, options);\n  }\n\n  return this.insert.apply(this, arguments);\n};\n/**\n * Delete a record or records.\n *\n * @param {Object} criteria - A criteria object or primary key.\n * @param {Object} [options] - {@link https://massivejs.org/docs/options-objects|Delete options}.\n * @return {Promise} For a primary key, the deleted record; for a criteria\n * object, an array containing all deleted records.\n */\n\n\nWritable.prototype.destroy = function (criteria, options) {\n  return this.db.query(new Delete(this, criteria, options));\n};\n/**\n * Save a document to the database. This function will create or replace the\n * entire document body.\n *\n * @param {Object} doc - The document to persist.\n * @return {Promise} The updated document.\n */\n\n\nWritable.prototype.saveDoc = function (doc) {\n  if (!_.isObjectLike(doc) || _.isArray(doc)) {\n    return this.db.$p.reject(new Error('Please pass in the document for saving as an object. Include the primary key for an UPDATE.'));\n  }\n\n  const options = {\n    single: true,\n    document: true,\n    generator: 'docGenerator'\n  };\n  const criteria = this.getPkCriteria(doc);\n\n  if (criteria) {\n    const update = new Update(this, {\n      body: _.omit(doc, this.pk, 'created_at', 'updated_at')\n    }, criteria, options);\n    return this.db.query(update);\n  }\n\n  return this.db.query(new Insert(this, {\n    body: doc\n  }, options));\n};\n/**\n * Save documents to the database. This function will create or replace the\n * entire document body for each document.\n *\n * @param {Object} docs - The documents to persist.\n * @return {Promise} The updated documents.\n */\n\n\nWritable.prototype.saveDocs = function (docs) {\n  if (!_.isArray(docs)) {\n    return this.db.$p.reject(new Error('Please pass in the documents as an array of objects.'));\n  }\n\n  if (!docs.every(_.isObjectLike)) {\n    return this.db.$p.reject(new Error('Please pass in valid documents. Include the primary key for an UPDATE.'));\n  }\n\n  return this.db.$p.all(docs.map(this.saveDoc.bind(this)));\n};\n/**\n * Update a document, adding new information and changing existing information.\n * This function can be used with any JSON field, not just document tables;\n * however, only document tables can use criteria objects which directly\n * reference document fields.\n *\n * If calling updateDoc with a criteria object for a non-document table, the\n * criteria will be tested against the entire row (as opposed to the document\n * body as it is for document tables). To test elements of the JSON field in a\n * non-document table with a criteria object, use a JSON path string.\n *\n * @param {String|Number|Object} criteria - Primary key of the document, or a\n * criteria object.\n * @param {Object} changes - Changes to apply.\n * @param {Object} [options] - {@link https://massivejs.org/docs/options-objects|Update options}.\n * @param {String} [options.body] - Override the \"body\" JSON field to affect.\n * @return {Promise} If modifying a document table, the document; otherwise, the\n * modified row.\n */\n\n\nWritable.prototype.updateDoc = function (criteria, changes, options = {}) {\n  if (!Object.prototype.hasOwnProperty.call(options, 'body')) {\n    options.body = 'body';\n    options.document = true;\n  }\n\n  if (!_.isPlainObject(criteria)) {\n    // primitive criteria will always reference a unary primary key\n    criteria = _.fromPairs([[this.pk[0], criteria]]);\n    options.single = true;\n    options.generator = 'tableGenerator';\n  }\n\n  const queryCriteria = where(criteria, 1, options.generator || (options.document ? 'docGenerator' : 'tableGenerator'));\n  const sql = \"UPDATE \".concat(this.delimitedFullName, \" SET \\\"\").concat(options.body, \"\\\" = COALESCE(\\\"\").concat(options.body, \"\\\", '{}'::jsonb) || $1 WHERE \").concat(queryCriteria.conditions, \" RETURNING *;\");\n  return this.db.query(sql, [JSON.stringify(changes)].concat(queryCriteria.params), options);\n};\n\nmodule.exports = Writable;","map":null,"metadata":{},"sourceType":"script"}