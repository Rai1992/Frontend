{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n'use strict';\n\nconst npm = {\n  assertOptions: require('assert-options'),\n  fs: require('fs'),\n  os: require('os'),\n  path: require('path'),\n  con: require('manakin').local,\n  minify: require('pg-minify'),\n  utils: require('./utils'),\n  formatting: require('./formatting'),\n  QueryFileError: require('./errors/queryFile')\n};\n/**\r\n * @class QueryFile\r\n * @description\r\n *\r\n * Represents an external SQL file. The type is available from the library's root: `pgp.QueryFile`.\r\n *\r\n * Reads a file with SQL and prepares it for execution, also parses and minifies it, if required.\r\n * The SQL can be of any complexity, with both single and multi-line comments.\r\n *\r\n * The type can be used in place of the `query` parameter, with any query method directly, plus as `text` in {@link PreparedStatement}\r\n * and {@link ParameterizedQuery}.\r\n *\r\n * It never throws any error, leaving it for query methods to reject with {@link errors.QueryFileError QueryFileError}.\r\n *\r\n * **IMPORTANT:** You should only create a single reusable object per file, in order to avoid repeated file reads,\r\n * as the IO is a very expensive resource. If you do not follow it, you will be seeing the following warning:\r\n * `Creating a duplicate QueryFile object for the same file`, which signals a bad-use pattern.\r\n *\r\n * @param {string} file\r\n * Path to the SQL file with the query, either absolute or relative to the application's entry point file.\r\n *\r\n * If there is any problem reading the file, it will be reported when executing the query.\r\n *\r\n * @param {QueryFile.Options} [options]\r\n * Set of configuration options, as documented by {@link QueryFile.Options}.\r\n *\r\n * @returns {QueryFile}\r\n *\r\n * @see\r\n * {@link errors.QueryFileError QueryFileError},\r\n * {@link QueryFile#toPostgres toPostgres}\r\n *\r\n * @example\r\n * // File sql.js\r\n *\r\n * // Proper way to organize an sql provider:\r\n * //\r\n * // - have all sql files for Users in ./sql/users\r\n * // - have all sql files for Products in ./sql/products\r\n * // - have your sql provider module as ./sql/index.js\r\n *\r\n * const QueryFile = require('pg-promise').QueryFile;\r\n * const path = require('path');\r\n *\r\n * // Helper for linking to external query files:\r\n * function sql(file) {\r\n *     const fullPath = path.join(__dirname, file); // generating full path;\r\n *     return new QueryFile(fullPath, {minify: true});\r\n * }\r\n *\r\n * module.exports = {\r\n *     // external queries for Users:\r\n *     users: {\r\n *         add: sql('users/create.sql'),\r\n *         search: sql('users/search.sql'),\r\n *         report: sql('users/report.sql'),\r\n *     },\r\n *     // external queries for Products:\r\n *     products: {\r\n *         add: sql('products/add.sql'),\r\n *         quote: sql('products/quote.sql'),\r\n *         search: sql('products/search.sql'),\r\n *     }\r\n * };\r\n *\r\n * @example\r\n * // Testing our SQL provider\r\n *\r\n * const db = require('./db'); // our database module;\r\n * const sql = require('./sql').users; // our sql for users;\r\n *\r\n * module.exports = {\r\n *     addUser: (name, age) => db.none(sql.add, [name, age]),\r\n *     findUser: name => db.any(sql.search, name)\r\n * };\r\n *\r\n */\n\nfunction QueryFile(file, options) {\n  if (!(this instanceof QueryFile)) {\n    return new QueryFile(file, options);\n  }\n\n  let sql,\n      error,\n      ready,\n      modTime,\n      filePath = file;\n  const opt = npm.assertOptions(options, {\n    debug: npm.utils.isDev(),\n    minify: options && options.compress && options.minify === undefined ? true : undefined,\n    compress: undefined,\n    params: undefined,\n    noWarnings: undefined\n  });\n  Object.freeze(opt);\n\n  if (npm.utils.isText(filePath) && !npm.utils.isPathAbsolute(filePath)) {\n    filePath = npm.path.join(npm.utils.startDir, filePath);\n  } // istanbul ignore next:\n\n\n  if (!opt.noWarnings) {\n    if (filePath in usedPath) {\n      usedPath[filePath]++;\n      npm.con.warn('WARNING: Creating a duplicate QueryFile object for the same file - \\n    %s\\n%s\\n', filePath, npm.utils.getLocalStack(3));\n    } else {\n      usedPath[filePath] = 0;\n    }\n  }\n\n  this[npm.formatting.as.ctf.rawType] = true; // do not format the content when used as a formatting value\n\n  /**\r\n   * @method QueryFile#prepare\r\n   * @summary Prepares the query for execution.\r\n   * @description\r\n   * If the query hasn't been prepared yet, it will read the file and process the content according\r\n   * to the parameters passed into the constructor.\r\n   *\r\n   * This method is primarily for internal use by the library.\r\n   *\r\n   * @param {boolean} [throwErrors=false]\r\n   * Throw any error encountered.\r\n   *\r\n   */\n\n  this.prepare = function (throwErrors) {\n    let lastMod;\n\n    if (opt.debug && ready) {\n      try {\n        lastMod = npm.fs.statSync(filePath).mtime.getTime();\n\n        if (lastMod === modTime) {\n          // istanbul ignore next;\n          // coverage for this works differently under Windows and Linux\n          return;\n        }\n\n        ready = false;\n      } catch (e) {\n        sql = undefined;\n        ready = false;\n        error = e;\n\n        if (throwErrors) {\n          throw error;\n        }\n\n        return;\n      }\n    }\n\n    if (ready) {\n      return;\n    }\n\n    try {\n      sql = npm.fs.readFileSync(filePath, 'utf8');\n      modTime = lastMod || npm.fs.statSync(filePath).mtime.getTime();\n\n      if (opt.minify && opt.minify !== 'after') {\n        sql = npm.minify(sql, {\n          compress: opt.compress\n        });\n      }\n\n      if (opt.params !== undefined) {\n        sql = npm.formatting.as.format(sql, opt.params, {\n          partial: true\n        });\n      }\n\n      if (opt.minify && opt.minify === 'after') {\n        sql = npm.minify(sql, {\n          compress: opt.compress\n        });\n      }\n\n      ready = true;\n      error = undefined;\n    } catch (e) {\n      sql = undefined;\n      error = new npm.QueryFileError(e, this);\n\n      if (throwErrors) {\n        throw error;\n      }\n    }\n  };\n  /**\r\n   * @name QueryFile#Symbol(QueryFile.$query)\r\n   * @type {string}\r\n   * @default undefined\r\n   * @readonly\r\n   * @private\r\n   * @summary Prepared query string.\r\n   * @description\r\n   * When property {@link QueryFile#error error} is set, the query is `undefined`.\r\n   *\r\n   * **IMPORTANT:** This property is for internal use by the library only, never use this\r\n   * property directly from your code.\r\n   */\n\n\n  Object.defineProperty(this, QueryFile.$query, {\n    get() {\n      return sql;\n    }\n\n  });\n  /**\r\n   * @name QueryFile#error\r\n   * @type {errors.QueryFileError}\r\n   * @default undefined\r\n   * @readonly\r\n   * @description\r\n   * When in an error state, it is set to a {@link errors.QueryFileError QueryFileError} object. Otherwise, it is `undefined`.\r\n   */\n\n  Object.defineProperty(this, 'error', {\n    get() {\n      return error;\n    }\n\n  });\n  /**\r\n   * @name QueryFile#file\r\n   * @type {string}\r\n   * @readonly\r\n   * @description\r\n   * File name that was passed into the constructor.\r\n   *\r\n   * This property is primarily for internal use by the library.\r\n   */\n\n  Object.defineProperty(this, 'file', {\n    get() {\n      return file;\n    }\n\n  });\n  /**\r\n   * @name QueryFile#options\r\n   * @type {QueryFile.Options}\r\n   * @readonly\r\n   * @description\r\n   * Set of options, as configured during the object's construction.\r\n   *\r\n   * This property is primarily for internal use by the library.\r\n   */\n\n  Object.defineProperty(this, 'options', {\n    get() {\n      return opt;\n    }\n\n  });\n  this.prepare();\n} // Hiding the query as a symbol within the type,\n// to make it even more difficult to misuse it:\n\n\nQueryFile.$query = Symbol('QueryFile.query');\nconst usedPath = {};\n/**\r\n * @method QueryFile#toPostgres\r\n * @description\r\n * $[Custom Type Formatting], based on $[Symbolic CTF], i.e. the actual method is available only via {@link external:Symbol Symbol}:\r\n *\r\n * ```js\r\n * const ctf = pgp.as.ctf; // Custom Type Formatting symbols namespace\r\n * const query = qf[ctf.toPostgres]; // qf = an object of type QueryFile\r\n * ```\r\n *\r\n * This is a raw formatting type (`rawType = true`), i.e. when used as a query-formatting parameter, type `QueryFile` injects SQL as raw text.\r\n *\r\n * If you need to support type `QueryFile` outside of query methods, this is the only safe way to get the most current SQL.\r\n * And you would want to use this method dynamically, as it reloads the SQL automatically, if option `debug` is set.\r\n * See {@link QueryFile.Options Options}.\r\n *\r\n * @param {QueryFile} [self]\r\n * Optional self-reference, for ES6 arrow functions.\r\n *\r\n * @returns {string}\r\n * SQL string from the file, according to the {@link QueryFile.Options options} specified.\r\n *\r\n */\n\nQueryFile.prototype[npm.formatting.as.ctf.toPostgres] = function (self) {\n  self = this || self;\n  self.prepare(true);\n  return self[QueryFile.$query];\n};\n/**\r\n * @method QueryFile#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object's current state.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\n\n\nQueryFile.prototype.toString = function (level) {\n  level = level > 0 ? parseInt(level) : 0;\n  const gap = npm.utils.messageGap(level + 1);\n  const lines = ['QueryFile {'];\n  this.prepare();\n  lines.push(gap + 'file: \"' + this.file + '\"');\n  lines.push(gap + 'options: ' + JSON.stringify(this.options));\n\n  if (this.error) {\n    lines.push(gap + 'error: ' + this.error.toString(level + 1));\n  } else {\n    lines.push(gap + 'query: \"' + this[QueryFile.$query] + '\"');\n  }\n\n  lines.push(npm.utils.messageGap(level) + '}');\n  return lines.join(npm.os.EOL);\n};\n\nnpm.utils.addInspection(QueryFile, function () {\n  return this.toString();\n});\nmodule.exports = QueryFile;\n/**\r\n * @typedef QueryFile.Options\r\n * @description\r\n * A set of configuration options as passed into the {@link QueryFile} constructor.\r\n *\r\n * @property {boolean} debug\r\n * When in debug mode, the query file is checked for its last modification time on every query request,\r\n * so if it changes, the file is read afresh.\r\n *\r\n * The default for this property is `true` when `NODE_ENV` = `development`,\r\n * or `false` otherwise.\r\n *\r\n * @property {boolean|string} minify=false\r\n * Parses and minifies the SQL using $[pg-minify]:\r\n * - `false` - do not use $[pg-minify]\r\n * - `true` - use $[pg-minify] to parse and minify SQL\r\n * - `'after'` - use $[pg-minify] after applying static formatting parameters\r\n *   (option `params`), as opposed to before it (default)\r\n *\r\n * If option `compress` is set, then the default for `minify` is `true`.\r\n *\r\n * Failure to parse SQL will result in $[SQLParsingError].\r\n *\r\n * @property {boolean} compress=false\r\n * Sets option `compress` as supported by $[pg-minify], to uglify the SQL:\r\n * - `false` - no compression to be applied, keep minimum spaces for easier read\r\n * - `true` - remove all unnecessary spaces from SQL\r\n *\r\n * This option has no meaning, if `minify` is explicitly set to `false`. However, if `minify` is not\r\n * specified and `compress` is specified as `true`, then `minify` defaults to `true`.\r\n *\r\n * @property {array|object|value} params\r\n *\r\n * Static formatting parameters to be applied to the SQL, using the same method {@link formatting.format as.format},\r\n * but with option `partial` = `true`.\r\n *\r\n * Most of the time query formatting is fully dynamic, and applied just before executing the query.\r\n * In some cases though you may need to pre-format SQL with static values. Examples of it can be a\r\n * schema name, or a configurable table name.\r\n *\r\n * This option makes two-step SQL formatting easy: you can pre-format the SQL initially, and then\r\n * apply the second-step dynamic formatting when executing the query.\r\n *\r\n * @property {boolean} noWarnings=false\r\n * Suppresses all warnings produced by the class. It is not recommended for general use, only in specific tests\r\n * that may require it.\r\n *\r\n */","map":null,"metadata":{},"sourceType":"script"}