{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n/**\n * Collapses tabular result sets into a hierarchical object graph based on the\n * provided schema.\n *\n * @module util/decompose\n * @param {Object} schema - An object describing the shape of the output data.\n * Schema objects are nested to arbitrary depth, with a single top-level schema\n * describing the \"origin\" record format and containing other schemas which\n * describe descendant records.\n * @param {String} schema.pk - The name of a field in the result set which\n * uniquely identifies a single record.\n * @param {Object|Array} schema.columns - A map of field names in the result set\n * to keys of an output object, or an array of field names if no transformation\n * of names is desired.\n * @param {Boolean} schema.array - When true, entities built with this schema\n * are coerced into arrays of entities. This is only valid for nested schemas.\n * If an object described by this schema's parent schema does not contain any\n * records for this schema, an empty array will be generated.\n * @param {Object} schema.anythingElse - Nests a descendant schema under this\n * one.\n * @param {Array} data - Array of database records to decompose.\n * @return {Array} An array of nested objects generated by applying the schema\n * to each data element in turn.\n */\n\n\nexports = module.exports = function (schema, data) {\n  if (!data || data.length === 0) {\n    return [];\n  }\n\n  data = _.castArray(data);\n  /* Generate a nested dictionary of id:entity in the form of the final\n   * structure we're trying to build, effectively hashing ids to ensure we\n   * don't duplicate any entities in cases where multiple dependent tables are\n   * joined into the source query.\n    * Output: {1: {id: 1, name: 'hi', children: {111: {id: 111, name: 'ih'}}}\n   */\n\n  const mapping = data.reduce(function (acc, row) {\n    if (row[schema.pk] === null) {\n      throw new Error('Attempted to decompose a row where the root object has a null PK. This can happen if tables in your SELECT list share column names. Ensure that all columns are aliased uniquely and update your decomposition schema if necessary.');\n    }\n\n    return function build(obj, objSchema) {\n      const id = row[objSchema.pk]; // Use a string id instead of the (potentially numerical) row id as keys\n      // in the mapping. This prevents Object.keys from reordering the\n      // mapping in the \"transform\" step.\n\n      const strid = '_' + id;\n\n      if (id === null) {\n        // null id means this entity doesn't exist (eg outer join)\n        return undefined;\n      } else if (!Object.prototype.hasOwnProperty.call(obj, strid)) {\n        // this entity is new\n        obj[strid] = {};\n      }\n\n      let mapper;\n\n      if (_.isArray(objSchema.columns)) {\n        // columns is just a list of field names\n        mapper = val => obj[strid][val] = row[val];\n      } else {\n        // the columns object maps field names in the row to object key names\n        mapper = (val, key) => obj[strid][val] = row[key];\n      }\n\n      _.map(objSchema.columns, mapper);\n\n      Object.keys(objSchema).forEach(function (c) {\n        switch (c) {\n          case 'pk':\n          case 'columns':\n          case 'array':\n            break;\n\n          default:\n            {\n              const descendant = build(obj[strid][c] || {}, objSchema[c]);\n\n              if (descendant) {\n                obj[strid][c] = descendant;\n              } else if (objSchema[c].array) {\n                // we always want an array if there could be multiple descendants\n                obj[strid][c] = [];\n              }\n\n              break;\n            }\n        }\n      });\n      return obj;\n    }(acc, schema);\n  }, {});\n  /* Build the final graph. The structure and data already exists in mapping,\n   * but we need to transform the {id: entity} structures into arrays of\n   * entities (or flat objects if required).\n   *\n   * Output: [{id: 1, name: 'hi', children: [{id: 111, name: 'ih'}]}] */\n\n  return function transform(objSchema, map, output) {\n    // for every id:entity pair in the current level of mapping, if the schema\n    // defines any dependent entities recurse and transform them, then push the\n    // current object into the output and return\n    return Object.keys(map).reduce(function (acc, id) {\n      Object.keys(objSchema).filter(c => {\n        return c !== 'columns' && typeof objSchema[c] === 'object'; // just structure now\n      }).forEach(function (node) {\n        // we have to init & pass the accumulator into the *next* recursion\n        // since the single option is defined on the child rather than the\n        // parent\n        const accumulator = objSchema[node] && objSchema[node].array ? [] : {};\n\n        if (map[id][node]) {\n          map[id][node] = transform(objSchema[node], map[id][node], accumulator);\n        }\n      });\n\n      if (Array.isArray(output)) {\n        acc.push(map[id]);\n      } else {\n        acc = map[id];\n      }\n\n      return acc;\n    }, []);\n  }(schema, mapping, []);\n};","map":null,"metadata":{},"sourceType":"script"}