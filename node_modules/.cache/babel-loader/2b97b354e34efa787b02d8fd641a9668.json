{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst glob = require('glob');\n\nconst path = require('path');\n\nconst pgp = require('pg-promise');\n\nconst stream = require('stream');\n\nconst QueryStream = require('pg-query-stream');\n\nconst Executable = require('./executable');\n\nconst Readable = require('./readable');\n\nconst Writable = require('./writable');\n\nconst Sequence = require('./sequence');\n\nconst Entity = require('./entity');\n\nconst decompose = require('./util/decompose');\n\nconst docify = require('./util/docify');\n\nconst getFilterString = require('./util/get-filter-string');\n\nconst introspectors = {}; // store introspection scripts across reloads\n\n/**\n * A database connection.\n *\n * @class Database\n * @param {Object|String} connection - A pg connection object or a connection\n * string.\n * @param {Object} [loader] - Filter definition for including and\n * excluding database objects. If nothing is specified, Massive loads every\n * table, view, and function visible to the connection's user.\n * @param {String} [loader.scripts] - Override the Massive script file location\n * (default ./db).\n * @param {String} [loader.documentPkType] - Override default data type (serial),\n *  set for DocumentTable primary key 'id', e.g. 'uuid'\n * @param {String} [loader.uuidVersion] - If documentPkType is set to 'uuid', set which UUID version to use,\n *  e.g. 'uuid_generate_v1', 'uuid_generate_v4', etc. Default is 'uuid_generate_v4'\n * @param {Array|String} [loader.allowedSchemas] - Table/view schema whitelist.\n * @param {Array|String} [loader.whitelist] - Table/view name whitelist.\n * @param {Array|String} [loader.blacklist] - Table/view name blacklist.\n * @param {Array|String} [loader.exceptions] - Table/view blacklist exceptions.\n * @param {Array|String} [loader.functionWhitelist] - Function name whitelist.\n * @param {Array|String} [loader.functionBlacklist] - Function name blacklist.\n * @param {Boolean} [loader.enhancedFunctions] - Streamline function return values.\n * @param {Boolean} [loader.excludeFunctions] - Ignore functions entirely.\n * @param {Boolean} [loader.excludeMatViews] - [DEPRECATED] Ignore materialized views.\n * @param {Object} [driverConfig] - A pg-promise configuration object.\n */\n\nconst Database = function (connection = {}, loader = {}, driverConfig = {}) {\n  connection = typeof connection === 'string' ? {\n    connectionString: connection\n  } : connection; // If connectionString is defined in the configuration object, these defaults will be ignored\n\n  _.defaults(connection, {\n    host: 'localhost',\n    port: 5432\n  });\n\n  ['blacklist', 'whitelist', 'functionBlacklist', 'functionWhitelist', 'exceptions'].forEach(key => {\n    loader[key] = getFilterString(loader[key]);\n  });\n  loader.allowedSchemas = getFilterString(loader.allowedSchemas);\n  loader.scripts = loader.scripts || path.join(process.cwd(), 'db');\n  this.objects = [];\n  this.loader = loader;\n  this.driverConfig = driverConfig;\n  this.pgp = pgp(driverConfig);\n  this.instance = this.pgp(connection);\n  this.$p = this.instance.$config.promise;\n};\n/**\n * Attach an entity to the connected instance.\n *\n * @param {Object|Array} entities - New Entity or list of Entities to add to the\n * instance.\n * @return {Array} All added entities.\n */\n\n\nDatabase.prototype.attach = function (entities) {\n  entities = _.castArray(entities);\n  this.objects = this.objects.concat(entities);\n  return entities.map(entity => {\n    let executor;\n\n    if (entity instanceof Executable) {\n      executor = function () {\n        return entity.invoke(...arguments);\n      }; // make sure we can distinguish functions from scripts, since multiple\n      // signatures are allowed for the former but not the latter\n\n\n      executor.isDatabaseFunction = entity.isDatabaseFunction;\n      executor.executable = entity;\n    } // do we already have something at this location?\n\n\n    const existing = _.get(this, entity.path);\n\n    if (!existing) {\n      _.set(this, entity.path, executor || entity);\n    } else {\n      // first make sure we're not about to override an existing executor or\n      // object API function (findOne etc) with a new executor _unless_ it's a\n      // case of a database function with multiple signatures\n      if (executor && typeof existing === 'function' && executor.isDatabaseFunction !== existing.isDatabaseFunction) {\n        throw new Error(\"attempt to overwrite function at \".concat(entity.path, \" is not allowed\"));\n      } // determine which entity is more \"advanced\": executor functions win out,\n      // followed by Tables, which in turn define a superset of Readable\n      // functionality. If neither the new nor the existing entity are anything\n      // interesting, just use the new entity.\n\n\n      const both = [executor || entity, existing];\n      const winner = both.find(e => typeof e === 'function') || both.find(e => e instanceof Writable) || both.find(e => e instanceof Readable) || entity;\n      const loser = both.find(e => e !== winner); // determine the appropriate prototype for the new object based on the\n      // types of _both_ entities: Writable > Readable > Executable > Entity.\n\n      const newProto = _.cond([[() => both.some(e => e instanceof Writable), _.constant(Writable)], [() => both.some(e => e instanceof Readable), _.constant(Readable)], [() => both.some(e => typeof e === 'function'), _.constant(Executable)], [_.stubTrue, _.constant(Entity)]])(); // if we are about to change the type of this node in the entity tree,\n      // make sure that nothing new coming in from the new entity will override\n      // an already-attached function\n\n\n      const isNewType = existing.prototype !== newProto && !(_.isFunction(existing) && newProto === Executable);\n\n      if (isNewType) {\n        for (const prop in entity) {\n          if (typeof entity[prop] === 'function' && typeof _.get(this, \"\".concat(entity.path, \".\").concat(prop)) === 'function') {\n            throw new Error(\"collision of \".concat(entity.path, \".\").concat(prop, \" with previously-attached function\"));\n          }\n        }\n      } // set the new prototype and transfer properties of the object which won't\n      // stay/become the node onto the object which will\n\n\n      Object.setPrototypeOf(winner, newProto.prototype);\n\n      _.assign(winner, loser); // update the entity tree\n\n\n      _.set(this, entity.path, winner);\n    }\n\n    return executor || entity;\n  });\n};\n/**\n * Forget an entity.\n *\n * @param {String} entityPath - Path to the entity.\n */\n\n\nDatabase.prototype.detach = function (entityPath) {\n  _.unset(this, entityPath);\n\n  this.objects = _.reject(this.objects, e => e.path === entityPath);\n};\n/**\n * Remove all attached entities from the instance, returning it to the pre-\n * introspection state.\n */\n\n\nDatabase.prototype.clean = function () {\n  this.objects = this.objects.reduce((nothing, entity) => {\n    const segment = entity.path.split('.')[0];\n\n    if (this[segment]) {\n      delete this[segment];\n    }\n\n    return [];\n  }, []);\n};\n/**\n * Synchronize the database API with the current state by scanning for tables,\n * views, functions, and scripts. Objects and files which no longer exist are\n * cleared and new objects and files added.\n *\n * @return {Promise} The refreshed database.\n */\n\n\nDatabase.prototype.reload = function () {\n  this.clean(); // cache pg-promise receive option config\n\n  let receiveOptionCached;\n\n  if (this.instance.$config && this.instance.$config.options) {\n    receiveOptionCached = this.instance.$config.options.receive;\n    delete this.instance.$config.options.receive;\n  }\n\n  const initPromises = [// get the current schema; this is usually 'public' unless someone\n  // configured search_path in Postgres\n  this.query('SELECT current_schema').then(([{\n    current_schema\n  }]) => {\n    this.currentSchema = current_schema;\n  }), this.query('SHOW server_version').then(([{\n    server_version\n  }]) => {\n    this.serverVersion = server_version;\n  })];\n\n  if (_.isEmpty(introspectors)) {\n    // load our introspectors. These are stored on the module since they don't\n    // change between reloads.\n    initPromises.push(this.$p((resolve, reject) => {\n      glob(path.join(__dirname, '/scripts/*.sql'), (err, files) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(files);\n        }\n      });\n    }).then(files => {\n      files.forEach(file => {\n        introspectors[path.basename(file)] = new pgp.QueryFile(file, {\n          minify: true\n        });\n      });\n    }));\n  } // attach the introspection scripts\n\n\n  this.loader.queryFiles = introspectors;\n  return this.$p.all(initPromises).then(() => {\n    // run introspections and flatten the results into a single list of Entities\n    return this.$p.all(['tables', 'views', 'functions', 'scripts', 'sequences', 'enums'].map(loader => {\n      // first find and execute the loader function\n      const loaderFunc = require(\"./loader/\".concat(loader)); // eslint-disable-line global-require\n\n\n      return loaderFunc(this).then(loaded => {\n        // enums get attached at a fixed point\n        if (loader === 'enums') {\n          this.enums = loaded;\n          return [];\n        } // otherwise, map whatever it got into objects defined by ctor\n\n\n        return loaded.map(obj => {\n          obj = _.extend(obj, this.loader);\n          obj.db = this;\n          obj.path = !obj.schema || obj.schema === this.currentSchema ? obj.name : [obj.schema, obj.name].join('.');\n          obj.loader = loader;\n\n          if (loader === 'sequences') {\n            return new (Function.prototype.bind.apply(Sequence, [null, obj]))();\n          }\n\n          if (Object.prototype.hasOwnProperty.call(obj, 'is_insertable_into')) {\n            if (obj.is_insertable_into) {\n              return new (Function.prototype.bind.apply(Writable, [null, obj]))();\n            }\n\n            return new (Function.prototype.bind.apply(Readable, [null, obj]))();\n          }\n\n          return new (Function.prototype.bind.apply(Executable, [null, obj]))();\n        });\n      });\n    }, [])).then(groupedObjects => {\n      return _.flatten(groupedObjects);\n    }).then(objs => {\n      this.attach(objs); // restore pg-promise receive option config\n      // eslint-disable-next-line no-extra-boolean-cast\n\n      if (!!receiveOptionCached) {\n        this.instance.$config.options.receive = receiveOptionCached;\n      }\n\n      return this;\n    });\n  });\n};\n/**\n * Determine whether the connected PostgreSQL server is of at least the\n * specified version. Used for automatically enabling features in the loaders,\n * notably procedures (in the function loader) and materialized views.\n *\n * @param {String} target - Target version to match or exceed.\n * @return {Boolean} Whether the target version has been matched or exceeded.\n */\n\n\nDatabase.prototype.serverAtLeast = function (target) {\n  const tokens = target.split('.');\n  return this.serverVersion.split('.').reduce((acc, token, i) => {\n    const c = Number(token);\n    const t = Number(tokens[i]) || 0;\n\n    if (c > t) {\n      // candidate segment > target segment: if we've already gone negative,\n      // it's too late (the target version had a higher value in an earlier\n      // segment, meaning it's higher overall). Otherwise, we're still good.\n      return acc < 0 ? -1 : 1;\n    } else if (c < t) {\n      // candidate segment < target segment: as long as we've gone positive,\n      // rather than just matched segment for segment, we're still positive;\n      // otherwise, the target version is higher overall.\n      return acc > 0 ? 1 : -1;\n    } // candidate segment = target segment: nothing changes.\n\n\n    return acc;\n  }, 0) > -1; // at 0 the target has been met; at 1 it's been exceeded\n};\n/**\n * List all the tables attached to the connected instance.\n *\n * @return {Array} A list of table paths.\n */\n\n\nDatabase.prototype.listTables = function () {\n  return this.objects.reduce((names, obj) => {\n    if (obj.loader === 'tables') {\n      names.push(obj.path);\n    }\n\n    return names;\n  }, []);\n};\n/**\n * List all the views attached to the connected instance.\n *\n * @return {Array} A list of view paths.\n */\n\n\nDatabase.prototype.listViews = function () {\n  return this.objects.reduce((names, obj) => {\n    if (obj.loader === 'views') {\n      names.push(obj.path);\n    }\n\n    return names;\n  }, []);\n};\n/**\n * List all the functions and scripts attached to the connected instance.\n *\n * @return {Array} A list of function paths.\n */\n\n\nDatabase.prototype.listFunctions = function () {\n  return this.objects.reduce((names, obj) => {\n    if (obj instanceof Executable) {\n      names.push(obj.path);\n    }\n\n    return names;\n  }, []);\n};\n/**\n * List all the non-pk sequences attached to the connected instance.\n *\n * @return {Array} A list of sequence names.\n */\n\n\nDatabase.prototype.listSequences = function () {\n  return this.objects.reduce((names, obj) => {\n    if (obj.loader === 'sequences') {\n      names.push(obj.path);\n    }\n\n    return names;\n  }, []);\n};\n/**\n * Execute a query.\n *\n * @param {Select|Insert|Update|Delete|String} query - One of the four statement\n * objects, or a string containing a prepared SQL statement.\n * @param {Array} [params] - An array of the prepared statement parameters, if\n * applicable.\n * @param {Object} [options] - If using raw SQL, a subset of query options may be\n * applied.\n * @param {Boolean} options.document - This is a query against a document\n * table.\n * @param {Boolean} options.single - True to return a single result object\n * instead of an array of results.\n * @param {Boolean} options.stream - True to return a stream instead of a\n * resultset.\n * @return {Promise} Query results.\n */\n\n\nDatabase.prototype.query = function (query, params = undefined, options = {}) {\n  let sql;\n\n  if (_.isString(query)) {\n    sql = query;\n  } else if (query instanceof this.pgp.QueryFile) {\n    if (options.stream) {\n      if (_.isPlainObject(params)) {\n        return Promise.reject(new Error('Named parameters are not supported when streaming QueryFiles'));\n      } // query files can't be streamed directly, so extract the text at runtime\n\n\n      sql = query[this.pgp.as.ctf.toPostgres]();\n    } else {\n      sql = query;\n    }\n  } else {\n    try {\n      sql = query.format();\n    } catch (err) {\n      return this.$p.reject(err);\n    }\n\n    params = query.params;\n    options = query;\n  }\n\n  if (options.build) {\n    return this.$p.resolve({\n      sql,\n      params\n    });\n  }\n\n  let qrm;\n\n  if (options.single) {\n    qrm = this.pgp.queryResult.one | this.pgp.queryResult.none;\n  } else {\n    qrm = this.pgp.queryResult.any;\n  }\n\n  let promise;\n\n  if (options.stream) {\n    const qs = new QueryStream(sql, params);\n    promise = this.$p((resolve, reject) => this.instance.stream(qs, classicStream => {\n      const transformStream = new stream.Transform({\n        objectMode: true\n      });\n\n      transformStream._transform = (a, e, c) => {\n        transformStream.push(a);\n        return c();\n      };\n\n      resolve(classicStream.pipe(transformStream));\n    }).catch(reject));\n  } else {\n    promise = this.instance.query(sql, params, qrm);\n  }\n\n  if (options.document) {\n    promise = promise.then(docify);\n  } else if (options.decompose && !options.stream) {\n    promise = promise.then(decompose.bind(null, options.decompose));\n\n    if (options.single) {\n      // decomposition requires an array, so pull it back out\n      promise = promise.then(array => array[0]);\n    }\n  }\n\n  return promise;\n};\n/**\n * Begin a task, returning a copy of the connected instance which will route all\n * queries made in the callback through the task scope.\n *\n * @param {Function} callback - A callback containing Massive API calls and SQL\n * queries to be made within the task scope.\n * @param {Object} [options] - {@link https://vitaly-t.github.io/pg-promise/Database.html#task|Task options}.\n * @return {Promise} A promise for the completed task, which will be fulfilled\n * if it succeeds and commits or rejected if it rolls back.\n */\n\n\nDatabase.prototype.withConnection = function (callback, options = {}) {\n  const args = pgp.utils.taskArgs([options, task => {\n    const withTask = this.clone(task);\n    return callback(withTask);\n  }]);\n  return this.instance.task.apply(this, args);\n};\n/**\n * Begin a transaction, returning a copy of the connected instance which will\n * route all queries made in the callback through the transaction scope.\n *\n * @param {Function} callback - A callback containing Massive API calls and SQL\n * queries to be made within the transaction scope.\n * @param {Object} [options] - {@link https://vitaly-t.github.io/pg-promise/Database.html#tx|Transaction options}.\n * @return {Promise} A promise for the completed transaction, which will be\n * fulfilled if it succeeds and commits or rejected if it rolls back.\n */\n\n\nDatabase.prototype.withTransaction = function (callback, options = {}) {\n  const args = pgp.utils.taskArgs([options, tx => {\n    const withTx = this.clone(tx);\n    return callback(withTx);\n  }]);\n  return this.instance.tx.apply(this, args);\n};\n/**\n * Clones the database handle for a task or transaction, replacing the internal\n * instance with a dedicated connection.\n *\n * @param {Object} conn - A pg-promise task or transaction object.\n * @return {Database} A cloned database object.\n */\n\n\nDatabase.prototype.clone = function (conn) {\n  const executables = [];\n\n  const cloneDb = _.cloneDeepWith(this, prop => {\n    if (typeof prop === 'function' && Object.prototype.hasOwnProperty.call(prop, 'executable')) {\n      executables.push(_.cloneWith(prop.executable, (val, key) => {\n        // QueryFiles are not cloneable, but since the only thing we actually\n        // need to change is the db instance we can keep the original ref\n        if (key === 'sql') {\n          return val;\n        }\n\n        return undefined;\n      }));\n    }\n  });\n\n  cloneDb.instance = conn;\n  executables.forEach(e => {\n    cloneDb.detach(e.path);\n    e.db = cloneDb;\n    cloneDb.attach(e);\n  });\n  return cloneDb;\n};\n/**\n * Create an extension.\n *\n * @param {String} extensionName - A valid extension name. Example 'uuid-ossp'\n * @return {Promise} A promise which resolves when the extension has been created.\n */\n\n\nDatabase.prototype.createExtension = function (extensionName) {\n  return this.query(\"CREATE EXTENSION IF NOT EXISTS \\\"\".concat(extensionName, \"\\\";\"));\n};\n/**\n * Drop an extension.\n *\n * @param {String} extensionName - A valid extension name. Example 'uuid-ossp'\n * @return {Promise} A promise which resolves when the extension has been droped.\n */\n\n\nDatabase.prototype.dropExtension = function (extensionName) {\n  return this.query(\"DROP EXTENSION IF EXISTS \\\"\".concat(extensionName, \"\\\";\"));\n};\n\nconst extractTable = function (collection, db) {\n  if (collection.startsWith(\"\".concat(db.currentSchema, \".\"))) {\n    collection = collection.substring(db.currentSchema.length + 1);\n  }\n\n  return _.get(db, collection);\n};\n/**\n * Save a document.\n *\n * @param {String} collection - Document table name to save to. If it does not\n * already exist, it will be created.\n * @param {Object} doc - A JSON document.\n * @return {Promise} The saved document.\n */\n\n\nDatabase.prototype.saveDoc = function (collection, doc) {\n  const potentialTable = extractTable(collection, this);\n\n  if (potentialTable) {\n    return potentialTable.saveDoc(doc);\n  }\n\n  return this.createDocumentTable(collection).then(() => this.saveDoc(collection, doc));\n};\n/**\n * Save multiple documents.\n *\n * @param {String} collection - Document table name to save to. If it does not\n * already exist, it will be created.\n * @param {Object} docs - JSON documents.\n * @return {Promise} The saved documents.\n */\n\n\nDatabase.prototype.saveDocs = function (collection, docs) {\n  const potentialTable = extractTable(collection, this);\n\n  if (potentialTable) {\n    return potentialTable.saveDocs(docs);\n  }\n\n  return this.createDocumentTable(collection).then(() => this.saveDocs(collection, docs));\n};\n/**\n * Generate SQL to define UUID primary key default\n *\n * @param {String} pkType - Primary key data type, 'serial' or 'uuid' expected\n * @param {String} uuidV - The UUID variant/version (default = 'v4'), typically 'v1', 'v1mc' or 'v4'\n * @return {String} SQL to define primary key default.\n */\n\n\nfunction getDefaultSQLforUUID(pkType, uuidV) {\n  if (pkType !== 'uuid') {\n    return '';\n  }\n\n  let sqlDefault = '';\n\n  switch (uuidV) {\n    case 'v1':\n      sqlDefault = 'DEFAULT uuid_generate_v1()';\n      break;\n\n    case 'v1mc':\n      sqlDefault = 'DEFAULT uuid_generate_v1mc()';\n      break;\n\n    case 'v3':\n      throw new Error('v3 UUIDs are not currently supported');\n\n    case 'v4':\n      sqlDefault = 'DEFAULT uuid_generate_v4()';\n      break;\n\n    case 'v5':\n      throw new Error('v5 UUIDs are not currently supported');\n\n    default:\n      sqlDefault = 'DEFAULT uuid_generate_v4()';\n  }\n\n  return sqlDefault;\n}\n/**\n * Create a new document table and attach it to the Database for usage.\n *\n * @param {String} location - Name of the table to create. Unless the schema is\n * specified in a qualified path, current schema (usually 'public') is assumed.\n * @return {Promise} The added table.\n */\n\n\nDatabase.prototype.createDocumentTable = function (location) {\n  const splits = location.split('.');\n  const tableName = splits.pop();\n  const schemaName = splits.pop() || this.currentSchema;\n  const indexName = tableName.replace('.', '_');\n  const documentPkType = this.loader.documentPkType || 'serial';\n  const uuidVersion = this.loader.uuidVersion;\n  const sqlDefault = getDefaultSQLforUUID(documentPkType, uuidVersion);\n  return this.query(this.loader.queryFiles['document-table.sql'], {\n    schema: schemaName,\n    table: tableName,\n    index: indexName,\n    pkType: documentPkType,\n    pkDefault: sqlDefault\n  }).then(() => this.attach(new Writable({\n    db: this,\n    schema: schemaName,\n    name: tableName,\n    columns: ['id', 'body', 'search', 'created_at'],\n    pk: ['id']\n  }))).then(added => {\n    return added[0];\n  });\n};\n/**\n * Drop a table and remove it from the Database.\n *\n * @param {String} tablePath - Path to the table (including schema, if not\n * public).\n * @param {Object} options - Additional options.\n * @param {Boolean} options.cascade - True to drop any objects that depend on\n * the table.\n * @return {Promise} A promise which resolves when the table has been removed.\n */\n\n\nDatabase.prototype.dropTable = function (tablePath, options) {\n  const cascade = options && options.cascade;\n  return this.query(\"DROP TABLE IF EXISTS \".concat(tablePath, \" \").concat(cascade ? 'CASCADE' : '', \";\")).then(() => {\n    this.detach(tablePath);\n  });\n};\n/**\n * Create a new schema in the database.\n *\n * @param {String} schemaName - A valid schema name.\n * @return {Promise} A promise which resolves when the schema has been added.\n */\n\n\nDatabase.prototype.createSchema = function (schemaName) {\n  return this.query(\"CREATE SCHEMA IF NOT EXISTS \".concat(schemaName, \";\")).then(() => {\n    this[schemaName] = {};\n  });\n};\n/**\n * Drop a schema and remove it and its owned objects from the Database.\n *\n * @param {String} schemaName - A valid schema name to remove.\n * @param {Object} options - Additional options.\n * @param {Boolean} options.cascade - True to drop any objects that depend on\n * the schema.\n * @return {Promise} A promise which resolves when the schema and all owned\n * objects have been removed.\n */\n\n\nDatabase.prototype.dropSchema = function (schemaName, options = {}) {\n  return this.query(\"DROP SCHEMA IF EXISTS \".concat(schemaName, \" \").concat(options.cascade ? 'CASCADE' : '', \";\")).then(() => {\n    // Remove all objects from the namespace\n    if (this[schemaName]) {\n      _.each(Object.keys(this[schemaName]), key => {\n        this.detach(\"\".concat(schemaName, \".\").concat(key));\n      });\n    } // Remove the schema from the namespace\n\n\n    delete this[schemaName];\n  });\n};\n\nexports = module.exports = Database;","map":null,"metadata":{},"sourceType":"script"}