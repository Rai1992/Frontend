{"ast":null,"code":"'use strict';\n\nvar npm = {\n  u: require('util'),\n  os: require('os'),\n  utils: require('../utils/static')\n};\n/**\r\n * @interface errors.BatchError\r\n * @augments external:Error\r\n * @description\r\n * This type represents all errors rejected by method {@link batch}, except for {@link external:TypeError TypeError}\r\n * when the method receives invalid input parameters.\r\n *\r\n * @property {string} name\r\n * Standard {@link external:Error Error} property - error type name = `BatchError`.\r\n *\r\n * @property {string} message\r\n * Standard {@link external:Error Error} property - the error message.\r\n *\r\n * It represents the message of the first error encountered in the batch, and is a safe\r\n * version of using `first.message`.\r\n *\r\n * @property {string} stack\r\n * Standard {@link external:Error Error} property - the stack trace.\r\n *\r\n * @property {array} data\r\n * Array of objects `{success, result, [origin]}`:\r\n * - `success` = true/false, indicates whether the corresponding value in the input array was resolved.\r\n * - `result` = resolved data, if `success`=`true`, or else the rejection reason.\r\n * - `origin` - set only when failed as a result of an unsuccessful call into the notification callback\r\n *    (parameter `cb` of method {@link batch})\r\n *\r\n * The array has the same size as the input one that was passed into method {@link batch}, providing direct mapping.\r\n *\r\n * @property {} stat\r\n * Resolution Statistics.\r\n *\r\n * @property {number} stat.total\r\n * Total number of elements in the batch.\r\n *\r\n * @property {number} stat.succeeded\r\n * Number of resolved values in the batch.\r\n *\r\n * @property {number} stat.failed\r\n * Number of rejected values in the batch.\r\n *\r\n * @property {number} stat.duration\r\n * Time in milliseconds it took to settle all values.\r\n *\r\n * @property {} first\r\n * The very first error within the batch, with support for nested batch results, it is also the same error\r\n * as $[promise.all] would provide.\r\n *\r\n * @see {@link batch}\r\n *\r\n */\n\nfunction BatchError(result, errors, duration) {\n  this.data = result;\n  /**\r\n   * @method errors.BatchError.getErrors\r\n   * @description\r\n   * Returns the complete list of errors only.\r\n   *\r\n   * It supports nested batch results, presented as a sub-array.\r\n   *\r\n   * @returns {array}\r\n   */\n\n  this.getErrors = function () {\n    var err = new Array(errors.length);\n\n    for (var i = 0; i < errors.length; i++) {\n      err[i] = result[errors[i]].result;\n\n      if (err[i] instanceof BatchError) {\n        err[i] = err[i].getErrors();\n      }\n    }\n\n    npm.utils.extend(err, '$isErrorList', true);\n    return err;\n  };\n\n  var e = this.getErrors(),\n      first = e[0];\n\n  while (first && first.$isErrorList) {\n    first = first[0];\n  } // we do not show it within the inspect, because when the error\n  // happens for a nested result, the output becomes a mess.\n\n\n  this.first = first;\n\n  if (first instanceof Error) {\n    this.message = first.message;\n  } else {\n    if (typeof first !== 'string') {\n      first = npm.u.inspect(first);\n    }\n\n    this.message = first;\n  }\n\n  this.stat = {\n    total: result.length,\n    succeeded: result.length - e.length,\n    failed: e.length,\n    duration: duration\n  };\n  Error.captureStackTrace(this, BatchError);\n}\n\nnpm.u.inherits(BatchError, Error);\nBatchError.prototype.name = 'BatchError';\n/**\r\n * @method errors.BatchError.toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the error.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * The output is an abbreviated version of the error, because the complete error\r\n * is often too much for displaying or even logging, as a batch can be of any size.\r\n * Therefore, only errors are rendered from the `data` property, alongside their indexes,\r\n * and only up to the first 5, to avoid polluting the screen or the log file.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\n\nBatchError.prototype.toString = function (level) {\n  level = level > 0 ? parseInt(level) : 0;\n  var gap0 = npm.utils.messageGap(level),\n      gap1 = npm.utils.messageGap(level + 1),\n      gap2 = npm.utils.messageGap(level + 2),\n      lines = ['BatchError {', gap1 + 'stat: { total: ' + this.stat.total + ', succeeded: ' + this.stat.succeeded + ', failed: ' + this.stat.failed + ', duration: ' + this.stat.duration + ' }', gap1 + 'errors: [']; // In order to avoid polluting the error log or the console, \n  // we limit the log output to the top 5 errors:\n\n  var counter = 0,\n      maxErrors = 5;\n  this.data.forEach(function (d, index) {\n    if (!d.success && counter < maxErrors) {\n      lines.push(gap2 + index + ': ' + npm.utils.formatError(d.result, level + 2));\n      counter++;\n    }\n  });\n  lines.push(gap1 + ']');\n  lines.push(gap0 + '}');\n  return lines.join(npm.os.EOL);\n};\n\nnpm.utils.addInspection(BatchError, function () {\n  return this.toString();\n});\nmodule.exports = BatchError;","map":null,"metadata":{},"sourceType":"script"}