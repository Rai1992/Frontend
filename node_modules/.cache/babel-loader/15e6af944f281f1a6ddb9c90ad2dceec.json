{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n'use strict';\n\nconst npm = {\n  path: require('path'),\n  util: require('util'),\n  patterns: require('../patterns')\n}; ////////////////////////////////////////////\n// Simpler check for null/undefined;\n\nfunction isNull(value) {\n  return value === null || value === undefined;\n} ////////////////////////////////////////////////////////\n// Verifies parameter for being a non-empty text string;\n\n\nfunction isText(txt) {\n  return txt && typeof txt === 'string' && /\\S/.test(txt);\n} ///////////////////////////////////////////////////////////\n// Approximates the environment as being for development.\n//\n// Proper configuration is having NODE_ENV = 'development', but this\n// method only checks for 'dev' being present, and regardless of the case.\n\n\nfunction isDev() {\n  const env = global.process.env.NODE_ENV || '';\n  return env.toLowerCase().indexOf('dev') !== -1;\n} ///////////////////////////////////////////////////\n// Locks all properties in an object to read-only,\n// or freezes the entire object for any changes.\n\n\nfunction lock(obj, freeze, options) {\n  if (options && options.noLocking) {\n    return;\n  }\n\n  if (freeze) {\n    Object.freeze(obj); // freeze the entire object, permanently;\n  } else {\n    const desc = {\n      writable: false,\n      configurable: false,\n      enumerable: true\n    };\n\n    for (const p in obj) {\n      Object.defineProperty(obj, p, desc);\n    }\n  }\n} /////////////////////////////////////////////\n// Adds properties from source to the target,\n// making them read-only and enumerable.\n\n\nfunction addReadProperties(target, source) {\n  for (const p in source) {\n    addReadProp(target, p, source[p]);\n  }\n} ///////////////////////////////////////////////////////\n// Adds a read-only, non-deletable enumerable property.\n\n\nfunction addReadProp(obj, name, value, hidden) {\n  Object.defineProperty(obj, name, {\n    value,\n    configurable: false,\n    enumerable: !hidden,\n    writable: false\n  });\n} //////////////////////////////////////////////////////////////\n// Converts a connection string or object into its safe copy:\n// if password is present, it is masked with symbol '#'.\n\n\nfunction getSafeConnection(cn) {\n  if (typeof cn === 'object') {\n    const copy = Object.assign({}, cn);\n\n    if (typeof copy.password === 'string') {\n      copy.password = copy.password.replace(/./g, '#');\n    }\n\n    if (typeof copy.connectionString === 'string') {\n      copy.connectionString = maskPassword(copy.connectionString);\n    }\n\n    return copy;\n  }\n\n  return maskPassword(cn);\n} ///////////////////////////////////////////////////////////\n// Replaces password letters with # in a connection string.\n\n\nfunction maskPassword(connectionString) {\n  return connectionString.replace(/:(?![/])([^@]+)/, (_, m) => {\n    return ':' + new Array(m.length + 1).join('#');\n  });\n} ///////////////////////////////////////////\n// Returns a space gap for console output;\n\n\nfunction messageGap(level) {\n  return ' '.repeat(level * 4);\n} /////////////////////////////////////////\n// Provides platform-neutral inheritance;\n\n\nfunction inherits(child, parent) {\n  child.prototype.__proto__ = parent.prototype;\n} ///////////////////////////////////////////////////////////////////////////\n// Checks if the path is absolute;\n//\n// Though we do test it, we still skip it from the coverage,\n// because it is platform-specific.\n//\n// istanbul ignore next\n\n\nfunction isPathAbsolute(path) {\n  // Based on: https://github.com/sindresorhus/path-is-absolute\n  if (process.platform === 'win32') {\n    const result = npm.patterns.splitDevice.exec(path);\n    const device = result[1] || '';\n    const isUnc = !!device && device.charAt(1) !== ':';\n    return !!result[2] || isUnc;\n  }\n\n  return path.charAt(0) === '/';\n}\n\nfunction getLocalStack(startIdx) {\n  // from the call stack, we take only lines starting with the client's\n  // source code, and only those that contain a full path inside brackets,\n  // indicating a reference to the client's source code:\n  return new Error().stack.split('\\n').slice(startIdx).filter(line => {\n    return line.match(/\\(.*(\\\\+|\\/+).*\\)/); // contains \\ or / inside ()\n  }).join('\\n');\n} //////////////////////////////\n// Internal error container;\n\n\nfunction InternalError(error) {\n  this.error = error;\n} /////////////////////////////////////////////////////////////////\n// Parses a property name, and gets its name from the object,\n// if the property exists. Returns object {valid, has, target, value}:\n//  - valid - true/false, whether the syntax is valid\n//  - has - a flag that property exists; set when 'valid' = true\n//  - target - the target object that contains the property; set when 'has' = true\n//  - value - the value; set when 'has' = true\n\n\nfunction getIfHas(obj, prop) {\n  const result = {\n    valid: true\n  };\n\n  if (prop.indexOf('.') === -1) {\n    result.has = prop in obj;\n    result.target = obj;\n\n    if (result.has) {\n      result.value = obj[prop];\n    }\n  } else {\n    const names = prop.split('.');\n    let missing, target;\n\n    for (let i = 0; i < names.length; i++) {\n      const n = names[i];\n\n      if (!n) {\n        result.valid = false;\n        return result;\n      }\n\n      if (!missing && hasProperty(obj, n)) {\n        target = obj;\n        obj = obj[n];\n      } else {\n        missing = true;\n      }\n    }\n\n    result.has = !missing;\n\n    if (result.has) {\n      result.target = target;\n      result.value = obj;\n    }\n  }\n\n  return result;\n} /////////////////////////////////////////////////////////////////////////\n// Checks if the property exists in the object or value or its prototype;\n\n\nfunction hasProperty(value, prop) {\n  return value && typeof value === 'object' && prop in value || value !== null && value !== undefined && value[prop] !== undefined;\n} ////////////////////////////////////////////////////////\n// Adds prototype inspection, with support of the newer\n// Custom Inspection, which was added in Node.js 6.x\n\n\nfunction addInspection(type, cb) {\n  // istanbul ignore next;\n  if (npm.util.inspect.custom) {\n    // Custom inspection is supported:\n    type.prototype[npm.util.inspect.custom] = cb;\n  } else {\n    // Use classic inspection:\n    type.prototype.inspect = cb;\n  }\n} /////////////////////////////////////////////////////////////////////////////////////////\n// Identifies a general connectivity error, after which no more queries can be executed.\n// This is primarily to detect when to skip executing ROLLBACK for a failed transaction.\n\n\nfunction isConnectivityError(err) {\n  const code = err && typeof err.code === 'string' && err.code;\n  const cls = code && code.substr(0, 2); // Error Class\n  // istanbul ignore next (we cannot test-cover all error cases):\n\n  return code === 'ECONNRESET' || cls === '08' || cls === '57' && code !== '57014'; // Code 'ECONNRESET' - Connectivity issue handled by the driver.\n  // Class 08 - Connection Exception.\n  // Class 57 - Operator Intervention (except for 57014, for cancelled queries).\n  //\n  // ERROR CODES: https://www.postgresql.org/docs/9.6/static/errcodes-appendix.html\n}\n\nconst exp = {\n  getIfHas,\n  addInspection,\n  InternalError,\n  getLocalStack,\n  isPathAbsolute,\n  lock,\n  isText,\n  isNull,\n  isDev,\n  addReadProp,\n  addReadProperties,\n  getSafeConnection,\n  messageGap,\n  inherits,\n  isConnectivityError\n};\nconst mainFile = process.argv[1]; // istanbul ignore next\n\nexp.startDir = mainFile ? npm.path.dirname(mainFile) : process.cwd();\nObject.freeze(exp);\nmodule.exports = exp;","map":null,"metadata":{},"sourceType":"script"}