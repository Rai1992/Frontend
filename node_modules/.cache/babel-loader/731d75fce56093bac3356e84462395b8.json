{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst parseKey = require('../util/parse-key');\n/**\n * Generate an ORDER BY clause from an array of order segments.\n *\n * @param {Array} order - The sort definition.\n * @param {String} order.field A column name which will be safely quoted, OR\n * @param {String} order.expr A raw expression, which will NOT be quoted (this will be vulnerable to SQL injection if user input is interpolated). Exprs ignore useBody.\n * @param {String} [order.type] A cast type to be applied before ordering.\n * @param {String} [order.direction] \"asc\" (the default) or \"desc\".\n * @param {Boolean} [useBody] - If true and using the Array form of order,\n * will generate order based on a document body.\n * @return {String} An ORDER BY clause.\n */\n\n\nexports = module.exports = (order, useBody) => {\n  if (!order) {\n    return '';\n  }\n\n  return 'ORDER BY ' + _.reduce(order, function (acc, val) {\n    const direction = val.direction && val.direction.toLowerCase() === 'desc' ? ' DESC' : ' ASC';\n    const nulls = val.nulls ? \" NULLS \".concat(val.nulls === 'first' ? 'FIRST' : 'LAST') : '';\n    acc.push(exports.fullAttribute(val, useBody) + direction + nulls);\n    return acc;\n  }, []).join(',');\n};\n\nexports.fullAttribute = function (orderObj, useBody) {\n  let field;\n\n  if (orderObj.expr) {\n    field = orderObj.expr;\n  } else if (useBody) {\n    field = \"body->>'\".concat(orderObj.field, \"'\");\n  } else if (orderObj.field) {\n    const parsed = parseKey(orderObj.field, () => {});\n    field = parsed.field;\n  }\n\n  if (orderObj.type) {\n    return \"(\".concat(field, \")::\").concat(orderObj.type);\n  }\n\n  return field;\n};","map":null,"metadata":{},"sourceType":"script"}