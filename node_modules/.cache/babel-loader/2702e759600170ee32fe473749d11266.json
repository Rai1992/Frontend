{"ast":null,"code":"'use strict';\n\nvar Cursor = require('pg-cursor');\n\nvar Readable = require('stream').Readable;\n\nclass PgQueryStream extends Readable {\n  constructor(text, values, options) {\n    super(Object.assign({\n      objectMode: true\n    }, options));\n    this.cursor = new Cursor(text, values);\n    this._reading = false;\n    this._closed = false;\n    this.batchSize = (options || {}).batchSize || 100; // delegate Submittable callbacks to cursor\n\n    this.handleRowDescription = this.cursor.handleRowDescription.bind(this.cursor);\n    this.handleDataRow = this.cursor.handleDataRow.bind(this.cursor);\n    this.handlePortalSuspended = this.cursor.handlePortalSuspended.bind(this.cursor);\n    this.handleCommandComplete = this.cursor.handleCommandComplete.bind(this.cursor);\n    this.handleReadyForQuery = this.cursor.handleReadyForQuery.bind(this.cursor);\n    this.handleError = this.cursor.handleError.bind(this.cursor);\n  }\n\n  submit(connection) {\n    this.cursor.submit(connection);\n  }\n\n  close(callback) {\n    this._closed = true;\n\n    const cb = callback || (() => this.emit('close'));\n\n    this.cursor.close(cb);\n  }\n\n  _read(size) {\n    if (this._reading || this._closed) {\n      return false;\n    }\n\n    this._reading = true;\n    const readAmount = Math.max(size, this.batchSize);\n    this.cursor.read(readAmount, (err, rows) => {\n      if (this._closed) {\n        return;\n      }\n\n      if (err) {\n        return this.emit('error', err);\n      } // if we get a 0 length array we've read to the end of the cursor\n\n\n      if (!rows.length) {\n        this._closed = true;\n        setImmediate(() => this.emit('close'));\n        return this.push(null);\n      } // push each row into the stream\n\n\n      this._reading = false;\n\n      for (var i = 0; i < rows.length; i++) {\n        this.push(rows[i]);\n      }\n    });\n  }\n\n}\n\nmodule.exports = PgQueryStream;","map":null,"metadata":{},"sourceType":"script"}